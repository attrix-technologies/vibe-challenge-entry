# Geotab Vibe Coding: Hero to Hero 2.0

## My Vibe-Coding Journey

Impressed by your demo and inspired to use skills, claude.md and other resources to improve our typical add-in development workflow, I decided to use this contest as a means to stop our day-to-day routine of reusing the same generator-addin script to boilerplate new add-ins (with its problems and limitations), and instead use the full potential of AI to create a new add-in from scratch. For us, this always means external add-ins (no embedded source) - this always means multi-lingual, and since last year this also means leveraging React + Zenith. When we create a new add-in with the generator, there are 10-12 steps that we repeat every time to get it to our standards. Here, my first focus was to give Claude the context and tools to get to the same (or better) result faster, and through simple prompting. No knowing what the ultimate add-in entry was going to be in the contest, I knew it would be a submission of both the final add-in and the tools to streamline this process. The generator-addin, while somewhat outdated and burdened with the same old problems, still has solid advantages for local developement and testing, so I knew my process with Claude would also need similar capabilities to reduce overhead on the feedback loop.
So, as a first step, I ran `yo addin` inside examples/addins/ and created a new add-in called runner_demo. It would serve as a base for Claude's next steps. I added a few instructions in CLAUDE.md and in the ADDINS skills, then I started testing:

> Create a new add-in that shows me a summary of existing (enabled) rules with a sparkline next to its name that shows the number of exceptions trend over the last 4 weeks. Show me what it looks like in the runner when you're done. 

The result was surpringly good after just this simple step. It added a new add-in called rules_overview to the examples/addins/ folder, with all the required files and a working example. It was working as expected, but I wanted to work out some years-old kinks of the runner before I got further. I started by having Claude fix the runner's left menu.

> I found the boilerplate layout of the npm run dev runner environment to be quite broken in terms of UI (it was created when Geotab looked very different and under outdated assumptions). I would like to update the UI of the left nav menu and maybe the top bar, too. Right now the arrow toggle button is broken and the mygeotab icon is very small. I am talking about boilerplate in examples/addins/runner_demo/src/.dev. I don't need the full menu with menu entries (locally they will not be able to navigate anyway), but I would like the user to be able to toggle wide/folded menu so they can see their addin under the right widths and how it reacts to these changes. Here is the current mygeotab menu's outerhtml, but let me know what else you would need to fix it. First fix it in runner_demo, then once I validate, you can replicate under the rules_overview copy we made.

The left menu looked better, but for some reason it had decided to remove the group filter in the top header. I wanted it back:

> First of all, the group filter is important functionality for testing, I didn't ask to remove it. The outerHtml I copied was just from the left nav, the group filter is in the top header. Please restore the functionality. The UI/CSS of it was broken (and I was going to ask you to work on it next), but the functionality of it was fine. Second of all, now the left menu nav toggle works well, but the add-in context doesn't render nicely in either state (open or closed) - the add-in content is hidden behind the left nav and the top header. In MyGeotab, the add-in       content covers only the available content under the top header and right of the (open or closed) left nav menu. Please adjust making changes only to the .dev folder and without touching the CSS in the add-in's source jsx or css files, because it's a local runner UI problem and not a production add-in problem. 

> This works for the most part. The group filter selection updates the group filter component, but it doesn't actually change the state.getGroupFilter() value (it seems). Previously, I think it would just call focus() again from my add-in's lifecycle methods, and within it, the state.getGroupFilter() had updated value. Maybe the getGroupFilter() method works now (I couldn't test), but I don't think it triggers focus so really nothing happens when I change the groups.

> I am running runner_demo and it still does nothing when I apply the group filter changes in the add-in.

> I think the problem is elsewhere, it does call focus again, but it doesn't trigger a new call to getDevices (which uses the current groupfilter). I think it's something to change with react's useState usage here.

All good with the group filter and the menu now (better than before even). On to automating language development and testing. Everything should always be multi-lingal:

> You'll see in the top bar of the add-in runner that there is a language dropdown. This used to be practical to test our translations in older add-ins, but now with Zenith and the new translation files with state.translate, it doesn't work (it relied on localStorage properties that don't exist in production, whereas we usually depend on user.language. In Zenith, the components should be wrapped in a LanguageProvider that should be set from the user.language property. Make sure to add this to both Zenith examples as best practice, but also: 1. Update  the ADDINS skill to mention this for external add-ins, maybe update the Zenith docs if they don't already mention this, and update Claude.md to make sure you know to include this in all future external add-ins. What's important to me is that it can also work with the runner's language bar - so in production, use the current user's language, but in the local runner for   testing, proritize using the selected language. Make sure changing the language applies the changes dynamically. Zenith lang ref: https://developers.geotab.com/zenith-storybook/?path=/docs/application-language-and-date-format--docs

> Nicely done, now apply needed/missing translations to both external add-in examples. Make sure fr.json is populated with all required keys and values.

Framework in place, but needs translations for our initial 2 add-in examples.

> Now I have a good basis for a vanilla React/Zenith translated add-in that works in the runner, but I'd like you to fix the UI for the group filter. This is what it looks like when I'm picking groups, not very readable. Not very "Zenith"-y. [image1] In contrast, when I select to use the Advanced Group Filter, that has a nice Zenith experience: [image2] Please just make it more readable, increase z-index, add padding, background-color, etc. 

> Just fix the broken chevron icons and we're good.

All good now. From my initial assessment, now I'm able to create a new add-in with a simple prompt, and the add-in will have the structure I want, using React + Zenith, working in English and French (we can add more locales later), and with local testing tools that will allow me to verify as we iterate. Onto the actual Challenge entry...

## The Challenge Entry

> Create an external mygeotab add-in called "Last Week in Fleet". Use React and Zenith. The add-in should have 4 tabs: Productivity | Safety | Compliance | Sustainability. The Productivity tab should be selected by default. When loaded, it should Get Trip entities from last week (from last Sunday 00:00 to last Saturday 23:59, local time) - make sure includeOverlappedTrips is set to true. For each trip, find its predecessor (same device.id, previous' nextTripStart == next's start). This allows you to map previous.stopPoint as next's startPoint property. For each processed trip, if startPoint and stopPoint are not the same and distance is > 5, create a GPX payload with the startPoint and stopPoint coordinates - including ISO8601 timestamps in each trkpt. Send this payload as postbody (content-type application/xml) to https://nav.attrix.ai/match?instructions=false&profile=car. Compile the resulting map-matched polylines using something like polyline.decode(gpxJson.paths[0].points, 5) and add these strings to a trips layer on the maplibre map. You can batchs these requests 25 at a time so we don't throw 5000 requests to the mapping server at once. Add the polylines on the map as they come back. Each device should have its own random color assigned so polylines differ between vehicles. This will be the headliner of the Productivity tab. Next to it, we'll show some KPIs related to the same trips: total distance, total driving time and driving time %, total idling time and idling time %.

> After initial generation, it renders a map with the trips in npm run dev, but I get this error in the console and I don't see any Zenith components, only the map. I don't think it's using my style. [Pasted text #1 +7 lines]

> The error went away, but I just found out the map is just overlaid on top of evertying else.

> OK forget about batching in 30s, this is painstakingly slow, especially for long trips. It seems graphhopper needs more data to map-match quickly, so we'll do this: initially, paint all trips as straight lines (origin, destination), then using 5 "slots" we will send requests one by one, when one resolves, send another, etc, until all are done. When a gpxResponse is gotten, replace the straight line with the resulting polyline. As an extra step, though, for trips longer than 30 minutes, we will add a trkpt every 30 min. To do this, build a multicall to extrapolate logrecords at the 30-min increments (pass deviceSearch.id as device.id, and pass fromDate=toDate as the desired interpolated timestamp).

> That works. KPIs are all wrong. Idling time % and driving time % both say 0, and that's not right. Distance shows 4.2 km, that's obviously wrong. Idling and Driving time both show NaN. So: for distance, sum all trips.distance prop - that one's easy. For idling and driving time, look at each trip's idlingDuration and drivingDuration props. They use format [d.]hh:mm:ss.sss. So 27 hours, 1 min, 48 seconds and 31 milliseconds would show as 1.03:01:48.031 and 2 hours (even) would show up as 2:00:00.000. Parse these and sum them together. For the % values, start with the same accumulators, then count the total elapsed time in the week and show the relative %.

> The % values are likely wrong. They would be right for just 1 vehicle, but if I have 5 vehicles, each driving 4 hours in a 24 hour span, then it's false to say I've driven 20 hours out of 24 (>80%). It would be 20 hours out of (5 * 24) ~= 16%.

> See my deploy-addins.yml github workflow file I just added. This is a pipeline we use in other repos to deploy addins on push. The script works for single add-in repos - where the repo is the add-in and nothing else. Here I thought we could go from this template and modify it so that we maintain a list of add-ins to deploy on push (through a config file maybe?). Iterate over those and run the same kind of deploy script. For instance, now, I would to deploy examples/addins/last-week-in-fleet and examples/addins/rules_overview, respectively to https://storage.googleapis.com/geotab-addins/$BRANCH_NAME/last-week-in-fleet/ and https://storage.googleapis.com/geotab-addins/$BRANCH_NAME/rules_overview. What do you suggest?

> OK, move KPIs to the top of the tab, and the map under it. Before initializing the map, Get the SystemSettings entity, then retrieve the companyAddress from the first index of the returned array. If set, send this address to a GetCoordinates call to get the coordinates, then set this as the center of the map on load. If any of this fails, set the center to 45.57401727, -73.17375896. Once the trips are returned, fitBounds on the map (with a small padding around it). Add a min zoom value so we can't zoom out to the world level, because our map tiles only cover North America. That should be it for the productivity tab after this.

> In some cases we hit rate limits when getting the logrecords. If this happens, we should still try and geocode without the extra logrecords. Also, the workaround you put in place earlier to force getting the devices with updated Group Filter on every focus, it makes it so that we are reloading all these trips and also map-matching them all over again. Regarding the group filter, check if data has changed before getting again. Regarding tab navigation (going from productivity to safety and then back to productivity) should not trigger a complete data reload,especially for heavy computation like this. Only reload if the group filter value has changed (or we don't have any data yet).

> It seems to me the look of the Productivity tab's content is not very Zenith-y. Can you look at more Zenith doc and examples and make sure we leverage the components (ie: summary tiles)? It should beprettier and more modern. 

> This is better. Still weird, the tiles are too wide. Also probably don't need a title mid-way down the page for the map. Use summarytile labels to show the relative % values and combine them in the driving/idling times.

> I would like to show a visual representation of distance driven by vehicle. We can split the viewport width on larger screens, the map can take up something like 75% of the width and on the  remaining space on the right, show kind of a lean vertical bar chart where the bars represent total distance driven by device across the trips we got. Each bar should be the same color as the lines from the map. The label should show the vehicle name, not id, so Get the details for the relevant devices. If there are many devices (like over 30) we can show top 10 and bottom 10 only (with a separator to show there is a missing gap). It should be modern looking. You can use Zenith charts if it suits this use-case, otherwise you can draw manually or use another charting library.

> Not bad, but the cutoff with the edge of the window is too abrupt. Maybe it needs margin or padding? What do you think? We need to show units (km), either once at the top of next to each value. Make the lines a little bit more narrow. The split threshold should be 25, not 30.

> Sort trips by distance descending before map-matching them, so we map-match the longest trips first. When there are lots of trips, it takes a while to map-match, and visually the longest trips have the biggest impact.


## Authors

This repo was initially forked from [https://github.com/fhoffa/geotab-vibe-guide](https://github.com/fhoffa/geotab-vibe-guide) created by [Felipe Hoffa](https://www.linkedin.com/in/hoffa/). 
The changes to implement add-in runner functionality and produce a final entry for the Vibe Coding Challenge are by [LP Papillon](https://www.linkedin.com/in/lppapillon/).
