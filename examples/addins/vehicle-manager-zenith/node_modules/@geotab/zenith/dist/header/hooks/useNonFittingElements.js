"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNonFittingElements = void 0;
const react_1 = require("react");
const setEmptyValue = (prevValue) => prevValue.length ? [] : prevValue;
const useNonFittingElements = ({ maxWidth, data, hiddenElementsCountToRender, widthDelta = 0, reverseOrderOfVisible }) => {
    const elementOffset = 8;
    const hiddenContainerRef = (0, react_1.useRef)(null);
    const [visibleElements, setVisibleElements] = (0, react_1.useState)([]);
    const [nonFittingElements, setNonFittingElements] = (0, react_1.useState)([]);
    const calculateVisibleChildrenCount = (0, react_1.useCallback)((currentMaxWidth) => {
        if (!hiddenContainerRef.current) {
            return 0;
        }
        let currentIterationWidth = 0;
        return Array.from(hiddenContainerRef.current.children).reduce((acc, child, index) => {
            if (!(child instanceof HTMLElement)) {
                return acc;
            }
            currentIterationWidth += child.offsetWidth + (index > 0 ? elementOffset : 0);
            if (currentIterationWidth >= currentMaxWidth) {
                return acc;
            }
            return acc + 1;
        }, 0);
    }, []);
    (0, react_1.useEffect)(() => {
        if (!hiddenContainerRef.current) {
            return;
        }
        if (!data.length) {
            setVisibleElements(setEmptyValue);
            setNonFittingElements(setEmptyValue);
            return;
        }
        let visibleChildrenCount = calculateVisibleChildrenCount(maxWidth);
        if (hiddenContainerRef.current.children.length > visibleChildrenCount) {
            visibleChildrenCount = calculateVisibleChildrenCount(maxWidth - widthDelta - elementOffset);
            if (visibleChildrenCount >= hiddenElementsCountToRender) {
                visibleChildrenCount = hiddenElementsCountToRender;
            }
        }
        else if (visibleChildrenCount === hiddenElementsCountToRender + 1) {
            visibleChildrenCount = hiddenElementsCountToRender + 1;
        }
        else if (visibleChildrenCount > hiddenElementsCountToRender) {
            visibleChildrenCount = hiddenElementsCountToRender;
        }
        let dataForRender = data;
        if (data.length !== hiddenContainerRef.current.children.length && data.every((item) => { var _a; return ((_a = item.props) === null || _a === void 0 ? void 0 : _a.id) !== undefined; })) {
            let canBeFiltered = hiddenContainerRef.current.children.length > 0;
            const filteredData = [];
            Array.from(hiddenContainerRef.current.children).forEach((child) => {
                const childrenId = child.getAttribute("id");
                if (childrenId) {
                    const elem = dataForRender.find((item) => { var _a; return ((_a = item.props) === null || _a === void 0 ? void 0 : _a.id) === childrenId; });
                    if (elem) {
                        filteredData.push(elem);
                    }
                }
                else {
                    canBeFiltered = false;
                }
            });
            dataForRender = canBeFiltered ? filteredData : data;
        }
        const menuOnlyItems = dataForRender.filter(el => { var _a; return (_a = el.props) === null || _a === void 0 ? void 0 : _a.inContextMenu; });
        const newVisibleElements = dataForRender.filter(el => { var _a; return !((_a = el.props) === null || _a === void 0 ? void 0 : _a.inContextMenu); }).slice(0, visibleChildrenCount);
        setVisibleElements(reverseOrderOfVisible ? newVisibleElements.reverse() : newVisibleElements);
        setNonFittingElements([...menuOnlyItems, ...dataForRender.filter(el => { var _a; return !((_a = el.props) === null || _a === void 0 ? void 0 : _a.inContextMenu); }).slice(visibleChildrenCount)]);
    }, [maxWidth, calculateVisibleChildrenCount, data, widthDelta, hiddenElementsCountToRender, reverseOrderOfVisible]);
    return {
        visibleElements,
        nonFittingElements,
        hiddenContainerRef
    };
};
exports.useNonFittingElements = useNonFittingElements;
