"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.Range = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const filterButton_1 = require("../filterButton/filterButton");
const controlledPopup_1 = require("../controlledPopup/controlledPopup");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const button_1 = require("../button/button");
const buttonType_1 = require("../button/buttonType");
const rangeField_1 = require("./rangeField");
const useLanguage_1 = require("../utils/localization/useLanguage");
const rangeHelper_1 = require("./rangeHelper");
const formFieldError_1 = require("../formFieldError/formFieldError");
const useDirection_1 = require("../filtersBar/filtersBarSidePanel/hooks/useDirection");
const chip_1 = require("../chip/chip");
const chipStatusProvider_1 = require("../chip/chipStatusProvider");
const Range = ({ className, onChange, value, labelMin, labelMax, unit, defaultValue, disabled, label, min, max, id, fullWidthTriggerButton, fullBounded, allowEqualMinMax, error, triggerAriaLabel, chip, chipIcon, chipId, chipName }) => {
    const [isOpen, setIsOpen] = (0, react_1.useState)(false);
    const [currentValue, setCurrentValue] = (0, react_1.useState)(value);
    const [errorType, setErrorType] = (0, react_1.useState)(undefined);
    const triggerId = (0, react_1.useId)();
    const chipStatus = (0, chipStatusProvider_1.useChipStatus)();
    const triggerRef = (0, react_1.useRef)(null);
    const contentRef = (0, react_1.useRef)(null);
    const prevValueRef = (0, react_1.useRef)(value);
    const minRef = (0, react_1.useRef)(null);
    const maxRef = (0, react_1.useRef)(null);
    const { directionState, setContainerNode } = (0, useDirection_1.useDirection)("column");
    const blurTimeoutRef = (0, react_1.useRef)(null);
    const { translate } = (0, useLanguage_1.useLanguage)();
    // This is the callback ref
    const setFieldsContainerRef = (0, react_1.useCallback)((node) => {
        setContainerNode(node);
    }, [setContainerNode]);
    const getSelection = (0, react_1.useCallback)(() => {
        let selection = value.min !== null && value.max !== null ? `${value.min} - ${value.max}` : "";
        if (!selection && value.min !== null) {
            selection = `${labelMin || translate("Min")} = ${value.min}`;
        }
        if (!selection && value.max !== null) {
            selection = `${labelMax || translate("Max")} = ${value.max}`;
        }
        return selection;
    }, [labelMax, labelMin, translate, value.max, value.min]);
    const handleTriggerClick = (0, react_1.useCallback)(() => {
        setIsOpen(curr => !curr);
    }, []);
    const handleClearClick = (0, react_1.useCallback)(() => {
        if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
        }
        defaultValue ? setCurrentValue(defaultValue) : setCurrentValue({ min: null, max: null });
        const isHasError = (0, rangeHelper_1.checkErrorType)((defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.min) || null, (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.max) || null, fullBounded, allowEqualMinMax, min, max);
        setErrorType(isHasError);
    }, [allowEqualMinMax, defaultValue, fullBounded, max, min]);
    const handleCancelClick = () => {
        if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
        }
        setCurrentValue(value);
        const isHasError = (0, rangeHelper_1.checkErrorType)(value.min, value.max, fullBounded, allowEqualMinMax, min, max);
        setErrorType(isHasError);
        setIsOpen(false);
    };
    const handleApplyClick = () => {
        if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
        }
        const isHasError = (0, rangeHelper_1.checkErrorType)(currentValue.min, currentValue.max, fullBounded, allowEqualMinMax, min, max);
        setErrorType(isHasError);
        if (isHasError) {
            return;
        }
        onChange(currentValue);
        setIsOpen(false);
    };
    const handleClearChipClick = (0, react_1.useCallback)(() => {
        handleClearClick();
        defaultValue && onChange(defaultValue);
        setIsOpen(false);
    }, [defaultValue, handleClearClick, onChange]);
    const handleChange = (0, react_1.useCallback)((targetId, newValue) => {
        const newValues = { min: targetId === "min" ? newValue : currentValue.min, max: targetId === "max" ? newValue : currentValue.max };
        setCurrentValue(newValues);
    }, [currentValue.min, currentValue.max]);
    const isClearDisabled = () => defaultValue ? defaultValue.min === currentValue.min && defaultValue.max === currentValue.max : currentValue.min === null && currentValue.max === null;
    const isApplyDisabled = () => currentValue.min === value.min && currentValue.max === value.max;
    const handleBlur = (0, react_1.useCallback)((e) => {
        if (e.relatedTarget && e.relatedTarget.getAttribute("data-validated-button")) {
            blurTimeoutRef.current = setTimeout(() => {
                const isHasError = (0, rangeHelper_1.checkErrorType)(currentValue.min, currentValue.max, fullBounded, allowEqualMinMax, min, max);
                setErrorType(isHasError);
            }, 200);
            return;
        }
        const isHasError = (0, rangeHelper_1.checkErrorType)(currentValue.min, currentValue.max, fullBounded, allowEqualMinMax, min, max);
        setErrorType(isHasError);
    }, [currentValue.min, currentValue.max, fullBounded, allowEqualMinMax, min, max]);
    (0, react_1.useEffect)(() => {
        if (value.min === prevValueRef.current.min && value.max === prevValueRef.current.max) {
            return;
        }
        prevValueRef.current = value;
        if (value.min !== currentValue.min || value.max !== currentValue.max) {
            setCurrentValue(value);
        }
    }, [currentValue.min, currentValue.max, value]);
    const memoizedMinRangeField = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(rangeField_1.RangeField, { className: "zen-range__min-field", label: labelMin || translate("Min"), unit: unit, value: currentValue.min, id: "min", inputRef: minRef, errorString: (0, rangeHelper_1.getErrorString)("min", currentValue.min, translate, errorType, min, max), onChange: handleChange, onBlur: handleBlur, max: max, min: min, isMinField: true, direction: directionState }), [labelMin, translate, unit, currentValue.min, errorType, min, max, handleChange, handleBlur, directionState]);
    const memoizedMaxRangeField = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(rangeField_1.RangeField, { className: "zen-range__max-field", label: labelMax || translate("Max"), unit: unit, value: currentValue.max, id: "max", inputRef: maxRef, errorString: (0, rangeHelper_1.getErrorString)("max", currentValue.max, translate, errorType, min, max), onChange: handleChange, onBlur: handleBlur, max: max, min: min, isMinField: false, direction: directionState }), [max, min, labelMax, handleChange, handleBlur, currentValue.max, translate, unit, errorType, directionState]);
    const selection = (0, react_1.useMemo)(() => getSelection(), [getSelection]);
    return (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-range", error ? "zen-range--error" : "", className || ""]), children: [chip ? (0, jsx_runtime_1.jsx)(chip_1.Chip, { id: chipId, status: isClearDisabled() ? undefined : chipStatus || "active", isOpen: isOpen, disabled: disabled, onClick: handleTriggerClick, onClose: isClearDisabled() ? undefined : handleClearChipClick, triggerRef: triggerRef, icon: chipIcon, children: selection ? selection : chipName }) :
                (0, jsx_runtime_1.jsx)(filterButton_1.FilterButton, { ariaLabel: triggerAriaLabel, ref: triggerRef, id: id || triggerId, className: "zen-range__trigger-button", onClick: handleTriggerClick, disabled: disabled, isActive: isOpen, fullWidth: fullWidthTriggerButton, title: selection ? translate("{rangeName} values {values}").replace("{rangeName}", label).replace("{values}", selection) : "", children: selection ? (0, jsx_runtime_1.jsx)("span", { className: "zen-range__trigger-button-text", children: selection }) : label }), (0, jsx_runtime_1.jsx)(formFieldError_1.FormFieldError, { error: error }), (0, jsx_runtime_1.jsx)(controlledPopup_1.ControlledPopup, { isOpen: isOpen, className: (0, classNames_1.classNames)(["zen-range-popup zen-shadow-dropdown-default", className ? className : ""]), onOpenChange: handleTriggerClick, useTrapFocusWithTrigger: "on", alignment: "bottom-left", shouldHoldScroll: true, triggerRef: triggerRef, ariaLabel: translate("Range Filter popup"), recalculateOnScroll: true, children: (0, jsx_runtime_1.jsxs)("div", { ref: contentRef, className: "zen-range__content", children: [(0, jsx_runtime_1.jsx)("div", { className: "zen-range__label zen-ellipsis", children: label }), (0, jsx_runtime_1.jsxs)("div", { className: "zen-range__fields-wrapper", children: [(0, jsx_runtime_1.jsxs)("div", { ref: setFieldsContainerRef, className: (0, classNames_1.classNames)(["zen-range__fields-container", directionState === "row" ? "zen-range__fields-container--row" : "zen-range__fields-container--column"]), children: [memoizedMinRangeField, memoizedMaxRangeField] }), errorType !== undefined && directionState === "row" ? (0, jsx_runtime_1.jsx)(formFieldError_1.FormFieldError, { className: "zen-range__error", error: [(0, rangeHelper_1.getErrorString)("min", currentValue.min, translate, errorType, min, max) || "", (0, rangeHelper_1.getErrorString)("max", currentValue.max, translate, errorType, min, max) || ""] })
                                    : null] }), (0, jsx_runtime_1.jsxs)("div", { className: "zen-range__footer", children: [(0, jsx_runtime_1.jsx)(button_1.Button, { onClick: handleClearClick, disabled: isClearDisabled(), className: "zen-range__clear-button", type: buttonType_1.ButtonType.Tertiary, title: translate("Clear"), "data-validated-button": true, children: translate("Clear") }), (0, jsx_runtime_1.jsxs)("div", { className: "zen-range__button-group", children: [(0, jsx_runtime_1.jsx)(button_1.Button, { onClick: handleCancelClick, className: "zen-range__cancel-button", title: translate("Cancel"), "data-validated-button": true, children: translate("Cancel") }), (0, jsx_runtime_1.jsx)(button_1.Button, { onClick: handleApplyClick, type: buttonType_1.ButtonType.Primary, disabled: isApplyDisabled(), className: "zen-range__apply-button", title: translate("Apply"), "data-validated-button": true, children: translate("Apply") })] })] })] }) })] });
};
exports.Range = Range;
exports.TRANSLATIONS = [
    "Min",
    "Max",
    "Range Filter popup",
    "Clear",
    "Cancel",
    "Apply",
    "Must be less than the max",
    "Must be more than the min",
    "Must be more than {value}",
    "Must be less than {value}",
    "Must be in range {min} - {max}",
    "The min value must be set",
    "The max value must be set",
    "{rangeName} values {values}"
];
