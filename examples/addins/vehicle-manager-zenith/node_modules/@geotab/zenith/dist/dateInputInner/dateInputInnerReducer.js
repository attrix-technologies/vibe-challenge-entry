"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateInputInnerReducer = exports.getInitialDateInputInnerState = exports.DateInputInnerStateActionType = exports.AssistiveText = void 0;
exports.AssistiveText = {
    DateAdjusted: "date-adjusted",
    TimeAdjusted: "time-adjusted",
    None: "none"
};
var DateInputInnerStateActionType;
(function (DateInputInnerStateActionType) {
    DateInputInnerStateActionType["ChangeCalendarValue"] = "CHANGE_CALENDAR_VALUE";
    DateInputInnerStateActionType["ChangeStartDateText"] = "CHANGE_START_DATE_TEXT";
    DateInputInnerStateActionType["ChangeEndDateText"] = "CHANGE_END_DATE_TEXT";
    DateInputInnerStateActionType["ChangePeriod"] = "CHANGE_PERIOD";
    DateInputInnerStateActionType["ChangeStartAssistiveText"] = "CHANGE_START_ASSISTIVE_TEXT";
    DateInputInnerStateActionType["ChangeEndAssistiveText"] = "CHANGE_END_ASSISTIVE_TEXT";
    DateInputInnerStateActionType["ChangeActiveField"] = "CHANGE_ACTIVE_FIELD";
    DateInputInnerStateActionType["ToggleActiveField"] = "TOGGLE_ACTIVE_FIELD";
    DateInputInnerStateActionType["ChangeDateRangeMode"] = "CHANGE_DATE_RANGE_MODE";
    DateInputInnerStateActionType["UpdateDateText"] = "UPDATE_DATE_TEXT";
    DateInputInnerStateActionType["ChangeInputKeydownBehavior"] = "CHANGE_INPUT_KEYDOWN_BEHAVIOR";
})(DateInputInnerStateActionType || (exports.DateInputInnerStateActionType = DateInputInnerStateActionType = {}));
const getInitialDateInputInnerState = (id, startText, endText, dateRange) => ({
    dateRangeMode: dateRange || false,
    startDateId: `${id}-start`,
    endDateId: `${id}-end`,
    startDateText: startText,
    endDateText: endText,
    startAssistiveText: exports.AssistiveText.None,
    endAssistiveText: exports.AssistiveText.None,
    currentActiveField: "start",
    inputKeyDownBehavior: "start"
});
exports.getInitialDateInputInnerState = getInitialDateInputInnerState;
// eslint-disable-next-line complexity
function dateInputInnerReducer(state, action) {
    if (action.type === DateInputInnerStateActionType.ChangePeriod) {
        const getEndAssistiveText = () => {
            if (!state.dateRangeMode) {
                return exports.AssistiveText.None;
            }
            if (action.payload.emittedBy === "end" && state.currentActiveField === "end") {
                return exports.AssistiveText.None;
            }
            if (action.payload.emittedBy === "start" && state.currentActiveField === "start") {
                return action.payload.endAssistiveText;
            }
            return action.payload.endAssistiveText || state.endAssistiveText;
        };
        const getStartAssistiveText = () => {
            if (!state.dateRangeMode) {
                return exports.AssistiveText.None;
            }
            if (action.payload.emittedBy === "start" && state.currentActiveField === "start") {
                return exports.AssistiveText.None;
            }
            if (action.payload.emittedBy === "end" && state.currentActiveField === "end") {
                return action.payload.startAssistiveText;
            }
            return action.payload.startAssistiveText || state.startAssistiveText;
        };
        return Object.assign(Object.assign({}, state), { currentActiveField: action.payload.emittedBy || action.payload.nextActiveField || state.currentActiveField, inputKeyDownBehavior: action.payload.emittedBy || action.payload.nextActiveField || state.inputKeyDownBehavior, startDateText: action.payload.start, endDateText: state.dateRangeMode ? action.payload.end : state.endDateText, startAssistiveText: getStartAssistiveText(), endAssistiveText: getEndAssistiveText() });
    }
    if (action.type === DateInputInnerStateActionType.ChangeCalendarValue) {
        const nextActiveField = state.currentActiveField === "start" ? "end" : "start";
        const getNextStartAssistiveText = () => {
            if (!state.dateRangeMode) {
                return exports.AssistiveText.None;
            }
            if (state.currentActiveField === "start") {
                return exports.AssistiveText.None;
            }
            return state.startDateText !== action.payload.start || action.payload.hasAssistiveText ? exports.AssistiveText.DateAdjusted : exports.AssistiveText.None;
        };
        const getNextEndAssistiveText = () => {
            if (!state.dateRangeMode) {
                return exports.AssistiveText.None;
            }
            if (state.currentActiveField === "end") {
                return exports.AssistiveText.None;
            }
            return state.endDateText !== action.payload.end || action.payload.hasAssistiveText ? exports.AssistiveText.DateAdjusted : exports.AssistiveText.None;
        };
        return Object.assign(Object.assign({}, state), { startDateText: action.payload.start, endDateText: state.dateRangeMode ? action.payload.end : state.endDateText, startAssistiveText: getNextStartAssistiveText(), endAssistiveText: getNextEndAssistiveText(), currentActiveField: state.dateRangeMode ? nextActiveField : "start", inputKeyDownBehavior: state.dateRangeMode ? nextActiveField : "start" });
    }
    if (action.type === DateInputInnerStateActionType.ChangeStartDateText) {
        if (action.payload === state.startDateText) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { startDateText: action.payload });
    }
    if (action.type === DateInputInnerStateActionType.ChangeEndDateText) {
        if (action.payload === state.endDateText || !state.dateRangeMode) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { endDateText: action.payload });
    }
    if (action.type === DateInputInnerStateActionType.UpdateDateText) {
        if (action.payload.end === state.endDateText && action.payload.start === state.startDateText) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { startDateText: action.payload.start, endDateText: action.payload.end });
    }
    if (action.type === DateInputInnerStateActionType.ChangeStartAssistiveText) {
        if (!state.dateRangeMode) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { startAssistiveText: action.payload });
    }
    if (action.type === DateInputInnerStateActionType.ChangeEndAssistiveText) {
        return Object.assign(Object.assign({}, state), { endAssistiveText: action.payload });
    }
    if (action.type === DateInputInnerStateActionType.ChangeActiveField) {
        return Object.assign(Object.assign({}, state), { currentActiveField: action.payload, inputKeyDownBehavior: action.payload, startAssistiveText: state.currentActiveField === "start" ? exports.AssistiveText.None : state.startAssistiveText, endAssistiveText: state.currentActiveField === "end" ? exports.AssistiveText.None : state.endAssistiveText });
    }
    if (action.type === DateInputInnerStateActionType.ChangeInputKeydownBehavior) {
        return Object.assign(Object.assign({}, state), { inputKeyDownBehavior: action.payload });
    }
    if (action.type === DateInputInnerStateActionType.ToggleActiveField) {
        if (!state.dateRangeMode) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { currentActiveField: state.currentActiveField === "start" ? "end" : "start", inputKeyDownBehavior: state.currentActiveField === "start" ? "end" : "start", startAssistiveText: state.currentActiveField === "start" ? exports.AssistiveText.None : state.startAssistiveText, endAssistiveText: state.currentActiveField === "end" ? exports.AssistiveText.None : state.endAssistiveText });
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (action.type === DateInputInnerStateActionType.ChangeDateRangeMode) {
        if (state.dateRangeMode === action.payload) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { dateRangeMode: action.payload });
    }
    return state;
}
exports.dateInputInnerReducer = dateInputInnerReducer;
