"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.Calendar = exports.monthLabelsArray = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const dateUtils_1 = require("./dateUtils");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const iconChevronRightSmall_1 = require("../icons/iconChevronRightSmall");
const iconChevronLeftSmall_1 = require("../icons/iconChevronLeftSmall");
const parallelSelection_1 = require("../parallelSelection/parallelSelection");
const calendarUtils_1 = require("./calendarUtils");
const useLanguage_1 = require("../utils/localization/useLanguage");
const useDriveClassName_1 = require("../utils/theme/useDriveClassName");
const textIconButton_1 = require("../textIconButton/textIconButton");
const textIconButton_2 = require("../textIconButton/textIconButton");
const button_1 = require("../button/button");
const buttonType_1 = require("../button/buttonType");
const DEFAULT_START_DAY_OF_WEEK = 0;
const DEFAULT_YEAR_RANGE = 20;
exports.monthLabelsArray = ["Jan", "Feb", "Mar", "Apr", "Ma", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const Calendar = ({ id, value, onChange, disableFutureDates = false, disablePastDates = false, disableDatesAfter, disableDatesBefore, dateRangeMode = false, startDayOfWeek, yearRange, isMobileView, getCurrentActiveField, onTodayButtonClick }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const fromDate = (0, react_1.useMemo)(() => value.from ? (0, dateUtils_1.toDayStart)(value.from) : undefined, [value.from]);
    const toDate = (0, react_1.useMemo)(() => value.to ? (0, dateUtils_1.toDayStart)(value.to) : undefined, [value.to]);
    const driveClassName = (0, useDriveClassName_1.useDriveClassName)("zen-calendar");
    const parentRef = (0, react_1.useRef)(null);
    const focusRef = (0, react_1.useRef)(null);
    const parallelSelectionTriggerRef = (0, react_1.useRef)(null);
    const [viewDate, setViewDate] = (0, react_1.useState)(fromDate || new Date().toISOString());
    const [hoverDate, setHoverDate] = (0, react_1.useState)(fromDate);
    const [focusDate, setFocusDate] = (0, react_1.useState)(fromDate || new Date().toISOString());
    const changeView = (0, react_1.useCallback)((date) => {
        var _a, _b;
        focusRef.current = document.activeElement;
        const dateLike = new Date(date);
        dateLike.setDate(15);
        if ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.classList.contains("zen-parallel-selection__select")) {
            (_b = parallelSelectionTriggerRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
        setViewDate(dateLike.toISOString());
    }, [setViewDate]);
    const handleFocusDateChange = (0, react_1.useCallback)((focusing = false) => (date) => {
        var _a;
        if (date && focusing) {
            const dateLike = new Date(date);
            const button = (_a = parentRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-id="${id}-day-${dateLike.getDate()}-${dateLike.getMonth()}-${dateLike.getFullYear()}"]`);
            button === null || button === void 0 ? void 0 : button.focus();
        }
        changeView(date);
        setFocusDate(date);
    }, [changeView, setFocusDate, id]);
    const dayLabels = (0, react_1.useMemo)(() => ({
        0: translate("ShortSunday"),
        1: translate("ShortMonday"),
        2: translate("ShortTuesday"),
        3: translate("ShortWednesday"),
        4: translate("ShortThursday"),
        5: translate("ShortFriday"),
        6: translate("ShortSaturday")
    }), [translate]);
    const getDayOfWeek = (0, react_1.useCallback)((date) => {
        const dayOfWeek = new Date(date).getDay();
        return dayLabels[dayOfWeek];
    }, [dayLabels]);
    const monthLabels = (0, react_1.useMemo)(() => ({
        0: translate(exports.monthLabelsArray[0]),
        1: translate(exports.monthLabelsArray[1]),
        2: translate(exports.monthLabelsArray[2]),
        3: translate(exports.monthLabelsArray[3]),
        4: translate(exports.monthLabelsArray[4]),
        5: translate(exports.monthLabelsArray[5]),
        6: translate(exports.monthLabelsArray[6]),
        7: translate(exports.monthLabelsArray[7]),
        8: translate(exports.monthLabelsArray[8]),
        9: translate(exports.monthLabelsArray[9]),
        10: translate(exports.monthLabelsArray[10]),
        11: translate(exports.monthLabelsArray[11])
    }), [translate]);
    const getMonthYear = (0, react_1.useCallback)((date) => {
        const month = new Date(date).getMonth();
        const year = new Date(date).getFullYear();
        return `${monthLabels[month]} ${year}`;
    }, [monthLabels]);
    const dates = (0, react_1.useMemo)(() => (0, dateUtils_1.getCalendarMonthDates)(viewDate, startDayOfWeek || DEFAULT_START_DAY_OF_WEEK), [viewDate, startDayOfWeek]);
    const monthStart = (0, react_1.useMemo)(() => (0, dateUtils_1.getStartOfMonth)(viewDate), [viewDate]);
    const monthEnd = (0, react_1.useMemo)(() => (0, dateUtils_1.getEndOfMonth)(viewDate), [viewDate]);
    const now = new Date().toISOString();
    const years = (0, dateUtils_1.getSelectableYears)(viewDate, yearRange || DEFAULT_YEAR_RANGE, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
    const selectionHandler = (0, react_1.useCallback)(
    // eslint-disable-next-line complexity
    (selectedDate, isOtherMonth) => {
        setHoverDate(undefined);
        if (isOtherMonth) {
            handleFocusDateChange()(selectedDate);
        }
        // single date mode
        if (!dateRangeMode || !getCurrentActiveField) {
            if (fromDate && fromDate === selectedDate) {
                onChange({ from: undefined, to: undefined });
            }
            else {
                onChange({ from: selectedDate, to: undefined });
            }
            return;
        }
        const currentActiveField = getCurrentActiveField();
        // no selection yet
        if (!fromDate && !toDate) {
            onChange({ from: currentActiveField === "start" ? selectedDate : undefined, to: currentActiveField === "end" ? selectedDate : undefined }, currentActiveField);
            return;
        }
        if (currentActiveField === "start" && toDate && selectedDate > toDate) {
            onChange({ from: selectedDate, to: undefined }, "start");
            return;
        }
        if (currentActiveField === "end" && fromDate && selectedDate < fromDate) {
            onChange({ from: undefined, to: selectedDate }, "end");
            return;
        }
        if (fromDate && selectedDate === fromDate && currentActiveField === "end") {
            onChange({ from: selectedDate, to: selectedDate }, "end");
            return;
        }
        if (toDate && selectedDate === toDate && currentActiveField === "start") {
            onChange({ from: selectedDate, to: selectedDate }, "start");
            return;
        }
        const isWrongPeriodFn = (start, end) => (0, dateUtils_1.isDifferentPeriod)(start, end, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
        const newRangeOptions = (0, calendarUtils_1.getCalendarRange)(selectedDate, currentActiveField, isWrongPeriodFn, fromDate, toDate);
        onChange(newRangeOptions, currentActiveField);
        return;
    }, [dateRangeMode, getCurrentActiveField, fromDate, toDate, onChange, handleFocusDateChange,
        disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter]);
    const handleDateKeyDown = (0, react_1.useCallback)((e, isDisabled, date, isOtherMonth) => {
        if (e.code === "Enter" || e.code === "Space") {
            e.preventDefault();
            !isDisabled && selectionHandler(date, isOtherMonth);
            return;
        }
        if (e.code === "ArrowLeft") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.addDays)(new Date(date), -1).toISOString(), handleFocusDateChange(true));
            return;
        }
        if (e.code === "ArrowRight") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.addDays)(new Date(date), 1).toISOString(), handleFocusDateChange(true));
            return;
        }
        if (e.code === "ArrowUp") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.addDays)(new Date(date), -7).toISOString(), handleFocusDateChange(true));
            return;
        }
        if (e.code === "ArrowDown") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.addDays)(new Date(date), 7).toISOString(), handleFocusDateChange(true));
            return;
        }
        if (e.code === "Home") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getStartOfWeek)(date), handleFocusDateChange(true));
            return;
        }
        if (e.code === "End") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getEndOfWeek)(date), handleFocusDateChange(true));
            return;
        }
        if (e.code === "PageUp" && e.shiftKey) {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getSameDateOrTheLastForMonth)(date, -12), handleFocusDateChange(true));
            return;
        }
        if (e.code === "PageDown" && e.shiftKey) {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getSameDateOrTheLastForMonth)(date, 12), handleFocusDateChange(true));
            return;
        }
        if (e.code === "PageUp") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getSameDateOrTheLastForMonth)(date, -1), handleFocusDateChange(true));
            return;
        }
        if (e.code === "PageDown") {
            (0, calendarUtils_1.setFocusTo)(e, (0, dateUtils_1.getSameDateOrTheLastForMonth)(date, 1), handleFocusDateChange(true));
            return;
        }
    }, [selectionHandler, handleFocusDateChange]);
    const isDisabledDay = (0, react_1.useCallback)((date) => {
        const dateTime = new Date(date).getTime();
        const nowDateTime = new Date(now).getTime();
        return (disableFutureDates && dateTime > nowDateTime) || (disablePastDates && dateTime < nowDateTime)
            || (0, dateUtils_1.isDisableDate)(dateTime, disableDatesBefore, disableDatesAfter);
    }, [disableFutureDates, disablePastDates, now, disableDatesAfter, disableDatesBefore]);
    const onPointerDown = (0, react_1.useCallback)((date, isOtherMonth) => {
        selectionHandler(date, isOtherMonth);
        setFocusDate(undefined);
    }, [selectionHandler]);
    (0, react_1.useEffect)(() => {
        value.to && handleFocusDateChange()(value.to);
    }, [value.to, handleFocusDateChange]);
    (0, react_1.useEffect)(() => {
        value.from && handleFocusDateChange()(value.from);
    }, [value.from, handleFocusDateChange]);
    const getBeforeDecorator = (0, react_1.useCallback)((date, isFirstDayOfMonth, isFirstDayOfWeek) => {
        if (!dateRangeMode) {
            return null;
        }
        if (isFirstDayOfMonth && (fromDate && fromDate < date) && (0, calendarUtils_1.isDateInRange)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__month-start" });
        }
        if (isFirstDayOfWeek && (0, calendarUtils_1.isDateInRange)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__week-start" });
        }
        if ((0, calendarUtils_1.isLeftBorderVisible)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__left-border" });
        }
        return null;
    }, [dateRangeMode, hoverDate, focusDate, fromDate, toDate]);
    const getAfterDecorator = (0, react_1.useCallback)((date, isLastDayOfMonth, isLastDayOfWeek) => {
        if (!dateRangeMode) {
            return null;
        }
        if (isLastDayOfMonth && (0, calendarUtils_1.isDateInRange)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__month-end" });
        }
        if (isLastDayOfWeek && (0, calendarUtils_1.isDateInRange)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__week-end" });
        }
        if ((0, calendarUtils_1.isRightBorderVisible)(date, hoverDate || focusDate, fromDate, toDate)) {
            return (0, jsx_runtime_1.jsx)("div", { className: "zen-calendar__right-border" });
        }
        return null;
    }, [dateRangeMode, hoverDate, focusDate, fromDate, toDate]);
    const handleTodayButtonClick = (0, react_1.useCallback)((e) => {
        if (!onTodayButtonClick) {
            return;
        }
        setViewDate(new Date().toISOString());
        onTodayButtonClick(e);
    }, [onTodayButtonClick]);
    const memoizedVisibleFocus = (0, react_1.useMemo)(() => focusDate ? dates.some(arr => arr.some(el => el === focusDate)) : true, [dates, focusDate]);
    const currentActiveField = getCurrentActiveField ? getCurrentActiveField() : undefined;
    return ((0, jsx_runtime_1.jsxs)("div", { ref: parentRef, onBlur: () => setFocusDate(fromDate || viewDate), className: (0, classNames_1.classNames)(["zen-calendar", driveClassName || ""]), children: [(0, jsx_runtime_1.jsxs)("div", { className: "zen-calendar__header", children: [isMobileView ? null : (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-calendar__btn", type: "tertiary-black", icon: iconChevronLeftSmall_1.IconChevronLeftSmall, title: translate("Previous month"), onClick: () => changeView((0, dateUtils_1.addMonth)(viewDate, -1)), iconPosition: textIconButton_2.ButtonIconPosition.Start }), (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-calendar__year", onTodayButtonClick ? "zen-calendar__year--limited" : ""]), children: [(0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-calendar__year-name", onTodayButtonClick ? "zen-calendar__year-name--left" : "", "zen-ellipsis"]), "aria-live": "polite", children: getMonthYear(viewDate) }), (0, jsx_runtime_1.jsx)(parallelSelection_1.ParallelSelectionTrigger, { className: "zen-calendar__year-trigger zen-calendar__btn", title: translate("Select year"), ref: parallelSelectionTriggerRef }), (0, jsx_runtime_1.jsx)(parallelSelection_1.ParallelSelection, { selected: new Date(viewDate).getFullYear().toString(), items: years, triggerRef: parallelSelectionTriggerRef, title: translate("Select year"), onSelect: year => changeView((0, dateUtils_1.setYear)(viewDate, year)), isMobileView: isMobileView, alignment: onTodayButtonClick ? "bottom" : "bottom-right" })] }), onTodayButtonClick ? (0, jsx_runtime_1.jsx)(button_1.Button, { type: buttonType_1.ButtonType.Tertiary, className: "zen-calendar__today-button", disabled: false, onClick: handleTodayButtonClick, children: translate("Today") }) : null, isMobileView ? (0, jsx_runtime_1.jsxs)("div", { className: "zen-calendar__months", children: [(0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-calendar__btn", type: "tertiary-black", icon: iconChevronLeftSmall_1.IconChevronLeftSmall, title: translate("Previous month"), onClick: () => changeView((0, dateUtils_1.addMonth)(viewDate, -1)), iconPosition: textIconButton_2.ButtonIconPosition.Start }), (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-calendar__btn", type: "tertiary-black", icon: iconChevronRightSmall_1.IconChevronRightSmall, title: translate("Next month"), onClick: () => changeView((0, dateUtils_1.addMonth)(viewDate, 1)), iconPosition: textIconButton_2.ButtonIconPosition.Start })] }) : null, isMobileView ? null : (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-calendar__btn", type: "tertiary-black", icon: iconChevronRightSmall_1.IconChevronRightSmall, title: translate("Next month"), onClick: () => changeView((0, dateUtils_1.addMonth)(viewDate, 1)), iconPosition: textIconButton_2.ButtonIconPosition.Start })] }), (0, jsx_runtime_1.jsxs)("table", { className: "zen-calendar__table", children: [(0, jsx_runtime_1.jsx)("thead", { children: (0, jsx_runtime_1.jsx)("tr", { className: "zen-calendar__columns", children: dates[0].map(date => (0, jsx_runtime_1.jsx)("th", { className: "zen-calendar__column", children: getDayOfWeek(date) }, `cal-h-${date}`)) }) }), (0, jsx_runtime_1.jsx)("tbody", { className: (0, classNames_1.classNames)(["zen-calendar__body", isMobileView ? "zen-calendar__body--mobile-view" : ""]), children: dates.map((week, weekIndex) => (0, jsx_runtime_1.jsx)("tr", { className: "zen-calendar__row", children: week.map((date, index) => {
                                const isOtherMonth = date < monthStart || date > monthEnd;
                                const isDisabled = isDisabledDay(date);
                                const dateLike = new Date(date);
                                const isActive = date === fromDate || date === toDate;
                                const isReadyToChange = date === fromDate && currentActiveField === "start" || date === toDate && currentActiveField === "end";
                                const isFocusable = memoizedVisibleFocus ? date === (fromDate || viewDate) : date.split("T")[0] === viewDate.split("T")[0];
                                const isFirstDayOfWeek = index === 0;
                                const isLastDayOfWeek = index === 6;
                                const isFirstDayOfMonth = weekIndex === 0 && index === 0;
                                const isLastDayOfMonth = weekIndex === dates.length - 1 && index === 6;
                                const isInRange = dateRangeMode && !isFirstDayOfWeek && !isLastDayOfWeek && (0, calendarUtils_1.isDateInRange)(date, hoverDate || focusDate, fromDate, toDate);
                                return (0, jsx_runtime_1.jsx)("td", { className: "zen-calendar__cell", children: (0, jsx_runtime_1.jsxs)("button", { className: (0, classNames_1.classNames)([
                                            "zen-calendar__day-wrapper",
                                            isActive ? "zen-calendar__day-wrapper--active" : "",
                                            isReadyToChange ? "zen-calendar__day-wrapper--ready-to-change" : ""
                                        ]), onPointerDown: evt => {
                                            evt.preventDefault();
                                            !isDisabled && evt.button !== 2 && onPointerDown(date, isOtherMonth);
                                        }, onPointerEnter: () => { !isDisabled && setHoverDate(date); }, onPointerLeave: () => { setHoverDate(undefined); }, tabIndex: isFocusable ? 0 : -1, type: "button", "data-id": `${id}-day-${dateLike.getDate()}-${dateLike.getMonth()}-${dateLike.getFullYear()}`, "aria-label": (0, calendarUtils_1.getButtonLabel)(translate, date, dateRangeMode, fromDate, toDate), onKeyDown: evt => handleDateKeyDown(evt, isDisabled, date, isOtherMonth), onFocus: () => {
                                            !isDisabled && !isOtherMonth && handleFocusDateChange(true)(date);
                                        }, disabled: isDisabled, children: [getBeforeDecorator(date, isFirstDayOfMonth, isFirstDayOfWeek), (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)([
                                                    "zen-calendar__day",
                                                    isInRange ? "zen-calendar__day--in-range" : "",
                                                    isOtherMonth ? "zen-calendar__day--other-month" : "",
                                                    isDisabled ? "zen-calendar__day--disabled" : ""
                                                ]), children: dateLike.getDate() }), getAfterDecorator(date, isLastDayOfMonth, isLastDayOfWeek)] }) }, date);
                            }) }, `week_${week[0]}`)) })] })] }));
};
exports.Calendar = Calendar;
exports.TRANSLATIONS = [
    "Select year",
    "Previous month",
    "Next month",
    "Change daterange start date, {date}",
    "Change daterange end date, {date}",
    "Choose daterange end date",
    "Choose daterange start date",
    "Change date, {date}",
    "Choose date",
    "{short-day-of-week-sunday}S",
    "{short-day-of-week-monday}M",
    "{short-day-of-week-tuesday}T",
    "{short-day-of-week-wednesday}W",
    "{short-day-of-week-thursday}T",
    "{short-day-of-week-friday}F",
    "{short-day-of-week-saturday}S",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
