"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidTime = exports.getValidDatesForEnd = exports.getValidDatesForStart = exports.isDifferentPeriod = exports.isValidationDateError = exports.isValidDate = exports.getSelectableYears = exports.isDisableDate = exports.isDisableYear = exports.getAvailablePeriod = exports.toDayStart = exports.setYear = exports.getSameDateOrTheLastForMonth = exports.addMonth = exports.getEndOfWeek = exports.getStartOfWeek = exports.getDayOfWeekOffset = exports.addMonths = exports.addDays = exports.addMinutes = exports.getNewEndDate = exports.getNewStartDate = exports.getCalendarMonthDates = exports.getEndOfMonth = exports.getStartOfMonth = exports.dayNames = void 0;
exports.dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const getStartOfMonth = (d) => {
    const date = new Date(Date.parse(d));
    date.setDate(1);
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date.toISOString();
};
exports.getStartOfMonth = getStartOfMonth;
const getEndOfMonth = (d) => {
    const date = new Date(d);
    date.setMonth(date.getMonth() + 1);
    date.setDate(1);
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    date.setMilliseconds(date.getMilliseconds() - 1);
    return date.toISOString();
};
exports.getEndOfMonth = getEndOfMonth;
const getCalendarMonthDates = (date, startDayOfWeek) => {
    if (startDayOfWeek > 6 || startDayOfWeek < 0) {
        throw new Error("startDayOfWeek should be between 0 and 6 inclusive");
    }
    const endDayOfWeek = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;
    const getStartDate = (d) => {
        const calendarStart = new Date((0, exports.getStartOfMonth)(d));
        while (calendarStart.getDay() !== startDayOfWeek) {
            calendarStart.setDate(calendarStart.getDate() - 1);
        }
        return calendarStart;
    };
    const getEndDate = (d) => {
        const calendarEnd = new Date((0, exports.getEndOfMonth)(d));
        while (calendarEnd.getDay() !== endDayOfWeek) {
            calendarEnd.setDate(calendarEnd.getDate() + 1);
        }
        return calendarEnd;
    };
    const calendarStart = getStartDate(date);
    const calendarEnd = getEndDate(date);
    const iterator = calendarStart;
    const dates = [];
    let week = 0;
    while (iterator <= calendarEnd && week < 6) {
        if (!dates[week]) {
            dates[week] = [];
        }
        dates[week].push(new Date(iterator.getTime()).toISOString());
        if (iterator.getDay() === endDayOfWeek) {
            week++;
        }
        iterator.setDate(iterator.getDate() + 1);
    }
    return dates;
};
exports.getCalendarMonthDates = getCalendarMonthDates;
const getNewStartDate = function (toLocalDateTime) {
    const localStartDate = toLocalDateTime(new Date());
    return new Date(localStartDate.getFullYear(), localStartDate.getMonth(), localStartDate.getDate(), 0, 0, 0, 0);
};
exports.getNewStartDate = getNewStartDate;
const getNewEndDate = function (toLocalDateTime) {
    const localEndDate = toLocalDateTime(new Date());
    return new Date(localEndDate.getFullYear(), localEndDate.getMonth(), localEndDate.getDate(), 23, 59, 59, 0);
};
exports.getNewEndDate = getNewEndDate;
const addMinutes = (date, minutes) => {
    date.setMilliseconds(date.getMilliseconds() + minutes * 60000);
    return date;
};
exports.addMinutes = addMinutes;
const addDays = (date, days) => {
    date.setMilliseconds(date.getMilliseconds() + days * 86400000);
    return date;
};
exports.addDays = addDays;
function addMonths(date, num) {
    const day = date.getDate();
    date.setDate(1);
    date.setMonth(date.getMonth() + num);
    const monthAdded = new Date(date.getTime());
    monthAdded.setMonth(date.getMonth() + 1);
    date.setDate(Math.min(day, Math.round((monthAdded.getTime() - date.getTime()) / 86400000)));
    return date;
}
exports.addMonths = addMonths;
const getDayOfWeekOffset = (nowDate, firstDayOfWeek) => {
    const dayOfWeek = nowDate.getDay();
    const startDayOfWeek = firstDayOfWeek ? exports.dayNames.indexOf(firstDayOfWeek) : 0;
    return dayOfWeek - startDayOfWeek + (startDayOfWeek > dayOfWeek ? 7 : 0);
};
exports.getDayOfWeekOffset = getDayOfWeekOffset;
const getStartOfWeek = (date, firstDayOfWeek) => {
    const d = new Date(date);
    const dayOfWeek = (0, exports.getDayOfWeekOffset)(d, firstDayOfWeek);
    d.setDate(d.getDate() - dayOfWeek);
    return d.toISOString();
};
exports.getStartOfWeek = getStartOfWeek;
const getEndOfWeek = (date, firstDayOfWeek) => {
    const d = new Date(date);
    const dayOfWeek = (0, exports.getDayOfWeekOffset)(d, firstDayOfWeek);
    d.setDate(d.getDate() + 6 - dayOfWeek);
    return d.toISOString();
};
exports.getEndOfWeek = getEndOfWeek;
const addMonth = (date, inc) => {
    const d = new Date(date);
    d.setMonth(new Date(date).getMonth() + inc);
    return d.toISOString();
};
exports.addMonth = addMonth;
const getSameDateOrTheLastForMonth = (date, inc) => {
    const dateLike = new Date(date);
    const initialDay = dateLike.getDate();
    const initialMonth = dateLike.getMonth();
    dateLike.setDate(15);
    const shiftedDate = new Date((0, exports.addMonth)(dateLike.toISOString(), inc));
    shiftedDate.setDate(initialDay);
    const shiftedMonth = shiftedDate.getMonth();
    const isOverShifted = (initialMonth % 2 === shiftedMonth % 2 && inc % 2 === 1) || (initialMonth % 2 !== shiftedMonth % 2 && inc % 2 === 0);
    if (isOverShifted) {
        const lastDate = new Date(shiftedDate.getFullYear(), shiftedDate.getMonth(), 1);
        lastDate.setDate(lastDate.getDate() - 1);
        return lastDate.toISOString();
    }
    return shiftedDate.toISOString();
};
exports.getSameDateOrTheLastForMonth = getSameDateOrTheLastForMonth;
const setYear = (date, year) => {
    const d = new Date(date);
    d.setFullYear(Number(year));
    return d.toISOString();
};
exports.setYear = setYear;
const toDayStart = (date) => {
    const dateLike = new Date(date);
    dateLike.setHours(0, 0, 0, 0);
    return dateLike.toISOString();
};
exports.toDayStart = toDayStart;
const getAvailablePeriod = (disableBefore, disableAfter) => {
    if (disableBefore && !disableAfter) {
        return "after";
    }
    if (disableAfter && !disableBefore) {
        return "before";
    }
    if (disableAfter && disableBefore) {
        return new Date(disableBefore).getTime() < new Date(disableAfter).getTime() ? "inside" : "outside";
    }
    return "all";
};
exports.getAvailablePeriod = getAvailablePeriod;
const isDisableYear = (year, disableBefore, disableAfter) => {
    const disableBeforeYear = disableBefore ? new Date(disableBefore).getFullYear() : undefined;
    const disableAfterYear = disableAfter ? new Date(disableAfter).getFullYear() : undefined;
    const availablePeriod = (0, exports.getAvailablePeriod)(disableBefore, disableAfter);
    if (availablePeriod === "all") {
        return false;
    }
    if (availablePeriod === "before" && disableAfterYear !== undefined && year <= disableAfterYear) {
        return false;
    }
    if (availablePeriod === "after" && disableBeforeYear !== undefined && year >= disableBeforeYear) {
        return false;
    }
    if (availablePeriod === "outside" && disableAfterYear !== undefined && disableBeforeYear !== undefined && (year <= disableAfterYear || year >= disableBeforeYear)) {
        return false;
    }
    if (availablePeriod === "inside" && disableAfterYear !== undefined && disableBeforeYear !== undefined && (year >= disableBeforeYear && year <= disableAfterYear)) {
        return false;
    }
    return true;
};
exports.isDisableYear = isDisableYear;
const isDisableDate = (dateTime, disableBefore, disableAfter) => {
    const disableDatesBeforeDateTime = disableBefore ? new Date(disableBefore).getTime() : undefined;
    const disableDatesAfterDateTime = disableAfter ? new Date(disableAfter).getTime() : undefined;
    const availablePeriod = (0, exports.getAvailablePeriod)(disableBefore, disableAfter);
    if (availablePeriod === "all") {
        return false;
    }
    if (availablePeriod === "before" && disableDatesAfterDateTime !== undefined && dateTime <= disableDatesAfterDateTime) {
        return false;
    }
    if (availablePeriod === "after" && disableDatesBeforeDateTime !== undefined && dateTime >= disableDatesBeforeDateTime) {
        return false;
    }
    if (availablePeriod === "outside" && disableDatesAfterDateTime !== undefined && disableDatesBeforeDateTime !== undefined &&
        (dateTime <= disableDatesAfterDateTime || dateTime >= disableDatesBeforeDateTime)) {
        return false;
    }
    if (availablePeriod === "inside" && disableDatesAfterDateTime !== undefined && disableDatesBeforeDateTime !== undefined &&
        (dateTime >= disableDatesBeforeDateTime && dateTime < disableDatesAfterDateTime)) {
        return false;
    }
    return true;
};
exports.isDisableDate = isDisableDate;
const getSelectableYears = (date, yearsRange, disableFeature, disablePast, disableBefore, disableAfter) => {
    if (yearsRange < 0) {
        throw new Error("yearsRange should be >= 0");
    }
    const d = new Date(date);
    const year = d.getFullYear();
    const years = [];
    const nowYear = new Date().getFullYear();
    for (let i = year - yearsRange; i <= year + yearsRange; i++) {
        years.push({ id: i.toString(), children: i.toString(), disabled: disableFeature && i > nowYear || disablePast && i < nowYear
                || (0, exports.isDisableYear)(i, disableBefore, disableAfter) });
    }
    return years;
};
exports.getSelectableYears = getSelectableYears;
const isValidDate = (d) => {
    if (!d) {
        return false;
    }
    const dateLike = new Date(d);
    return !isNaN(dateLike.getTime());
};
exports.isValidDate = isValidDate;
const isValidationDateError = (date, toReverseOffsetDateTime, disableFutureDates = false, disablePastDates = false, disableBefore, disableAfter) => {
    if (!(0, exports.isValidDate)(date)) {
        return true;
    }
    const reversedDate = toReverseOffsetDateTime(date);
    if (!disableBefore && !disableAfter) {
        const now = new Date();
        return disableFutureDates && reversedDate > now
            || disablePastDates && reversedDate < now;
    }
    return (0, exports.isDisableDate)(reversedDate.getTime(), disableBefore, disableAfter);
};
exports.isValidationDateError = isValidationDateError;
// eslint-disable-next-line complexity
const isDifferentPeriod = (date1, date2, disableFutureDates, disablePastDates, disableBefore, disableAfter) => {
    if (!date1 || !date2) {
        return false;
    }
    const availablePeriod = (0, exports.getAvailablePeriod)(disableBefore, disableAfter);
    if (availablePeriod === "all") {
        if (!disableFutureDates && !disablePastDates) {
            return false;
        }
        const now = new Date();
        return !(date1 < now && date2 <= now || date1 >= now && date2 > now);
    }
    if (availablePeriod === "before" && (date1 <= new Date(disableAfter) && date2 > new Date(disableAfter))
        || date1 > new Date(disableBefore) && date2 < new Date(disableBefore)) {
        return true;
    }
    if (availablePeriod === "after" && (date1 >= new Date(disableBefore) && date2 < new Date(disableBefore))
        || date1 <= new Date(disableAfter) && date2 > new Date(disableAfter)) {
        return true;
    }
    if (availablePeriod === "outside" && date1 <= new Date(disableAfter) && date2 > new Date(disableAfter)
        || date1 >= new Date(disableBefore) && date2 < new Date(disableBefore)) {
        return true;
    }
    if (availablePeriod === "inside" && (date1 >= new Date(disableBefore) && date2 < new Date(disableBefore)
        || date1 <= new Date(disableAfter) && date2 > new Date(disableAfter))) {
        return true;
    }
    return false;
};
exports.isDifferentPeriod = isDifferentPeriod;
const getValidDatesForStart = (toReverseOffsetDateTime, dateToPass, endValidDate, disableFutureDates = false, disablePastDates = false, disableBefore, disableAfter) => {
    if (!endValidDate) {
        return { start: dateToPass, end: undefined };
    }
    const isDifferentPeriods = (0, exports.isDifferentPeriod)(toReverseOffsetDateTime(dateToPass), toReverseOffsetDateTime(endValidDate), disableFutureDates, disablePastDates, disableBefore, disableAfter);
    if (dateToPass <= endValidDate && !isDifferentPeriods) {
        return { start: dateToPass, end: endValidDate }; // in user timezone
    }
    return { start: dateToPass, end: dateToPass };
};
exports.getValidDatesForStart = getValidDatesForStart;
const getValidDatesForEnd = (toReverseOffsetDateTime, dateToPass, startValidDate, disableFutureDates = false, disablePastDates = false, disableBefore, disableAfter) => {
    if (!startValidDate) {
        return { start: undefined, end: dateToPass };
    }
    const isDifferentPeriods = (0, exports.isDifferentPeriod)(toReverseOffsetDateTime(startValidDate), toReverseOffsetDateTime(dateToPass), disableFutureDates, disablePastDates, disableBefore, disableAfter);
    if (startValidDate <= dateToPass && !isDifferentPeriods) {
        return { start: startValidDate, end: dateToPass }; // in user timezone
    }
    return { start: dateToPass, end: dateToPass };
};
exports.getValidDatesForEnd = getValidDatesForEnd;
const getValidTime = (notValidDateToPass, previousDate, disableFutureDates = false, disablePastDates = false, disableBefore, disableAfter) => {
    const availablePeriod = (0, exports.getAvailablePeriod)(disableBefore, disableAfter);
    if (!previousDate) {
        return undefined;
    }
    const now = new Date();
    if (availablePeriod === "all" && disableFutureDates) {
        return now;
    }
    if (availablePeriod === "all" && disablePastDates) {
        return now;
    }
    if (availablePeriod === "inside" && notValidDateToPass > new Date(disableAfter)) {
        return new Date(disableAfter);
    }
    if (availablePeriod === "inside" && notValidDateToPass < new Date(disableBefore)) {
        return new Date(disableBefore);
    }
    if (availablePeriod === "outside" && new Date(previousDate) < new Date(disableAfter)) {
        return new Date(disableAfter);
    }
    if (availablePeriod === "outside" && new Date(previousDate) > new Date(disableBefore)) {
        return new Date(disableBefore);
    }
    if (availablePeriod === "before" && notValidDateToPass > new Date(disableAfter)) {
        return new Date(disableAfter);
    }
    if (availablePeriod === "after" && notValidDateToPass < new Date(disableBefore)) {
        return new Date(disableBefore);
    }
    return undefined;
};
exports.getValidTime = getValidTime;
