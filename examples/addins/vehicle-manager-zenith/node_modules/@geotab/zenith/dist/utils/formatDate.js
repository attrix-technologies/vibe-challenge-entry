"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deformatDate = exports.formatDate = exports.dayNamesShort = exports.dayNames = exports.monthNamesShort = exports.monthNames = void 0;
exports.monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
exports.monthNamesShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
exports.dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
exports.dayNamesShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const createMonthDaysNames = (t) => {
    const translate = function (arr, pos = 0, postfix = "") {
        return arr.map(function (a) {
            const part = pos ? a.substring(0, pos) : a;
            return t(part + postfix) || part;
        });
    };
    return {
        monthNames: translate(exports.monthNames),
        dayNames: translate(exports.dayNames),
        shortMonthNames: translate(exports.monthNamesShort),
        shortDayNames: translate(exports.dayNamesShort)
    };
};
const formatDate = function (dateSource, format, translate) {
    const monthsDaysNames = createMonthDaysNames(translate);
    const date = new Date(dateSource);
    const token = /d{1,4}|M{1,4}|yy(?:yy)?|y|([HhmsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g;
    const padString = function (valStr, len = 2) {
        let val = valStr.toString();
        while (val.length < len) {
            val = "0" + val;
        }
        return val;
    };
    const d = date.getDate();
    const day = date.getDay();
    const m = date.getMonth();
    const y = date.getFullYear();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const s = date.getSeconds();
    const mills = date.getMilliseconds();
    const flags = {
        d: d,
        dd: padString(d),
        ddd: monthsDaysNames.shortDayNames[day],
        dddd: monthsDaysNames.dayNames[day],
        M: m + 1,
        MM: padString(m + 1),
        MMM: monthsDaysNames.shortMonthNames[m],
        MMMM: monthsDaysNames.monthNames[m],
        y: parseInt(y.toString().slice(2)),
        yy: y.toString().slice(2),
        yyyy: y,
        h: hours % 12 || 12,
        hh: padString(hours % 12 || 12),
        H: hours,
        HH: padString(hours),
        m: minutes,
        mm: padString(minutes),
        s: s,
        ss: padString(s),
        l: padString(mills, 3),
        L: padString(mills > 99 ? Math.round(mills / 10) : mills),
        t: hours < 12 ? "a" : "p",
        tt: hours < 12 ? "am" : "pm",
        T: hours < 12 ? "A" : "P",
        TT: hours < 12 ? "AM" : "PM"
    };
    return format.replace(token, function (character) {
        return character in flags ? flags[character] : character.slice(1, character.length - 1);
    });
};
exports.formatDate = formatDate;
const deformatDate = function (dateSource, format, translate) {
    const monthsDaysNames = createMonthDaysNames(translate);
    // eslint-disable-next-line complexity
    const parseDate = (dateString, pformat) => {
        const formatTokens = pformat.split(/[^A-Za-z]/);
        const dateTokens = dateString.split(/[^A-Za-z0-9]+/);
        const dateComponents = {};
        formatTokens.filter(el => el).forEach((token, index) => {
            var _a;
            dateComponents[token] = (_a = dateTokens[index]) === null || _a === void 0 ? void 0 : _a.trim();
        });
        let year = 0;
        if (dateComponents["YYYY"] || dateComponents["yyyy"]) {
            year = parseInt(dateComponents["YYYY"] || dateComponents["yyyy"], 10);
        }
        else if (dateComponents["YY"] || dateComponents["yy"]) {
            year = parseInt(dateComponents["YY"] || dateComponents["yy"], 10);
            if (year < 100) {
                year += (year < 50) ? 2000 : 1900;
            }
        }
        let month = -1;
        if (dateComponents["MMM"]) {
            month = monthsDaysNames.shortMonthNames.indexOf(dateComponents["MMM"]);
        }
        else if (dateComponents["MMMM"]) {
            month = monthsDaysNames.monthNames.indexOf(dateComponents["MMMM"]);
        }
        else if (dateComponents["MM"] || dateComponents["mm"] || dateComponents["M"] || dateComponents["m"]) {
            month = (parseInt(dateComponents["MM"] || dateComponents["mm"] || dateComponents["M"] || dateComponents["m"], 10) - 1);
        }
        if (dateComponents["MM"]) {
            month = parseInt(dateComponents["MM"], 10) - 1;
        }
        else if (dateComponents["mm"]) {
            month = parseInt(dateComponents["mm"], 10) - 1;
        }
        else if (dateComponents["M"]) {
            month = parseInt(dateComponents["M"], 10) - 1;
        }
        else if (dateComponents["MMM"]) {
            const monthName = dateComponents["MMM"];
            const result = monthsDaysNames.shortMonthNames.findIndex((name) => name === monthName);
            month = result;
        }
        let day = 0;
        if (dateComponents["DD"] || dateComponents["dd"] || dateComponents["D"] || dateComponents["d"]) {
            day = parseInt(dateComponents["DD"] || dateComponents["dd"] || dateComponents["D"] || dateComponents["d"], 10);
        }
        const isHasError = isNaN(year) || isNaN(month) || month === -1 || isNaN(day);
        return isHasError ? "" : new Date(year, month, day);
    };
    const date = parseDate(dateSource, format);
    return date;
};
exports.deformatDate = deformatDate;
