export interface IAbortablePromiseOptions {
    signal?: AbortSignal;
}
type TResolve<T> = (value: T | PromiseLike<T>) => void;
type TReject<T> = (reason?: T) => void;
type TExecutor<T> = (resolve: TResolve<T>, reject: TReject<unknown>) => void;
export interface IAbortablePromiseConstructor {
    new <T>(executor: TExecutor<T>, options?: IAbortablePromiseOptions): AbortablePromise<T>;
    new <T>(promise: PromiseLike<T>, options?: IAbortablePromiseOptions): AbortablePromise<T>;
}
/**
 * Create an instance of AbortablePromise class.
 * @extends Promise
 */
export declare class AbortablePromise<T> extends Promise<T> {
    /**
     * Create an instance of AbortablePromise class.
     * E.g.:
     * ```ts
     * const promise = new AbortablePromise(
     *      (resolveValue: string) => { return resolveValue; }, (error: Error) => { console.error(error) },
     *      { signal: abortSignal }
     * );
     * ```
     * @param {Function} executor - Promise executor: `(resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void`.
     * @param {Object} [options] - Options (optinal parameter). Now it accepts only `signal: AbortSignal` option.
     */
    constructor(executor: TExecutor<T>, options?: IAbortablePromiseOptions);
    /**
     * Create an instance of AbortablePromise class based on another non-abortable Promise.
     * E.g.:
     * ```ts
     * const promise = new AbortablePromise(
     *      Promise.resolve(""),
     *      { signal: abortSignal }
     * );
     * ```
     * @param {PromiseLike} promise - PromiseLike object that should be abortable (e.g. `Promise`).
     * @param {Object} [options] - Options (optinal parameter). Now it accepts only `signal: AbortSignal` option.
     */
    constructor(promise: PromiseLike<T>, options?: IAbortablePromiseOptions);
}
export {};
