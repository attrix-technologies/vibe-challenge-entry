"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbortablePromise = void 0;
const isPromiseParam = (executor) => !!executor.then;
/**
 * Create an instance of AbortablePromise class.
 * @extends Promise
 */
class AbortablePromise extends Promise {
    constructor(executor, options = {}) {
        super((res, rej) => {
            var _a, _b;
            const abortHandler = () => {
                rej(new DOMException("Aborted", "AbortError"));
            };
            const resolveHandler = (val) => {
                var _a, _b;
                (_a = options.signal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortHandler, false);
                !((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) && res(val);
            };
            const rejectHandler = e => {
                var _a, _b;
                (_a = options.signal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortHandler, false);
                !((_b = options.signal) === null || _b === void 0 ? void 0 : _b.aborted) && rej(e);
            };
            isPromiseParam(executor)
                ? executor.then(resolveHandler, rejectHandler)
                : executor(resolveHandler, rejectHandler);
            // If signal is already aborted then just abort promise
            if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                abortHandler();
            }
            // If we received abort event from signal then abort internal promise
            (_b = options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener("abort", abortHandler, false);
        });
    }
}
exports.AbortablePromise = AbortablePromise;
