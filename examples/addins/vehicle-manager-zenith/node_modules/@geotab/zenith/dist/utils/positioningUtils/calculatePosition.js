"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePosition = void 0;
const getRelativeParent_1 = require("../getRelativeParent");
const adjustParentRect_1 = require("./adjustParentRect");
const alignments_1 = require("./alignments");
const getBorders_1 = require("./getBorders");
const getMargins_1 = require("./getMargins");
const normalizePosition_1 = require("./normalizePosition");
// eslint-disable-next-line complexity
const calculatePosition = (triggerRef, popupRef, paddingX, paddingY, inline, alignment, alignmentsFn = alignments_1.alignments, scrollParent) => {
    if (!triggerRef.current || !popupRef.current) {
        return;
    }
    const triggerElement = triggerRef.current;
    const popup = popupRef.current;
    const triggerRect = triggerElement.getBoundingClientRect();
    let popupRect = popup.getBoundingClientRect();
    const relativeParent = inline ? ((0, getRelativeParent_1.getRelativeParent)(triggerElement) || document.body) : document.body;
    popup.classList.add("zen-calculate-position");
    const parentDomRect = relativeParent.getBoundingClientRect();
    popup.classList.remove("zen-calculate-position");
    const parentBorders = (0, getBorders_1.getBorders)(relativeParent);
    const parentMargins = (0, getMargins_1.getMargins)(relativeParent);
    const parentRect = {
        top: parentDomRect.top + parentBorders.top - parentMargins.top,
        bottom: parentDomRect.bottom - parentBorders.bottom - parentMargins.bottom,
        left: parentDomRect.left + parentBorders.left - parentMargins.left,
        right: parentDomRect.right - parentBorders.right + parentMargins.right,
        height: window.innerHeight - parentDomRect.y,
        width: window.innerWidth - parentDomRect.x
    };
    (0, adjustParentRect_1.adjustParentRect)(parentRect);
    const alignmentFn = alignment ? alignmentsFn[alignment] : alignmentsFn["bottom-left"];
    let position = alignmentFn(triggerRect, popupRect, parentRect, paddingX || 0, paddingY || 0);
    (0, normalizePosition_1.normalizePosition)(position, popupRect, parentRect);
    if (position.width) {
        popup.style.width = `${position.width}px`;
    }
    if (position.height) {
        popup.style.maxHeight = `${position.height}px`;
    }
    popupRect = popup.getBoundingClientRect();
    position = alignmentFn(triggerRect, popupRect, parentRect, paddingX || 0, paddingY || 0);
    (0, normalizePosition_1.normalizePosition)(position, popupRect, parentRect);
    const scrollParentRect = scrollParent === null || scrollParent === void 0 ? void 0 : scrollParent.getBoundingClientRect();
    if (scrollParentRect && scrollParentRect.top > 0 && triggerRect.top < scrollParentRect.top) {
        position.top = scrollParentRect.top;
    }
    else if (triggerRect.top + triggerRect.height < 0 && triggerRect.top > ((scrollParentRect === null || scrollParentRect === void 0 ? void 0 : scrollParentRect.top) || 0)) {
        position.top = window.scrollY;
    }
    const isTopsideAlignment = alignment === null || alignment === void 0 ? void 0 : alignment.startsWith("top");
    const isRightsideAlignment = alignment === null || alignment === void 0 ? void 0 : alignment.startsWith("right");
    const isLeftsideAlignment = alignment === null || alignment === void 0 ? void 0 : alignment.startsWith("left");
    if (scrollParentRect && triggerRect.bottom > scrollParentRect.bottom) {
        position.top = (scrollParentRect.bottom + popupRect.height) <= (window.innerHeight + window.scrollY) ? scrollParentRect.bottom : (window.innerHeight + window.scrollY) - popupRect.height;
    }
    else if ((isRightsideAlignment || isLeftsideAlignment) && position.top !== undefined) {
        const popupBottom = position.top + parentRect.top + popupRect.height;
        if (popupBottom > window.innerHeight) {
            const overflow = popupBottom - window.innerHeight;
            position.top = position.top - overflow;
            if (position.top < 0) {
                position.top = 0;
            }
        }
    }
    else if (!isTopsideAlignment && triggerRect.y + triggerRect.height + popupRect.height > window.innerHeight) {
        const newTopPosition = window.innerHeight + window.scrollY - popupRect.height;
        position.top = newTopPosition < 0 ? 0 : newTopPosition;
    }
    Object.keys(position).forEach((prop) => {
        const property = prop === "height" ? "maxHeight" : prop;
        return popup.style[property] = `${position[prop]}px`;
    });
};
exports.calculatePosition = calculatePosition;
