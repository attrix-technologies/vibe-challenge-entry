"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.positionPopup = exports.getSelectInitialState = exports.getSelectValue = void 0;
const getBorders_1 = require("../utils/positioningUtils/getBorders");
const checkboxState_1 = require("../checkbox/checkboxState");
const selectList_helpers_1 = require("../selectList/selectList.helpers");
const getParentWithHiddenOverflow_1 = require("../utils/getParentWithHiddenOverflow");
const getRelativeParent_1 = require("../utils/getRelativeParent");
const getSelectValue = (state, items) => {
    var _a;
    const newValIndex = (0, selectList_helpers_1.getFirstActiveIndex)(state, items, false);
    return (_a = items[newValIndex]) === null || _a === void 0 ? void 0 : _a.id;
};
exports.getSelectValue = getSelectValue;
const getSelectInitialState = (props) => {
    const state = props.items.map(item => [item.id, item.id === props.value ? checkboxState_1.CheckboxState.On : checkboxState_1.CheckboxState.Off]);
    return Object.assign(Object.assign({ expanded: false }, (0, selectList_helpers_1.getInitialState)({ items: props.items, multiselect: false })), { itemsState: new Map(state) });
};
exports.getSelectInitialState = getSelectInitialState;
const getElementInnerRect = (elRect, bordersRect) => ({
    top: elRect.top + bordersRect.top,
    bottom: elRect.bottom - bordersRect.bottom,
    left: elRect.left + bordersRect.left,
    right: elRect.right - bordersRect.right,
    height: elRect.height - bordersRect.top - bordersRect.bottom,
    width: elRect.width - bordersRect.left - bordersRect.right
});
const positionPopup = (triggerElement, popupEl, acceptableMinPopupHeight = 0, maxPopupHeight = Number.POSITIVE_INFINITY) => {
    popupEl.style.height = "auto";
    const triggerRect = triggerElement.getBoundingClientRect();
    const relativeParent = (0, getRelativeParent_1.getRelativeParent)(triggerElement) || document.body;
    const parentDomRect = relativeParent.getBoundingClientRect();
    const parentBorders = (0, getBorders_1.getBorders)(relativeParent);
    const parentRect = getElementInnerRect(parentDomRect, parentBorders);
    const cuttingParent = (0, getParentWithHiddenOverflow_1.getParentWithHiddenOverflow)(triggerElement) || document.body;
    const cuttingParentDomRect = cuttingParent.getBoundingClientRect();
    const cuttingParentBorders = (0, getBorders_1.getBorders)(relativeParent);
    const cuttingParentRect = getElementInnerRect(cuttingParentDomRect, cuttingParentBorders);
    const spaceToTop = triggerRect.top - cuttingParentRect.top;
    const spaceToBottom = cuttingParentRect.bottom - triggerRect.bottom;
    const alignment = (spaceToBottom < acceptableMinPopupHeight && spaceToTop > spaceToBottom) ? "top" : "bottom";
    const childrenHeight = popupEl.scrollHeight;
    const position = alignment === "bottom"
        ? {
            top: triggerRect.top - parentRect.top + triggerRect.height,
            bottom: undefined,
            height: Math.min(maxPopupHeight, spaceToBottom, childrenHeight)
        }
        : {
            top: undefined,
            bottom: parentRect.bottom - triggerRect.bottom + triggerRect.height,
            height: Math.min(maxPopupHeight, spaceToTop, childrenHeight)
        };
    Object.keys(position).forEach((prop) => {
        const propValue = position[prop];
        popupEl.style[prop] = propValue === undefined ? "auto" : `${propValue}px`;
    });
};
exports.positionPopup = positionPopup;
