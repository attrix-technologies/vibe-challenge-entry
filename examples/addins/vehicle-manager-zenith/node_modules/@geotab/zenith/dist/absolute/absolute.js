"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Absolute = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const react_dom_1 = require("react-dom");
const focusableSelector_1 = require("../utils/focusableSelector");
const isChildPopup_1 = require("../utils/positioningUtils/isChildPopup");
const useEscape_1 = require("../commonHelpers/hooks/useEscape");
const useResize_1 = require("../commonHelpers/hooks/useResize");
const useTrapFocus_1 = require("../commonHelpers/hooks/useTrapFocus");
const isChildOf_1 = require("../utils/isChildOf");
const dialogHelpers_1 = require("../dialog/dialogHelpers");
const calculatePosition_1 = require("../utils/positioningUtils/calculatePosition");
const useArrowKey_1 = require("../commonHelpers/hooks/useArrowKey");
const themeContext_1 = require("../utils/theme/themeContext");
const useScroll_1 = require("../commonHelpers/hooks/useScroll");
const getScrollableParent_1 = require("../utils/getScrollableParent");
const Absolute = ({ isOpen, id, paddingX, paddingY, className, children, triggerRef, alignment, inline, onOpenChange, useTrapFocusWithTrigger = "off", shouldHoldScroll, stateFullChilds, role, ariaLabel, ariaLabelledby, alignmentsFn, recalculateOnScroll, recalculateTrigger = true }) => {
    const popupRef = (0, react_1.useRef)(null);
    const prevScroll = (0, react_1.useRef)(0);
    const { dark } = (0, react_1.useContext)(themeContext_1.themeContext);
    const onScrollHandler = (e) => {
        var _a;
        prevScroll.current = (_a = e.target) === null || _a === void 0 ? void 0 : _a.scrollTop;
    };
    const accessibleAttr = (0, react_1.useMemo)(() => {
        if (!role) {
            return {};
        }
        return Object.assign(Object.assign({ role }, (ariaLabelledby ? { "aria-labelledby": ariaLabelledby } : {})), (ariaLabel && !ariaLabelledby ? { "aria-label": ariaLabel } : {}));
    }, [role, ariaLabelledby, ariaLabel]);
    const darkClassName = dark ? "zen-dark" : "";
    const renderPopup = () => {
        if (isOpen) {
            const result = (0, jsx_runtime_1.jsx)("div", Object.assign({}, accessibleAttr, { ref: popupRef, id: id, onScroll: shouldHoldScroll ? onScrollHandler : undefined, className: (0, classNames_1.classNames)(["zen-absolute", darkClassName, className || ""]), children: children }));
            if (inline) {
                return result;
            }
            return (0, react_dom_1.createPortal)(result, document.fullscreenElement || document.body);
        }
        return "";
    };
    const parent = (0, react_1.useMemo)(() => {
        if (!isOpen || !recalculateOnScroll) {
            return null;
        }
        return (0, getScrollableParent_1.getScrollableParent)(triggerRef.current);
    }, [triggerRef, isOpen, recalculateOnScroll]);
    const calculatePosition = (0, react_1.useCallback)(() => (0, calculatePosition_1.calculatePosition)(triggerRef, popupRef, paddingX, paddingY, inline, alignment, alignmentsFn, parent ? parent : undefined), [triggerRef, paddingX, paddingY, inline, alignment, alignmentsFn, popupRef, parent]);
    (0, useResize_1.useResize)(calculatePosition, isOpen);
    (0, useScroll_1.useScroll)(calculatePosition, isOpen, parent);
    (0, react_1.useLayoutEffect)(calculatePosition, [isOpen, children, recalculateTrigger, calculatePosition]);
    function handleEscape() {
        onOpenChange(false);
        if (!triggerRef.current) {
            return;
        }
        if ((0, dialogHelpers_1.isFocusable)(triggerRef.current)) {
            triggerRef.current.focus();
            return;
        }
        const focusable = [...Array.from(triggerRef.current.querySelectorAll(focusableSelector_1.FOCUSABLE_SELECTOR))];
        (focusable[0] || triggerRef.current).focus();
    }
    const condition = (0, react_1.useCallback)(() => useTrapFocusWithTrigger === "off" ? false : true, [useTrapFocusWithTrigger]);
    (0, useTrapFocus_1.useTrapFocus)(popupRef, useTrapFocusWithTrigger === "withTrigger" ? triggerRef : undefined, isOpen, condition);
    (0, useEscape_1.useEscape)(popupRef, handleEscape, isOpen);
    (0, useArrowKey_1.useArrowKey)(popupRef, handleEscape, isOpen);
    (0, react_1.useEffect)(() => {
        var _a, _b;
        const closeOnClickOutside = (e) => {
            if (!popupRef.current) {
                return;
            }
            if (!e.target) {
                return;
            }
            const isClickInPopup = (0, isChildPopup_1.isChildPopup)(e.target, popupRef.current);
            const isClickOnTrigger = triggerRef.current ? e.target === triggerRef.current || (0, isChildOf_1.isChildOf)(e.target, triggerRef.current) : false;
            if (isClickInPopup || isClickOnTrigger || stateFullChilds) {
                return;
            }
            onOpenChange(false);
        };
        if (isOpen) {
            document.body.addEventListener("click", closeOnClickOutside, true);
            const firstFocusable = (_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(focusableSelector_1.FOCUSABLE_SELECTOR);
            if (useTrapFocusWithTrigger !== "withTrigger") {
                if (firstFocusable) {
                    firstFocusable.focus();
                }
                else {
                    (_b = popupRef.current) === null || _b === void 0 ? void 0 : _b.focus();
                }
            }
            return () => {
                document.body.removeEventListener("click", closeOnClickOutside, true);
            };
        }
        return () => { };
    }, [isOpen, onOpenChange, triggerRef, useTrapFocusWithTrigger, stateFullChilds]);
    (0, react_1.useEffect)(() => {
        var _a;
        if (isOpen) {
            (_a = popupRef.current) === null || _a === void 0 ? void 0 : _a.removeAttribute("style");
            calculatePosition();
        }
        return () => { };
    }, [calculatePosition, children, isOpen]);
    (0, react_1.useEffect)(() => {
        if (isOpen) {
            if (popupRef.current && prevScroll.current && shouldHoldScroll) {
                popupRef.current.scrollTop = prevScroll.current;
            }
        }
        else {
            prevScroll.current = 0;
        }
    }, [children, isOpen, shouldHoldScroll]);
    return renderPopup();
};
exports.Absolute = Absolute;
