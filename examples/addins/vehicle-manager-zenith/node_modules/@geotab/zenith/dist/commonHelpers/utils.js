"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepClone = exports.deepMerge = exports.flattenArrays = exports.echo = exports.generateId = void 0;
const generateId = () => "id" + Math.random().toString().substring(2);
exports.generateId = generateId;
const echo = (_) => _;
exports.echo = echo;
function flattenArrays(arrayOfArrays) {
    return arrayOfArrays.reduce((akk, arr) => akk.concat(arr), []);
}
exports.flattenArrays = flattenArrays;
function isObject(item) {
    return (typeof item === "object" && !Array.isArray(item) && item !== null);
}
function deepMerge(obj1, obj2) {
    const output = Object.assign({}, obj1);
    Object.entries(obj2).forEach(([key, value]) => {
        if (isObject(value) && key in obj1 && isObject(obj1[key])) {
            output[key] = deepMerge(obj1[key], value);
        }
        else {
            output[key] = value;
        }
    });
    return output;
}
exports.deepMerge = deepMerge;
const deepCloneFallback = (candidateToCopy) => {
    if (typeof candidateToCopy !== "object" || candidateToCopy === null) {
        return candidateToCopy;
    }
    if (candidateToCopy instanceof Date) {
        return new Date(candidateToCopy);
    }
    if (candidateToCopy instanceof Set) {
        return new Set(candidateToCopy);
    }
    if (candidateToCopy instanceof Map) {
        return new Map(candidateToCopy);
    }
    if (Array.isArray(candidateToCopy)) {
        return candidateToCopy.map(deepCloneFallback);
    }
    return Object.keys(candidateToCopy).reduce((acc, key) => {
        acc[key] = deepCloneFallback(candidateToCopy[key]);
        return acc;
    }, {});
};
const deepClone = (candidateToCopy) => {
    if (typeof window.structuredClone === "function") {
        return window.structuredClone(candidateToCopy);
    }
    return (candidateToCopy === undefined ? undefined : deepCloneFallback(candidateToCopy));
};
exports.deepClone = deepClone;
