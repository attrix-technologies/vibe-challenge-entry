"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTrapFocus = void 0;
const react_1 = require("react");
const dialogHelpers_1 = require("../../dialog/dialogHelpers");
const focusableSelector_1 = require("../../utils/focusableSelector");
const useKeydown_1 = require("./useKeydown");
const isChildOf_1 = require("../../utils/isChildOf");
const isElementHidden_1 = require("../../utils/isElementHidden");
const findFirstVisible = (elems, isElementVisible) => elems.find(elem => isElementVisible(elem));
const useTrapFocus = (containerRef, triggerRef, subscriptionTrigger, condition, isElementVisible) => {
    const handleKeyDown = (0, react_1.useCallback)((e) => {
        var _a;
        const getChildCondition = () => triggerRef
            ? !(0, isChildOf_1.isChildOf)(e.target, containerRef.current) && e.target !== document.body && !(0, isChildOf_1.isChildOf)(e.target, triggerRef.current)
            : !(0, isChildOf_1.isChildOf)(e.target, containerRef.current) && e.target !== document.body;
        if (!containerRef.current || getChildCondition()) {
            return;
        }
        const checkIsElementOutside = (target, containerEl, triggerEl) => !triggerEl ? !(0, dialogHelpers_1.isElementInsideContainer)(target, containerEl.current)
            : !(0, dialogHelpers_1.isElementInsideContainer)(target, containerEl.current) && !(0, dialogHelpers_1.isElementInsideContainer)(target, triggerEl.current);
        const isTargetOutside = e.target ? checkIsElementOutside(e.target, containerRef, triggerRef) : undefined;
        const triggerSelectors = ((_a = triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll(focusableSelector_1.FOCUSABLE_SELECTOR)) || [];
        const containerSelectors = containerRef.current.querySelectorAll(focusableSelector_1.FOCUSABLE_SELECTOR);
        const focusable = triggerRef ? [...Array.from(triggerSelectors), ...Array.from(containerSelectors)] : [...Array.from(containerSelectors)];
        if (!focusable.length) {
            return;
        }
        const isElemVisible = isElementVisible ? isElementVisible : (elm) => !(0, isElementHidden_1.isElementHidden)(elm);
        if (e.key === "Tab") {
            const first = findFirstVisible(focusable, isElemVisible);
            const last = findFirstVisible([...focusable].reverse(), isElemVisible);
            const firstContainerFocusable = findFirstVisible(Array.from(containerSelectors), isElemVisible);
            const lastTriggerFocusable = findFirstVisible([...Array.from(triggerSelectors)].reverse(), isElemVisible);
            if (isTargetOutside) {
                e.preventDefault();
                first === null || first === void 0 ? void 0 : first.focus();
                return;
            }
            if (e.shiftKey) {
                if (document.activeElement === first) {
                    e.preventDefault();
                    last === null || last === void 0 ? void 0 : last.focus();
                    return;
                }
                if (firstContainerFocusable && document.activeElement === firstContainerFocusable) {
                    e.preventDefault();
                    lastTriggerFocusable === null || lastTriggerFocusable === void 0 ? void 0 : lastTriggerFocusable.focus();
                }
                return;
            }
            if (document.activeElement === last) {
                e.preventDefault();
                first === null || first === void 0 ? void 0 : first.focus();
                return;
            }
            if (lastTriggerFocusable && document.activeElement === lastTriggerFocusable) {
                e.preventDefault();
                firstContainerFocusable === null || firstContainerFocusable === void 0 ? void 0 : firstContainerFocusable.focus();
            }
            return;
        }
    }, [containerRef, triggerRef, isElementVisible]);
    (0, useKeydown_1.useKeydown)(handleKeyDown, subscriptionTrigger, condition);
};
exports.useTrapFocus = useTrapFocus;
