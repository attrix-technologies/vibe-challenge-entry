"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFeedbackToast = void 0;
const react_1 = require("react");
const useMobile_1 = require("../../commonHelpers/hooks/useMobile");
const useFeedbackToastState_1 = require("./useFeedbackToastState");
const isToastValid_1 = require("../utils/isToastValid");
const getParentWindow_1 = require("../../utils/getParentWindow");
const TOAST_MAX_NUMBER_DESKTOP = 5;
const TOASTS_MAX_NUMBER_MOBILE = 3;
const useFeedbackToast = ({ setActiveFeedback, mode = "default" }) => {
    const isAPIMode = mode === "api";
    const { toasts, setToasts, toastsQueue, setToastsQueue, toastsAnimation, setToastsAnimation, removedToastId, apiToastActions, setApiToastActions } = (0, useFeedbackToastState_1.useFeedbackToastState)();
    const isMobile = (0, useMobile_1.useMobile)();
    const toastMaxNumber = isMobile ? TOASTS_MAX_NUMBER_MOBILE : TOAST_MAX_NUMBER_DESKTOP;
    const topView = (0, getParentWindow_1.getParentWindow)(window) || window;
    const removeToast = (0, react_1.useCallback)((id, important) => {
        if (isAPIMode) {
            if (!apiToastActions.find(el => el.id === id)) {
                return;
            }
            setApiToastActions((prevToasts) => prevToasts.filter((el) => el.id !== id));
            topView.dispatchEvent(new CustomEvent("removeZenithToast", { detail: id }));
            return;
        }
        const renderedToast = toasts.find((toast) => toast.id === id);
        if (!renderedToast) {
            return;
        }
        setToasts((prevToasts) => {
            const toastIndex = prevToasts.findIndex((toast) => toast.id === id);
            if (toastIndex === -1) {
                return prevToasts;
            }
            // TODO: check for mobile
            prevToasts[toastIndex].animation = "left-right";
            return [...prevToasts];
        });
        if (important) {
            setToastsQueue((prevToasts) => [{ value: renderedToast, action: "remove", id }, ...prevToasts]);
        }
        else {
            setToastsQueue((prevToasts) => [...prevToasts, { value: renderedToast, action: "remove", id }]);
        }
        setActiveFeedback("toast");
    }, [isAPIMode, toasts, setToasts, setToastsQueue, setActiveFeedback, apiToastActions, setApiToastActions, topView]);
    const finishToastAnimation = (0, react_1.useCallback)((toastId) => {
        setToastsAnimation((prevAnimations) => {
            const toastAnimation = prevAnimations.find((animation) => animation.id === toastId);
            if (!toastAnimation) {
                return prevAnimations;
            }
            toastAnimation.isFinished = true;
            return [...prevAnimations];
        });
    }, [setToastsAnimation]);
    const hasAllActionsHasAnimations = (0, react_1.useCallback)(() => toastsQueue.map(el => el.id).every(el => toastsAnimation.find(animation => animation.id === el)), [toastsAnimation, toastsQueue]);
    const findAllNotAnimatedActions = (0, react_1.useCallback)(() => toastsQueue.filter(el => !toastsAnimation.find(animation => animation.id === el.id)), [toastsAnimation, toastsQueue]);
    (0, react_1.useEffect)(() => {
        if (!hasAllActionsHasAnimations()) {
            const notAnimatedActions = findAllNotAnimatedActions();
            setToastsAnimation((prevAnimations) => {
                const newAnimations = notAnimatedActions.map((action) => {
                    if (action.action === "add") {
                        return { id: action.id, isFinished: null };
                    }
                    return ({ id: action.id, isFinished: false });
                });
                return [...prevAnimations, ...newAnimations];
            });
            return;
        }
        const notFinishedAnimations = toastsAnimation.filter(animation => animation.isFinished === false);
        // wait until all animations are finished
        if (notFinishedAnimations.length) {
            return;
        }
        if (toasts.length > toastMaxNumber) {
            const finishedAlertAnimations = toastsAnimation.filter(animation => animation.isFinished === true);
            const firstToast = toasts[0];
            const firstToastAnimation = finishedAlertAnimations.find((animation) => animation.id === firstToast.id);
            if (!firstToastAnimation) {
                removedToastId.current = 0;
                finishToastAnimation(firstToast.id);
                removeToast(firstToast.id, true);
                // TODO:
                firstToast.onClose();
                return;
            }
        }
        if (toastsQueue.length) {
            const toastQueueItem = toastsQueue[0];
            const animation = toastsAnimation.find((toastAnimation) => toastAnimation.id === toastQueueItem.id);
            if (toastQueueItem.action === "add") {
                if (animation && toastsQueue.length > 1) {
                    setToastsAnimation((prevAnimations) => {
                        const toastAnimation = prevAnimations.find((an) => an.id === toastQueueItem.id);
                        if (!toastAnimation) {
                            return prevAnimations;
                        }
                        toastAnimation.isFinished = false;
                        return [...prevAnimations];
                    });
                }
                setToasts((prevToasts) => [...prevToasts, toastQueueItem.value]);
                setToastsQueue((prevToasts) => prevToasts.filter((toast) => toast.id !== toastQueueItem.id));
                return;
            }
            const removedToastsQueue = toastsQueue.filter((toast) => toast.action === "remove");
            const finishedAnimations = toastsAnimation.filter(el => el.isFinished === true);
            if (removedToastsQueue.length && finishedAnimations.length) {
                removedToastsQueue.forEach((toast) => {
                    const toastAnimation = finishedAnimations.find((el) => el.id === toast.id);
                    if (!toastAnimation) {
                        return;
                    }
                    setToasts((prevToasts) => prevToasts.filter((el) => el.id !== toast.id));
                    setToastsQueue((prevToasts) => prevToasts.filter((el) => el.id !== toast.id));
                    setToastsAnimation((prevAnimations) => prevAnimations.filter((el) => el.id !== toast.id));
                });
            }
        }
        if (toasts.length && toastsAnimation.length) {
            const finishedAnimations = toastsAnimation.filter(animation => animation.isFinished === true);
            if (!finishedAnimations.length) {
                return;
            }
            const renderedToastsIds = toasts.filter((toast) => finishedAnimations.some((animation) => animation.id === toast.id)).map((toast) => toast.id);
            if (renderedToastsIds.length) {
                setToastsAnimation((prevAnimations) => prevAnimations.filter((toastAnimation) => !renderedToastsIds.includes(toastAnimation.id)));
            }
        }
    }, [
        toastsQueue,
        toastsAnimation,
        toasts,
        toastMaxNumber,
        removeToast,
        removedToastId,
        setToasts,
        setToastsQueue,
        setToastsAnimation,
        finishToastAnimation,
        hasAllActionsHasAnimations,
        findAllNotAnimatedActions
    ]);
    const startToastAnimation = (0, react_1.useCallback)((toastId) => {
        if (!toastId) {
            return;
        }
        setToastsAnimation((prevAnimations) => {
            const toastAnimation = prevAnimations.find((animation) => animation.id === toastId);
            if (!toastAnimation) {
                return prevAnimations;
            }
            toastAnimation.isFinished = false;
            return [...prevAnimations];
        });
    }, [setToastsAnimation]);
    const addToast = (0, react_1.useCallback)((toast) => {
        if (isAPIMode) {
            if (apiToastActions.find(el => el.id === toast.id)) {
                return;
            }
            setApiToastActions((prevToasts) => [...prevToasts, { value: toast, action: "add", id: toast.id }]);
            topView.dispatchEvent(new CustomEvent("addZenithToast", { detail: toast }));
            return;
        }
        setToastsQueue((prevToasts) => [...prevToasts, { value: toast, action: "add", id: toast.id }]);
        setActiveFeedback("toast");
    }, [isAPIMode, setToastsQueue, setActiveFeedback, apiToastActions, setApiToastActions, topView]);
    (0, react_1.useEffect)(() => {
        // TODO: add test
        if (mode === "default") {
            const addZenithToastCallback = (event) => {
                const toast = event.detail;
                if (!(0, isToastValid_1.isToastValid)(toast)) {
                    return;
                }
                addToast(toast);
            };
            const removeZenithToastCallback = (event) => {
                const toastId = event.detail;
                if (!toastId) {
                    return;
                }
                removeToast(toastId);
                removedToastId.current = toasts.findIndex((toast) => toast.id === toastId);
            };
            topView.addEventListener("addZenithToast", addZenithToastCallback);
            topView.addEventListener("removeZenithToast", removeZenithToastCallback);
            return () => {
                topView.removeEventListener("addZenithToast", addZenithToastCallback);
                topView.removeEventListener("removeZenithToast", removeZenithToastCallback);
            };
        }
        return () => { };
    }, [addToast, mode, topView, removeToast, removedToastId, toasts]);
    return {
        toasts,
        toastsQueue,
        toastsAnimation,
        setToasts,
        setToastsQueue,
        setToastsAnimation,
        removeToast,
        toastMaxNumber,
        addToast,
        finishToastAnimation,
        startToastAnimation,
        removedToastId,
        apiToastActions,
        setApiToastActions
    };
};
exports.useFeedbackToast = useFeedbackToast;
