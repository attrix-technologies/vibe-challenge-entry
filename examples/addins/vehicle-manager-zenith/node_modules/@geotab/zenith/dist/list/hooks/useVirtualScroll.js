"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useVirtualScroll = void 0;
const react_1 = require("react");
const getScrollableParent_1 = require("../../utils/getScrollableParent");
const findVisibleListItems_1 = require("../utils/findVisibleListItems");
const FIRST_RENDERED_ROWS = 100;
const useVirtualScroll = (ref, children) => {
    const isEnabled = (0, react_1.useMemo)(() => {
        if (children && Array.isArray(children)) {
            return children.length > FIRST_RENDERED_ROWS;
        }
        return false;
    }, [children]);
    const [scrollableParent, setScrollableParent] = (0, react_1.useState)(null);
    const observerRef = (0, react_1.useRef)(null);
    const updateScrollableParent = (0, react_1.useCallback)(() => {
        const parent = (0, getScrollableParent_1.getScrollableParent)(ref.current);
        setScrollableParent(parent || null);
        return parent;
    }, [ref]);
    (0, react_1.useEffect)(() => {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (isEnabled && !observerRef.current && ResizeObserver) {
            observerRef.current = new ResizeObserver(updateScrollableParent);
        }
        const parent = updateScrollableParent();
        if (parent) {
            (_a = observerRef.current) === null || _a === void 0 ? void 0 : _a.observe(parent);
        }
        return () => {
            var _a;
            if (parent) {
                (_a = observerRef.current) === null || _a === void 0 ? void 0 : _a.unobserve(parent);
            }
        };
    }, [isEnabled, ref, updateScrollableParent]);
    const initialVisibleRows = (0, react_1.useMemo)(() => {
        if (children && Array.isArray(children)) {
            return children.slice(0, FIRST_RENDERED_ROWS).map(r => r.props.id);
        }
        return [];
    }, [children]);
    const [visibleRows, setVisibleRows] = (0, react_1.useState)(new Set(initialVisibleRows));
    const isInViewport = (0, react_1.useCallback)((id) => visibleRows.has(id), [visibleRows]);
    (0, react_1.useEffect)(() => {
        setVisibleRows(new Set(initialVisibleRows));
    }, [initialVisibleRows]);
    const getVisibleRows = (0, react_1.useCallback)(() => {
        if (!ref.current) {
            return [];
        }
        if (!scrollableParent) {
            return [];
        }
        const { top, bottom } = scrollableParent.getBoundingClientRect();
        return (0, findVisibleListItems_1.findVisibleListItems)([...ref.current.children], top, bottom);
    }, [ref, scrollableParent]);
    const scheduleVisibleChanges = (0, react_1.useCallback)(() => requestAnimationFrame(() => {
        const visible = getVisibleRows();
        const newVisibleRows = visible.filter(row => {
            const id = row.dataset.listItemId;
            if (id === undefined) {
                return false;
            }
            return true;
        }).map(row => row.dataset.listItemId);
        const hasNewRows = newVisibleRows.some(id => !visibleRows.has(id));
        if (hasNewRows) {
            const newRowsSet = new Set(newVisibleRows);
            initialVisibleRows.forEach(row => newRowsSet.add(row));
            setVisibleRows(newRowsSet);
        }
    }), [getVisibleRows, initialVisibleRows, visibleRows]);
    const lazyRenderTimerRef = (0, react_1.useRef)(0);
    const scheduleLazyRender = (0, react_1.useCallback)(() => {
        cancelAnimationFrame(lazyRenderTimerRef.current);
        lazyRenderTimerRef.current = scheduleVisibleChanges();
    }, [scheduleVisibleChanges]);
    const handleScroll = (0, react_1.useCallback)(() => {
        scheduleLazyRender();
    }, [scheduleLazyRender]);
    (0, react_1.useEffect)(() => {
        if (!ref.current) {
            return () => { };
        }
        if (!isEnabled) {
            return () => { };
        }
        if (scrollableParent) {
            scrollableParent.addEventListener("scroll", handleScroll);
        }
        return () => {
            if (scrollableParent) {
                scrollableParent.removeEventListener("scroll", handleScroll);
            }
        };
    }, [handleScroll, isEnabled, ref, scrollableParent]);
    (0, react_1.useEffect)(() => {
        if (children && Array.isArray(children)) {
            scheduleLazyRender();
        }
    }, [children, getVisibleRows, scheduleLazyRender]);
    return { isInViewport };
};
exports.useVirtualScroll = useVirtualScroll;
