"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDragAndDrop = void 0;
const react_1 = require("react");
const getScrollableParent_1 = require("../../utils/getScrollableParent");
const findListElement_1 = require("../utils/findListElement");
const useContainerScroll_1 = require("./useContainerScroll");
const findItemPosition_1 = require("../utils/findItemPosition");
const useDragAndDrop = (containerRef, onChangeOrder) => {
    const dragImageRef = (0, react_1.useRef)(null);
    const dragMoveRef = (0, react_1.useRef)(undefined);
    const { moveScroll, cancelMoveScroll } = (0, useContainerScroll_1.useContainerScroll)();
    const getPlaceholder = (0, react_1.useCallback)((height) => {
        const placeholder = document.createElement("li");
        placeholder.className = "zen-list-item zen-list-item--placeholder";
        placeholder.style.height = height + "px";
        return placeholder;
    }, []);
    const removePlaceholders = (0, react_1.useCallback)((element) => {
        const placeholders = element.querySelectorAll(".zen-list-item--placeholder");
        for (const placeholder of placeholders) {
            placeholder.remove();
        }
    }, []);
    const setPlaceholder = (0, react_1.useCallback)((element) => {
        if (!containerRef.current) {
            return;
        }
        const items = containerRef.current.querySelectorAll(".zen-list-item");
        const rect = element.getBoundingClientRect();
        const listRect = containerRef.current.getBoundingClientRect();
        if (rect.top < listRect.top) {
            // If the dragged element is above the list, insert placeholder at the top
            const placeholder = getPlaceholder(rect.height);
            removePlaceholders(containerRef.current);
            const firstChild = containerRef.current.firstChild;
            if (firstChild) {
                containerRef.current.insertBefore(placeholder, firstChild);
            }
            else {
                containerRef.current.appendChild(placeholder);
            }
            return;
        }
        if (rect.top > listRect.bottom) {
            const placeholder = getPlaceholder(rect.height);
            removePlaceholders(containerRef.current);
            containerRef.current.appendChild(placeholder);
            return;
        }
        const dragItemTopOffset = 4;
        for (const item of items) {
            if (item.classList.contains("zen-list-item--placeholder") || item.classList.contains("zen-list-item--dragging")) {
                continue;
            }
            const itemRect = item.getBoundingClientRect();
            if (item !== element && rect.top > itemRect.top + dragItemTopOffset && rect.top <= itemRect.bottom) {
                const placeholder = getPlaceholder(rect.height);
                removePlaceholders(containerRef.current);
                const next = item.nextSibling;
                if (next) {
                    containerRef.current.insertBefore(placeholder, next);
                }
                else {
                    containerRef.current.appendChild(placeholder);
                }
                return;
            }
        }
    }, [containerRef, getPlaceholder, removePlaceholders]);
    const onDragStart = (0, react_1.useCallback)((e) => {
        const listItemElement = (0, findListElement_1.findListElement)(e.currentTarget);
        if (!listItemElement) {
            return;
        }
        const startPosition = (0, findItemPosition_1.findItemPosition)(listItemElement);
        const rect = listItemElement.getBoundingClientRect();
        const offset = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
        const div = listItemElement.cloneNode(true);
        document.body.appendChild(div);
        dragImageRef.current = div;
        div.style.position = "absolute";
        div.style.left = (e.clientX - offset.x) + "px";
        div.style.top = (e.clientY - offset.y) + "px";
        div.style.width = listItemElement.offsetWidth + "px";
        div.style.height = listItemElement.offsetHeight + "px";
        dragMoveRef.current = (moveEvent) => {
            if (!dragImageRef.current) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            const pageScroll = window ? window.scrollY : 0;
            dragImageRef.current.style.left = (moveEvent.clientX - offset.x) + "px";
            dragImageRef.current.style.top = (pageScroll + moveEvent.clientY - offset.y) + "px";
            setPlaceholder(dragImageRef.current);
            moveEvent.preventDefault();
        };
        const onDragEnd = () => {
            var _a;
            if (dragImageRef.current) {
                dragImageRef.current.remove();
                dragImageRef.current = null;
            }
            if (dragMoveRef.current) {
                document.body.removeEventListener("pointermove", dragMoveRef.current, false);
            }
            const placeholderElement = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(".zen-list-item--placeholder");
            const endPosition = placeholderElement ? (0, findItemPosition_1.findItemPosition)(placeholderElement) : null;
            listItemElement.classList.remove("zen-list-item--dragging");
            if (containerRef.current) {
                removePlaceholders(containerRef.current);
            }
            dragMoveRef.current = undefined;
            cancelMoveScroll();
            if (endPosition !== null && startPosition !== endPosition) {
                onChangeOrder(startPosition, endPosition);
            }
            document.body.removeEventListener("pointerup", onDragEnd, false);
            document.removeEventListener("mouseleave", onDragEnd);
        };
        document.body.addEventListener("pointermove", dragMoveRef.current, false);
        document.body.addEventListener("pointerup", onDragEnd, false);
        document.addEventListener("mouseleave", onDragEnd);
        listItemElement.classList.add("zen-list-item--dragging");
        setPlaceholder(dragImageRef.current);
        const scrollableParent = (0, getScrollableParent_1.getScrollableParent)(containerRef.current);
        moveScroll((scrollableParent || containerRef.current), dragImageRef.current, () => setPlaceholder(dragImageRef.current));
    }, [cancelMoveScroll, containerRef, moveScroll, onChangeOrder, removePlaceholders, setPlaceholder]);
    return { onDragStart };
};
exports.useDragAndDrop = useDragAndDrop;
