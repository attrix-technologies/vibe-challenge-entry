"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chart = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const auto_1 = require("chart.js/auto");
const utils_1 = require("./utils");
const ChartComponent = function (props, ref) {
    const _a = props, { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode } = _a, canvasProps = __rest(_a, ["height", "width", "redraw", "datasetIdKey", "type", "data", "options", "plugins", "fallbackContent", "updateMode"]);
    const canvasRef = (0, react_1.useRef)(null);
    const chartRef = (0, react_1.useRef)();
    const renderChart = (0, react_1.useCallback)(() => {
        if (!canvasRef.current) {
            return;
        }
        chartRef.current = new auto_1.Chart(canvasRef.current, {
            type,
            data: (0, utils_1.cloneData)(data, datasetIdKey),
            options: options && Object.assign({}, options),
            plugins
        });
        (0, utils_1.reforwardRef)(ref, chartRef.current);
    }, [data, datasetIdKey, options, plugins, ref, type]);
    const destroyChart = (0, react_1.useCallback)(() => {
        (0, utils_1.reforwardRef)(ref, null);
        if (chartRef.current) {
            chartRef.current.destroy();
            chartRef.current = null;
        }
    }, [ref]);
    (0, react_1.useEffect)(() => {
        if (!redraw && chartRef.current && options) {
            (0, utils_1.setOptions)(chartRef.current, options);
        }
    }, [redraw, options]);
    (0, react_1.useEffect)(() => {
        if (!redraw && chartRef.current) {
            (0, utils_1.setLabels)(chartRef.current.config.data, data.labels);
        }
    }, [redraw, data.labels]);
    (0, react_1.useEffect)(() => {
        if (!redraw && chartRef.current) {
            (0, utils_1.setDatasets)(chartRef.current.config.data, data.datasets, datasetIdKey);
        }
    }, [redraw, data.datasets, datasetIdKey]);
    (0, react_1.useEffect)(() => {
        if (!chartRef.current) {
            return;
        }
        if (redraw) {
            destroyChart();
            setTimeout(renderChart);
        }
        else {
            chartRef.current.update(updateMode);
        }
    }, [redraw, options, data.labels, data.datasets, updateMode, destroyChart, renderChart]);
    (0, react_1.useEffect)(() => {
        if (!chartRef.current) {
            return;
        }
        destroyChart();
        setTimeout(renderChart);
    }, [destroyChart, renderChart, type]);
    (0, react_1.useEffect)(() => {
        renderChart();
        return () => destroyChart();
    }, [destroyChart, renderChart]);
    return ((0, jsx_runtime_1.jsx)("div", { style: { position: "relative", width: "100%", height: "100%" }, children: (0, jsx_runtime_1.jsx)("canvas", Object.assign({ ref: canvasRef, role: "img", height: height, width: width }, canvasProps, { children: fallbackContent })) }));
};
exports.Chart = (0, react_1.forwardRef)(ChartComponent);
