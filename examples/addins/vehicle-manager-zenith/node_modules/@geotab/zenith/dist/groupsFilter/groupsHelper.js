"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareFilters = exports.toFilterState = exports.simplifyFilterState = exports.mergeItems = exports.getId = exports.mapFilterState = exports.isFilterState = exports.isEntireOrganization = exports.isIdEntity = exports.createLinkedTree = exports.getGroupDescription = exports.isSystemGroup = exports.makeBoolHash = exports.allSystemGroups = exports.defaultPrivateGroupId = exports.rootDefectGroups = exports.rootGroups = exports.rootSecurityGroups = exports.systemSecurityGroups = exports.getDefaultFilterState = exports.DEFAULT_RELATION_OPERATOR = exports.ENTIRE_ORGANIZATION_GROUP_ID = void 0;
const groupsFilterInterfaces_1 = require("./groupsFilterInterfaces");
exports.ENTIRE_ORGANIZATION_GROUP_ID = "GroupCompanyId";
exports.DEFAULT_RELATION_OPERATOR = groupsFilterInterfaces_1.RelationOperator.OR;
const getDefaultFilterState = () => ({
    relation: exports.DEFAULT_RELATION_OPERATOR,
    items: [{ id: exports.ENTIRE_ORGANIZATION_GROUP_ID }]
});
exports.getDefaultFilterState = getDefaultFilterState;
const systemGroups = [
    "GroupCompanyId",
    "GroupDriverActivityGroupId",
    "GroupBusinessGroupId",
    "GroupPersonalGroupId",
    "GroupAssetInformationId",
    "GroupAssetTypeId",
    "GroupVehicleId",
    "GroupTrailerId",
    "GroupPowertrainAndFuelTypeId",
    "GroupInternalCombustionEngineId",
    "GroupGasolinePetrolId",
    "GroupDieselId",
    "GroupEthanolId",
    "GroupBiodieselId",
    "GroupCompressedNaturalGasId",
    "GroupOtherFuelId",
    "GroupPropaneLiquifiedPetroleumGasId",
    "GroupElectricHybridPluginId",
    "GroupBatteryElectricVehicleId",
    "GroupPluginHybridElectricVehicleId",
    "GroupManuallyClassifiedPowertrainId",
    "GroupFuelCellElectricVehicleId"
];
exports.systemSecurityGroups = [
    "GroupEverythingSecurityId",
    "GroupSupervisorSecurityId",
    "GroupUserSecurityId",
    "GroupViewOnlySecurityId",
    "GroupDriveUserSecurityId",
    "GroupViewMapOnlySecurityId",
    "GroupNothingSecurityId"
];
exports.rootSecurityGroups = [
    "GroupSecurityId"
];
exports.rootGroups = [
    "GroupRootId"
];
exports.rootDefectGroups = [
    "GroupDefectsId"
];
exports.defaultPrivateGroupId = "GroupPrivateUserId";
exports.allSystemGroups = [
    ...systemGroups,
    ...exports.rootSecurityGroups,
    ...exports.rootGroups,
    ...exports.systemSecurityGroups,
    ...exports.rootDefectGroups,
    exports.defaultPrivateGroupId
];
function makeBoolHash(arr) {
    return (arr || []).reduce(function (result, item) {
        result[item.id || item] = true;
        return result;
    }, {});
}
exports.makeBoolHash = makeBoolHash;
const systemGroupIds = makeBoolHash(exports.allSystemGroups);
const isSystemGroup = (groupId) => !!(groupId && systemGroupIds[groupId]);
exports.isSystemGroup = isSystemGroup;
const getGroupDescription = function (group, translate) {
    if ((0, exports.isSystemGroup)(group === null || group === void 0 ? void 0 : group.id)) {
        return translate(group.id);
    }
    return (group === null || group === void 0 ? void 0 : group.name) || "";
};
exports.getGroupDescription = getGroupDescription;
function createLinkedTree(groups, customCreateNode) {
    const createNode = customCreateNode || ((g) => (Object.assign(Object.assign({}, g), { parent: undefined })));
    const nodeLookup = groups.reduce((hash, group) => {
        hash.set(group.id, createNode(group));
        return hash;
    }, new Map());
    const rGroups = groups.reduce((root, group) => {
        const node = nodeLookup.get(group.id);
        if (node) {
            node.children = (group.children || []).map(child => {
                const childNode = nodeLookup.get(child.id);
                if (childNode) {
                    childNode.parent = node;
                }
                const rootChild = root.get(child.id);
                if (rootChild) {
                    root.set(child.id, undefined);
                }
                return childNode;
            }).filter(c => c !== undefined);
            if (!node["parent"]) {
                root.set(node === null || node === void 0 ? void 0 : node.id, node);
            }
        }
        return root;
    }, new Map());
    for (const [key, value] of rGroups) {
        if (value === undefined) {
            rGroups.delete(key);
        }
    }
    return Array.from(rGroups.values());
}
exports.createLinkedTree = createLinkedTree;
const isIdEntity = (entity) => !!(entity && entity.id);
exports.isIdEntity = isIdEntity;
function isEntireOrganization(filter) {
    let items = filter;
    const isCompanyGroup = (entity) => {
        const id = (0, exports.isIdEntity)(entity) ? entity.id : entity;
        return id === exports.ENTIRE_ORGANIZATION_GROUP_ID;
    };
    const isFilterState = (entity) => entity.relation && Array.isArray(entity.items);
    // If filter is advanced but contains only one level then we can check level items
    if (isFilterState(filter) && (!filter.items.length || filter.items.every(item => !isFilterState(item)))) {
        items = filter.items || [];
        // If AND relation and all items are CompanyGroups then whole filer is entire organization
        if (filter.relation === groupsFilterInterfaces_1.RelationOperator.AND) {
            return items.every(isCompanyGroup);
        }
        // If OR then any item should be CompanyGroupsId
        return items.some(isCompanyGroup);
    }
    return items && Array.isArray(items) && (!items.length || items.some(isCompanyGroup));
}
exports.isEntireOrganization = isEntireOrganization;
const isFilterState = (item) => item && item.relation !== undefined;
exports.isFilterState = isFilterState;
const mapFilterState = (state, mapFunc) => {
    const processItem = (item) => (Object.assign(Object.assign({}, item), { items: item.items.map(childItem => (0, exports.isFilterState)(childItem)
            ? processItem(childItem)
            : mapFunc(childItem)) }));
    return processItem(state);
};
exports.mapFilterState = mapFilterState;
const getId = (entity) => (0, exports.isIdEntity)(entity) ? entity.id : entity;
exports.getId = getId;
const getSimpleItems = (entity) => entity.filter(e => !(0, exports.isFilterState)(e));
const mergeItems = (items) => {
    const firstItem = items[0] || [];
    let allIds = getSimpleItems(firstItem).map(exports.getId);
    return items.reduce((res, item) => {
        const advancedSubitems = item.filter(exports.isFilterState);
        const simpleSubitems = getSimpleItems(item);
        const uniqueSimpleSubitems = simpleSubitems.filter(subitem => allIds.indexOf((0, exports.getId)(subitem)) === -1);
        const uniqueSimpleIds = uniqueSimpleSubitems.map(exports.getId);
        allIds = allIds.concat(uniqueSimpleIds);
        return res.concat([...uniqueSimpleSubitems], [...advancedSubitems]);
    });
};
exports.mergeItems = mergeItems;
const simplifyFilterState = (state) => {
    const processItem = (item) => {
        let newItems = item.items.reduce((res, childItem) => {
            if ((0, exports.isFilterState)(childItem)) {
                const processedSubItem = processItem(childItem);
                const prevSubItem = res[res.length - 1];
                // If there is only one item into subitem then make it relation equal to intersection relation
                // (pretend like we move it on the upper level)
                const currentRelation = processedSubItem.items.length === 1 ? item.relation : processedSubItem.relation;
                // If subitem is the first then just put it into results without changes
                if (!prevSubItem || !(0, exports.isFilterState)(prevSubItem)) {
                    res.push(processedSubItem);
                    return res;
                }
                const prevRelation = prevSubItem.items.length === 1 ? item.relation : prevSubItem.relation;
                // If current and previous relations are equal to intersection relation then combine them into one condition
                if (currentRelation === prevRelation && currentRelation === item.relation) {
                    const isFilterStateForPrevSubItem = (0, exports.isFilterState)(prevSubItem.items[0]);
                    const proceccedForMerge = isFilterStateForPrevSubItem ? [{ relation: processedSubItem.relation, items: processedSubItem.items }] : processedSubItem.items;
                    res[res.length - 1] = Object.assign(Object.assign({}, res[res.length - 1]), { relation: item.relation, items: (0, exports.mergeItems)([prevSubItem.items, proceccedForMerge]) });
                    return res;
                }
            }
            res.push(childItem);
            return res;
        }, []);
        let newRelation = item.relation;
        if (newItems.length === 1 && (0, exports.isFilterState)(newItems[0])) {
            newRelation = newItems[0].relation;
            newItems = newItems[0].items;
        }
        return Object.assign(Object.assign({}, item), { relation: newRelation, items: newItems });
    };
    return processItem(state);
};
exports.simplifyFilterState = simplifyFilterState;
const toFilterState = (state) => {
    const toIdEntity = (entity) => typeof entity === "string" ? { id: entity } : entity;
    if ((0, exports.isFilterState)(state)) {
        return (0, exports.mapFilterState)(state, (item) => toIdEntity(item));
    }
    const isSimpleFilterItem = item => typeof item === "string" || (0, exports.isIdEntity)(item);
    if (Array.isArray(state) && state.length && state.every(isSimpleFilterItem)) {
        return Object.assign(Object.assign({}, (0, exports.getDefaultFilterState)()), { items: state.map((item) => toIdEntity(item)) });
    }
    return (0, exports.getDefaultFilterState)();
};
exports.toFilterState = toFilterState;
const compareAdvancedFilters = (filter1, filter2) => {
    const sortItemsFunc = (a, b) => {
        if (!(0, exports.isFilterState)(a) && !(0, exports.isFilterState)(b)) {
            return (0, exports.getId)(a) > (0, exports.getId)(b) ? -1 : 1;
        }
        return 0;
    };
    const processItems = (item1, item2) => {
        const relationMatch = item1.relation === item2.relation;
        if (!relationMatch) {
            return false;
        }
        const item1Children = [...item1.items];
        const item2Children = [...item2.items];
        if (!item1Children || !item2Children || item1Children.length !== item2Children.length) {
            return false;
        }
        item1Children.sort(sortItemsFunc);
        item2Children.sort(sortItemsFunc);
        const compareChildren = (itm1, itm2) => {
            if ((0, exports.isFilterState)(itm1) && (0, exports.isFilterState)(itm2)) {
                return processItems(itm1, itm2);
            }
            if (!(0, exports.isFilterState)(itm1) && !(0, exports.isFilterState)(itm2)) {
                return (0, exports.getId)(itm1) === (0, exports.getId)(itm2);
            }
            return false;
        };
        return item1Children.every((item1Child, i) => {
            const item2Child = item2Children[i];
            if (!item2Child) {
                return false;
            }
            return compareChildren(item1Child, item2Child);
        });
    };
    return processItems(filter1, filter2);
};
const compareFilters = (filter1, filter2) => {
    // Try to convert to standard filters because
    const filterA = (0, exports.simplifyFilterState)((0, exports.toFilterState)(filter1));
    const filterB = (0, exports.simplifyFilterState)((0, exports.toFilterState)(filter2));
    return compareAdvancedFilters(filterA, filterB);
};
exports.compareFilters = compareFilters;
