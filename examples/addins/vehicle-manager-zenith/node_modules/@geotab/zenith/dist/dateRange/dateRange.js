"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.DateRange = exports.parseLabel = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const textIconButton_1 = require("../textIconButton/textIconButton");
const button_1 = require("../button/button");
const iconCalendar_1 = require("../icons/iconCalendar");
const react_1 = require("react");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const buttonType_1 = require("../button/buttonType");
const useLanguage_1 = require("../utils/localization/useLanguage");
const userFormatContext_1 = require("../utils/userFormat/userFormatContext");
const dateRangeInner_1 = require("../dateRangeInner/dateRangeInner");
const useUniqueId_1 = require("../commonHelpers/useUniqueId");
const getRangeOption_1 = require("../filtersBar/components/filtersBarPeriodPicker/getRangeOption");
const formatDate_1 = require("../utils/formatDate");
const normalizeDates_1 = require("../filtersBar/components/filtersBarPeriodPicker/normalizeDates");
const controlledPopup_1 = require("../controlledPopup/controlledPopup");
const formFieldError_1 = require("../formFieldError/formFieldError");
const useMobile_1 = require("../commonHelpers/hooks/useMobile");
const mobileSheet_1 = require("../mobileSheet/mobileSheet");
const footerButtons_1 = require("../footerButtons/footerButtons");
const useDriveClassName_1 = require("../utils/theme/useDriveClassName");
const areMapsEqual_1 = require("./utils/areMapsEqual");
const iconChevronLeftSmall_1 = require("../icons/iconChevronLeftSmall");
const useDrive_1 = require("../utils/theme/useDrive");
const iconChevronRightSmall_1 = require("../icons/iconChevronRightSmall");
const chip_1 = require("../chip/chip");
const chipStatusProvider_1 = require("../chip/chipStatusProvider");
const parseLabel = (option, dateFormat, translate, toLacalFn) => {
    const localeFrom = toLacalFn(option.from);
    const localeTo = toLacalFn(option.to);
    if (localeFrom.getDate() === localeTo.getDate() &&
        localeFrom.getMonth() === localeTo.getMonth() &&
        localeFrom.getFullYear() === localeTo.getFullYear()) {
        return (0, formatDate_1.formatDate)(localeFrom, dateFormat, translate);
    }
    return `${(0, formatDate_1.formatDate)(localeFrom, dateFormat, translate)} - ${(0, formatDate_1.formatDate)(localeTo, dateFormat, translate)}`;
};
exports.parseLabel = parseLabel;
// eslint-disable-next-line complexity
const DateRange = ({ className, classNamePopup, defaultValue, value, onChange, options: optionsArg, type, id, disabled, dropDownTitle, hasApplyButton, disableFutureDates, disablePastDates, disableDatesBefore, triggerLabel, disableDatesAfter, withCalendar, lockStartDate, lockEndDate, timeSelect, error, allowUnsetValue = false, stepper = false, classNameWrapper, chip, chipId, chipName, chipIcon }) => {
    var _a;
    const { translate } = (0, useLanguage_1.useLanguage)();
    const isMobile = (0, useMobile_1.useMobile)();
    const isDrive = (0, useDrive_1.useDrive)();
    const chipStatus = (0, chipStatusProvider_1.useChipStatus)();
    const driveWrapperTriggerClassName = (0, useDriveClassName_1.useDriveClassName)("zen-date-range-wrapper");
    const drivePopupClassName = (0, useDriveClassName_1.useDriveClassName)("zen-date-range-popup");
    const driveWrapperPopupClassName = (0, useDriveClassName_1.useDriveClassName)("zen-date-range-popup-wrapper");
    const [showMobileCalendar, setShowMobileCalendar] = (0, react_1.useState)(false);
    const { dateFormat, toLocalDateTime, toReverseOffsetDateTime, weekStartsOnSunday } = (0, react_1.useContext)(userFormatContext_1.userFormatContext);
    const optionsMap = (0, react_1.useMemo)(() => (0, getRangeOption_1.getOptionsPeriodMap)(optionsArg, translate, toLocalDateTime, weekStartsOnSunday ? "Sunday" : "Monday", toReverseOffsetDateTime), [optionsArg, toLocalDateTime, toReverseOffsetDateTime, translate, weekStartsOnSunday]);
    const previousStepOption = (0, react_1.useRef)("");
    const [selectedRange, setSelectedRange] = (0, react_1.useState)((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value));
    const [renderContent, setRenderContent] = (0, react_1.useState)(false);
    const isCustomDateOption = (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) === dateRangeInner_1.CUSTOM_CALENDAR_ID;
    const [isOpen, setIsOpen] = (0, react_1.useState)(false);
    const prevIsOpenRef = (0, react_1.useRef)(false);
    const [customDate, setCustomDate] = (0, react_1.useState)((0, normalizeDates_1.normalizeDates)(value === null || value === void 0 ? void 0 : value.from.toISOString(), value === null || value === void 0 ? void 0 : value.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter));
    const isDefaultState = !defaultValue && !selectedRange
        || defaultValue && selectedRange && defaultValue.label === selectedRange.label && defaultValue.label !== dateRangeInner_1.CUSTOM_CALENDAR_ID
        || defaultValue && selectedRange && defaultValue.label === selectedRange.label && defaultValue.label === dateRangeInner_1.CUSTOM_CALENDAR_ID && customDate.from && customDate.to
            && new Date(customDate.from).toISOString() === defaultValue.from.toISOString() && new Date(customDate.to).toISOString() === defaultValue.to.toISOString();
    const triggerRef = (0, react_1.useRef)(null);
    const [prevSelection, setPrevSelection] = (0, react_1.useState)((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value));
    const componentId = (0, useUniqueId_1.useUniqueId)();
    const calendarLabel = translate(dateRangeInner_1.CUSTOM_CALENDAR_ID);
    const getCustomRange = (0, react_1.useCallback)(() => ({ from: (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.from) || new Date(), to: (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.to) || new Date() }), [prevSelection]);
    const options = (0, react_1.useMemo)(() => (0, getRangeOption_1.getRangeOptionsArray)(optionsArg, translate, toLocalDateTime, weekStartsOnSunday ? "Sunday" : "Monday", toReverseOffsetDateTime, withCalendar || false, prevSelection && prevSelection.label === dateRangeInner_1.CUSTOM_CALENDAR_ID, prevSelection ? getCustomRange : undefined), [optionsArg, translate, toLocalDateTime, weekStartsOnSunday, toReverseOffsetDateTime, withCalendar, prevSelection, getCustomRange]);
    const optionsMapRef = (0, react_1.useRef)(optionsMap);
    const isEqualMaps = (0, react_1.useMemo)(() => (0, areMapsEqual_1.areMapsEqual)(optionsMapRef.current, optionsMap), [optionsMap]);
    if (!isEqualMaps) {
        optionsMapRef.current = optionsMap;
    }
    const hasCustomOption = (0, react_1.useMemo)(() => options.find(option => option.id === dateRangeInner_1.CUSTOM_CALENDAR_ID) !== undefined, [options]);
    const title = (0, react_1.useMemo)(() => dropDownTitle || translate("Date range"), [dropDownTitle, translate]);
    const toggleVisibility = (0, react_1.useCallback)(() => setIsOpen(currentIsOpen => !currentIsOpen), []);
    const getButtonLabel = (0, react_1.useCallback)((rangeValue, titleText) => {
        if (!rangeValue) {
            return translate("Date range");
        }
        const val = rangeValue.label;
        const selection = options.find(option => option.id === val);
        if (selection && val !== dateRangeInner_1.CUSTOM_CALENDAR_ID) {
            return titleText ? `${translate("Date range filter:")} ${selection.label}` : selection.label;
        }
        return titleText ? `${translate("Date range filter:")} ${(0, exports.parseLabel)(rangeValue, dateFormat, translate, toLocalDateTime)}` : (0, exports.parseLabel)(rangeValue, dateFormat, translate, toLocalDateTime);
    }, [dateFormat, options, translate, toLocalDateTime]);
    (0, react_1.useEffect)(() => {
        const currentValue = (0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value);
        if ((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.label) !== (currentValue === null || currentValue === void 0 ? void 0 : currentValue.label) || ((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.from.getTime()) !== (currentValue === null || currentValue === void 0 ? void 0 : currentValue.from.getTime()) || (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.to.getTime()) !== (currentValue === null || currentValue === void 0 ? void 0 : currentValue.to.getTime()))) {
            setSelectedRange(currentValue);
            setPrevSelection(currentValue);
        }
    }, [optionsMap, prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.from, prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.label, prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.to, value]);
    const handleDateRangeSelection = (0, react_1.useCallback)((newVal) => {
        var _a, _b;
        const selection = options.find(option => option.id === newVal);
        newVal === dateRangeInner_1.CUSTOM_CALENDAR_ID && setShowMobileCalendar(true);
        if (selection && newVal !== dateRangeInner_1.CUSTOM_CALENDAR_ID && selection.getRange) {
            const range = selection.getRange();
            const normalizedDates = (0, normalizeDates_1.normalizeDates)(range.from.toISOString(), range.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
            const newRange = newVal === dateRangeInner_1.CUSTOM_CALENDAR_ID ?
                { from: new Date(normalizedDates.from), to: new Date(normalizedDates.to) }
                : range;
            setSelectedRange(Object.assign({ label: selection.id }, newRange));
            !hasApplyButton && setPrevSelection(Object.assign({ label: selection.id }, newRange));
            !hasApplyButton && onChange(Object.assign({ label: selection.id }, newRange));
            previousStepOption.current = "";
        }
        else {
            const startDateForNormalize = ((_a = selection === null || selection === void 0 ? void 0 : selection.getRange) === null || _a === void 0 ? void 0 : _a.call(selection)) && (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) !== newVal ? selection.getRange().from.toISOString() : value === null || value === void 0 ? void 0 : value.from.toISOString();
            const endDateForNormalize = ((_b = selection === null || selection === void 0 ? void 0 : selection.getRange) === null || _b === void 0 ? void 0 : _b.call(selection)) && (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) !== newVal ? selection.getRange().to.toISOString() : value === null || value === void 0 ? void 0 : value.to.toISOString();
            const normalizedDates = (0, normalizeDates_1.normalizeDates)(startDateForNormalize, endDateForNormalize, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
            const newRange = newVal === dateRangeInner_1.CUSTOM_CALENDAR_ID ?
                { from: new Date(normalizedDates.from), to: new Date(normalizedDates.to) }
                : undefined;
            const newValueFrom = (newRange === null || newRange === void 0 ? void 0 : newRange.from) || new Date();
            const newValueTo = (newRange === null || newRange === void 0 ? void 0 : newRange.to) || new Date();
            setSelectedRange({ label: newVal, from: newValueFrom, to: newValueTo });
            setCustomDate(normalizedDates);
            !hasApplyButton && onChange({ label: newVal, from: newValueFrom, to: newValueTo });
        }
        !hasApplyButton && newVal !== dateRangeInner_1.CUSTOM_CALENDAR_ID && setIsOpen(false);
    }, [options, hasApplyButton, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter, onChange, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, value === null || value === void 0 ? void 0 : value.from, value === null || value === void 0 ? void 0 : value.to]);
    const handleRangeSelection = (0, react_1.useCallback)(() => {
        if (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) {
            const newState = { label: selectedRange.label, from: new Date(customDate.from), to: new Date(customDate.to) };
            setPrevSelection(newState);
            onChange(newState);
            setSelectedRange(newState);
            setIsOpen(false);
        }
    }, [selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, customDate.from, customDate.to, onChange]);
    const handleApplyClick = (0, react_1.useCallback)(() => {
        setIsOpen(false);
        setShowMobileCalendar(false);
        if (isCustomDateOption) {
            handleRangeSelection();
            previousStepOption.current = "";
            return;
        }
        selectedRange && onChange(selectedRange);
        selectedRange && setPrevSelection(selectedRange);
    }, [handleRangeSelection, isCustomDateOption, onChange, selectedRange]);
    const handleCancelClick = (0, react_1.useCallback)(() => {
        hasApplyButton && prevSelection && handleDateRangeSelection(prevSelection.label);
        setCustomDate({ from: prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.from.toISOString(), to: prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.to.toISOString() });
        setIsOpen(!isOpen);
        setShowMobileCalendar(false);
    }, [handleDateRangeSelection, prevSelection, isOpen, hasApplyButton]);
    const handleClearClick = (0, react_1.useCallback)(() => {
        // @ts-expect-error: Let's ignore a compile error. if onChange is triggered, then either a value is passed to the function, or undefined can be passed because the interface is IDateRangeUnsetValue
        !hasApplyButton && (defaultValue || allowUnsetValue) && onChange(defaultValue);
        !hasApplyButton && setIsOpen(false);
        setSelectedRange(defaultValue);
        previousStepOption.current = "";
        (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.label) === dateRangeInner_1.CUSTOM_CALENDAR_ID && !allowUnsetValue && setCustomDate({ from: defaultValue.from.toISOString(), to: defaultValue.to.toISOString() });
        setShowMobileCalendar(false);
    }, [allowUnsetValue, defaultValue, hasApplyButton, onChange]);
    const handleMobileBackClick = (0, react_1.useCallback)(() => {
        setShowMobileCalendar(false);
    }, []);
    const handleStepperClick = (0, react_1.useCallback)((currentRange, isIncrease) => {
        let step = previousStepOption.current ? previousStepOption.current : (0, getRangeOption_1.getDateRangeAdjustedStep)(translate, currentRange.label);
        if (previousStepOption.current === "") {
            previousStepOption.current = step;
        }
        else if (previousStepOption.current !== getRangeOption_1.DEFAULT_STEP_OPTION) {
            step = previousStepOption.current;
        }
        const adjustFn = getRangeOption_1.dateRangeAdjustedFn[step];
        const newValue = adjustFn(currentRange, isIncrease, toLocalDateTime, toReverseOffsetDateTime);
        const labeledValue = (0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, newValue);
        labeledValue && onChange(labeledValue);
    }, [onChange, optionsMap, toLocalDateTime, toReverseOffsetDateTime, translate]);
    (0, react_1.useEffect)(() => {
        setCustomDate({ from: value === null || value === void 0 ? void 0 : value.from.toISOString(), to: value === null || value === void 0 ? void 0 : value.to.toISOString() });
        const currentValue = (0, getRangeOption_1.getSelectedRangeFromValue)(optionsMapRef.current, value);
        setPrevSelection(currentValue);
    }, [value, isEqualMaps]);
    const range = (0, react_1.useMemo)(() => ({ from: customDate.from, to: customDate.to }), [customDate.from, customDate.to]);
    const component = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(dateRangeInner_1.DateRangeInner, { id: id || componentId, options: options, onOptionSelect: handleDateRangeSelection, onCalendarSelect: hasCustomOption ? (val) => {
            setCustomDate({ from: lockStartDate || val.from, to: lockEndDate || (lockStartDate ? val.to || val.from : val.to) });
        } : undefined, selection: selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, range: range, timeSelect: timeSelect, disableFutureDates: disableFutureDates, disablePastDates: disablePastDates, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter, showMobileCalendar: isMobile ? showMobileCalendar : undefined, setShowMobileCalendar: isMobile ? setShowMobileCalendar : undefined }), [id, componentId, options, handleDateRangeSelection, hasCustomOption, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, range, timeSelect, disableFutureDates, disablePastDates,
        disableDatesBefore, disableDatesAfter, isMobile, showMobileCalendar, lockStartDate, lockEndDate]);
    const memoizedHandleClose = (0, react_1.useCallback)(() => {
        setIsOpen(false);
    }, [setIsOpen]);
    const onReadyForFocus = (0, react_1.useCallback)((isCurrentOpen) => {
        if (!isMobile) {
            return;
        }
        if (isCurrentOpen) {
            setRenderContent(true);
            return;
        }
        setRenderContent(false);
        prevIsOpenRef.current = isCurrentOpen;
    }, [isMobile]);
    const isValueNotChanged = (0, react_1.useMemo)(() => {
        if (!hasApplyButton) {
            return false;
        }
        if (!isCustomDateOption) {
            return (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) === (value === null || value === void 0 ? void 0 : value.label);
        }
        return selectedRange.label === (value === null || value === void 0 ? void 0 : value.label) && customDate.from === value.from.toISOString() && customDate.to === value.to.toISOString();
    }, [customDate.from, customDate.to, hasApplyButton, isCustomDateOption, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, value === null || value === void 0 ? void 0 : value.from, value === null || value === void 0 ? void 0 : value.label, value === null || value === void 0 ? void 0 : value.to]);
    const memoizedDesktopView = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(controlledPopup_1.ControlledPopup, { className: (0, classNames_1.classNames)(["zen-date-range-popup-wrapper", driveWrapperPopupClassName || ""]), ariaLabel: translate("Date range"), useTrapFocusWithTrigger: "on", role: "dialog", triggerRef: triggerRef, onOpenChange: setIsOpen, shouldHoldScroll: true, isOpen: isOpen, recalculateOnScroll: true, children: (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-date-range-popup", drivePopupClassName || "", classNamePopup !== null && classNamePopup !== void 0 ? classNamePopup : ""]), children: [(0, jsx_runtime_1.jsx)("div", { className: "zen-date-range-popup__header", children: title }), component, (0, jsx_runtime_1.jsxs)("div", { className: "zen-date-range-popup__footer", children: [(0, jsx_runtime_1.jsx)(button_1.Button, { className: "zen-date-range-popup__button-clear", type: buttonType_1.ButtonType.Tertiary, disabled: !!isDefaultState, onClick: handleClearClick, children: translate("Clear") }), (!isCustomDateOption && hasApplyButton) &&
                            (0, jsx_runtime_1.jsx)(button_1.Button, { className: "zen-date-range-popup__button-reset", type: buttonType_1.ButtonType.Secondary, onClick: handleCancelClick, children: translate("Cancel") }), (isCustomDateOption || hasApplyButton) && (0, jsx_runtime_1.jsx)(button_1.Button, { className: "zen-date-range-popup__button-apply", type: buttonType_1.ButtonType.Primary, disabled: (isCustomDateOption && (!customDate.from || !customDate.to)) || isValueNotChanged || !selectedRange, onClick: handleApplyClick, children: translate("Apply") })] })] }) }), [classNamePopup, component, customDate.from, customDate.to, drivePopupClassName, driveWrapperPopupClassName, handleApplyClick, handleCancelClick, handleClearClick, hasApplyButton, isCustomDateOption, isDefaultState, isOpen, isValueNotChanged, selectedRange, title, translate]);
    const notFocusedComponent = (0, react_1.useMemo)(() => !range.from && !range.to, [range.from, range.to]);
    const memoizedMobileFooter = (0, react_1.useMemo)(() => {
        const clearButton = (0, jsx_runtime_1.jsx)(button_1.Button, { type: buttonType_1.ButtonType.Tertiary, disabled: !!isDefaultState, onClick: handleClearClick, children: translate("Clear") });
        const cancelButton = hasApplyButton && !showMobileCalendar ? (0, jsx_runtime_1.jsx)(button_1.Button, { type: buttonType_1.ButtonType.Secondary, onClick: handleCancelClick, children: translate("Cancel") }) : null;
        const applyButton = showMobileCalendar || hasApplyButton ?
            (0, jsx_runtime_1.jsx)(button_1.Button, { type: buttonType_1.ButtonType.Primary, disabled: (isCustomDateOption && (!customDate.from || !customDate.to)) || isValueNotChanged || !selectedRange, onClick: handleApplyClick, children: translate("Apply") }) : null;
        return (0, jsx_runtime_1.jsxs)(footerButtons_1.FooterButtons, { children: [applyButton, cancelButton, clearButton] });
    }, [customDate.from, customDate.to, handleApplyClick, handleCancelClick, handleClearClick, hasApplyButton, isCustomDateOption, isDefaultState, isValueNotChanged, selectedRange,
        showMobileCalendar, translate]);
    const memoizedMobileView = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsxs)(mobileSheet_1.MobileSheet, { className: (0, classNames_1.classNames)(["zen-date-range-mobile-sheet", classNamePopup ? `${classNamePopup}--mobile-sheet` : ""]), label: translate("Date range"), triggerRef: triggerRef, isOpen: isOpen, onHidePanel: memoizedHandleClose, onCloseClick: memoizedHandleClose, useTrapFocusWithTrigger: notFocusedComponent ? false : true, isBackVisible: showMobileCalendar, onBackClick: handleMobileBackClick, onReadyForFocus: onReadyForFocus, children: [(0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Title, { children: showMobileCalendar ? calendarLabel : title }), (0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Content, { children: renderContent ? component : null }), (0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Footer, { children: memoizedMobileFooter })] }), [calendarLabel, classNamePopup, component, handleMobileBackClick, isOpen, memoizedHandleClose, memoizedMobileFooter, notFocusedComponent,
        onReadyForFocus, renderContent, showMobileCalendar, title, translate]);
    const checkIsRangeDisable = (0, react_1.useCallback)((isIncrease) => {
        if (!selectedRange) {
            return true;
        }
        const step = previousStepOption.current ? previousStepOption.current : (0, getRangeOption_1.getDateRangeAdjustedStep)(translate, selectedRange.label);
        const adjustFn = getRangeOption_1.dateRangeAdjustedFn[step];
        const newValue = adjustFn({ from: selectedRange.from, to: selectedRange.to }, isIncrease, toLocalDateTime, toReverseOffsetDateTime);
        const normalizeNewValue = (0, normalizeDates_1.normalizeDates)(newValue.from.toISOString(), newValue.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
        return newValue.from.getTime() !== new Date(normalizeNewValue.from).getTime() || newValue.to.getTime() !== new Date(normalizeNewValue.to).getTime();
    }, [disableDatesAfter, disableDatesBefore, disableFutureDates, disablePastDates, selectedRange, toLocalDateTime, toReverseOffsetDateTime, translate]);
    const increaseRange = (0, react_1.useCallback)(() => {
        selectedRange && handleStepperClick(selectedRange, true);
    }, [handleStepperClick, selectedRange]);
    const decreaseRange = (0, react_1.useCallback)(() => {
        selectedRange && handleStepperClick(selectedRange, false);
    }, [handleStepperClick, selectedRange]);
    (0, react_1.useEffect)(() => {
        if (!isMobile && !isOpen && prevIsOpenRef.current) {
            setTimeout(() => {
                var _a;
                (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 0);
        }
        prevIsOpenRef.current = isOpen;
    }, [isOpen, isMobile]);
    const buttonLabel = (0, react_1.useMemo)(() => triggerLabel && !stepper ? triggerLabel : getButtonLabel((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value)), [getButtonLabel, optionsMap, value, triggerLabel, stepper]);
    const buttonTitle = (0, react_1.useMemo)(() => triggerLabel && !stepper ? triggerLabel : getButtonLabel((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value), true), [getButtonLabel, optionsMap, value, triggerLabel, stepper]);
    const currentLabel = (_a = (0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, value)) === null || _a === void 0 ? void 0 : _a.label;
    const cssClass = (0, classNames_1.classNames)([
        "zen-date-range",
        error ? "zen-date-range--error" : "",
        className !== null && className !== void 0 ? className : "",
        stepper ? "zen-date-range--with-stepper" : "",
        stepper && currentLabel === dateRangeInner_1.CUSTOM_CALENDAR_ID && buttonLabel.length > 20 ? "zen-date-range--with-stepper-custom" : "",
        !defaultValue && !value || (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.label) === currentLabel || type && type !== buttonType_1.ButtonType.Secondary ? "" : "zen-date-range--active"
    ]);
    const popupTriggerComponent = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { htmlType: "button", title: buttonTitle, icon: iconCalendar_1.IconCalendar, iconPosition: textIconButton_1.ButtonIconPosition.Start, className: cssClass, type: type, disabled: disabled, onClick: toggleVisibility, ref: triggerRef, children: buttonLabel }), [cssClass, type, disabled, toggleVisibility, buttonLabel, buttonTitle]);
    const chipTriggerComponent = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(chip_1.Chip, { status: isDefaultState ? undefined : chipStatus || "active", isOpen: isOpen, disabled: disabled, onClick: toggleVisibility, onClose: isDefaultState ? undefined : handleClearClick, triggerRef: triggerRef, icon: chipIcon || iconCalendar_1.IconCalendar, id: chipId, children: isDefaultState ? chipName : buttonLabel }), [isDefaultState, chipStatus, isOpen, disabled, toggleVisibility, handleClearClick, chipIcon, chipId, chipName, buttonLabel]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [stepper ? (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-date-range-wrapper", driveWrapperTriggerClassName || "", classNameWrapper || ""]), children: [(0, jsx_runtime_1.jsx)("button", { type: "button", disabled: checkIsRangeDisable(false), onClick: decreaseRange, className: (0, classNames_1.classNames)(["zen-date-range__stepper", "zen-date-range__stepper--left"]), title: translate("Previous"), children: (0, jsx_runtime_1.jsx)(iconChevronLeftSmall_1.IconChevronLeftSmall, { size: isDrive ? "huge" : "large" }) }), popupTriggerComponent, (0, jsx_runtime_1.jsx)("button", { type: "button", disabled: checkIsRangeDisable(true), onClick: increaseRange, className: (0, classNames_1.classNames)(["zen-date-range__stepper", "zen-date-range__stepper--right"]), title: translate("Next"), children: (0, jsx_runtime_1.jsx)(iconChevronRightSmall_1.IconChevronRightSmall, { size: isDrive ? "huge" : "large" }) })] }) : (chip ? chipTriggerComponent : popupTriggerComponent), isMobile ? memoizedMobileView : memoizedDesktopView, (0, jsx_runtime_1.jsx)(formFieldError_1.FormFieldError, { error: error })] });
};
exports.DateRange = DateRange;
exports.TRANSLATIONS = [
    "Custom",
    "Date range",
    "Clear",
    "Cancel",
    "Apply",
    "Reset",
    "Today",
    "Next",
    "Previous",
    "Choose dates",
    "Date range not available",
    "Choose your date range",
    "Some of the dates you selected arenâ€™t available. Please try a different range.",
    "Please select the dates you want to view."
];
