"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.WaitingList = exports.EmptyList = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const waiting_1 = require("../waiting/waiting");
const comboList_1 = require("../comboList/comboList");
const searchListHelpers_1 = require("./searchListHelpers");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const useLanguage_1 = require("../utils/localization/useLanguage");
const EmptyList = ({ className }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    return (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-search-list zen-search-list__container zen-search-list__container--empty", className || ""]), children: translate("No data") });
};
exports.EmptyList = EmptyList;
const WaitingList = ({ className }) => (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-search-list zen-search-list__container zen-search-list__container--empty", className || ""]), children: (0, jsx_runtime_1.jsx)(waiting_1.Waiting, { isLoading: true, delay: Number.MAX_SAFE_INTEGER, hideOverlay: true }) });
exports.WaitingList = WaitingList;
const SearchSingleList = ({ onChange, listData, className, listId, parentRef, selected }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const [searchStack, setSearchStack] = (0, react_1.useState)([]);
    const [checkedItems, setNewCheckedItems] = (0, react_1.useState)(selected);
    const [hover, setHover] = (0, react_1.useState)("");
    const root = (0, react_1.useMemo)(() => ({
        id: "root",
        name: "root",
        children: listData
    }), [listData]);
    const getItemsWithChildrenToTree = (0, react_1.useCallback)(() => (0, searchListHelpers_1.getItemsWithChildren)(listData, [...selected]), [listData, selected]);
    const addParentLinksToTree = (0, react_1.useCallback)(() => {
        (0, searchListHelpers_1.addParentLinks)(listData, root);
    }, [listData, root]);
    const addAdditionalNavigationButton = (0, react_1.useCallback)(() => {
        listData.length && (0, searchListHelpers_1.addAdditionalNavigation)(listData, translate);
    }, [listData, translate]);
    (0, react_1.useLayoutEffect)(() => {
        addParentLinksToTree();
        addAdditionalNavigationButton();
        const ids = getItemsWithChildrenToTree();
        ids.length && setNewCheckedItems(prevValue => {
            const newSelection = new Set(prevValue);
            ids.forEach(id => newSelection.add(`${searchListHelpers_1.allInSuffix}${id}`));
            return newSelection;
        });
    }, [getItemsWithChildrenToTree, addAdditionalNavigationButton, addParentLinksToTree]);
    const [showingList, setShowingList] = (0, react_1.useState)(root.children);
    const onItemChange = (0, react_1.useCallback)((nodeId, state) => {
        var _a, _b;
        const node = (0, searchListHelpers_1.searchTree)(root, nodeId);
        if (nodeId.indexOf("allIn") !== -1) {
            const parentNode = (0, searchListHelpers_1.searchTree)(root, nodeId.split("allIn")[1]);
            const idsToUncheck = (0, searchListHelpers_1.getChildren)((parentNode === null || parentNode === void 0 ? void 0 : parentNode.children) || []);
            setNewCheckedItems(prevValue => {
                const result = new Set(prevValue);
                const action = state ? "add" : "delete";
                idsToUncheck.forEach(idToUncheck => {
                    result.delete(idToUncheck);
                });
                result[action](nodeId);
                result[action](nodeId.split("allIn")[1]);
                return result;
            });
            setHover(nodeId);
            onChange(nodeId.split("allIn")[1], idsToUncheck);
            return;
        }
        if (nodeId.indexOf("levelUp") !== -1) {
            setShowingList([...(((_b = (_a = searchStack[searchStack.length - 1]) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.children) || [])]);
            const newHistory = [...searchStack];
            newHistory.pop();
            setHover((newHistory[0] && newHistory[0].children) ? newHistory[0].children[0].id : root.children[0].id);
            setSearchStack(newHistory);
            return;
        }
        if (node && node.children) {
            setHover(node.children[0].id);
            setSearchStack([...searchStack, node]);
            setShowingList([...node.children]);
            return;
        }
        setNewCheckedItems(prevValue => {
            const result = new Set(prevValue);
            if (node) {
                (0, searchListHelpers_1.getParents)(node).forEach(id => {
                    result.delete(nodeId);
                    result.delete(`allIn${id}`);
                });
            }
            state ? result.add(nodeId) : result.delete(nodeId);
            return result;
        });
        setHover(nodeId);
        onChange(nodeId, node ? (0, searchListHelpers_1.getParents)(node) : undefined);
    }, [onChange, root, searchStack]);
    (0, react_1.useEffect)(() => {
        const reference = parentRef.current;
        const updateHover = (order) => {
            var _a;
            let updatedIndex = 0;
            let currentIndex = 0;
            showingList.forEach((el, index) => {
                if (el.id !== hover) {
                    return;
                }
                if (order === "next") {
                    updatedIndex = showingList[index + 1] ? index + 1 : 0;
                    currentIndex = showingList[index + 1] ? index : showingList.length - 1;
                }
                if (order === "previous") {
                    updatedIndex = showingList[index - 1] ? index - 1 : showingList.length - 1;
                    currentIndex = showingList[index - 1] ? index : 0;
                }
            });
            setHover((_a = showingList[updatedIndex]) === null || _a === void 0 ? void 0 : _a.id);
            setShowingList([...showingList].map((el, index) => {
                if (index === currentIndex) {
                    return Object.assign(Object.assign({}, el), { hover: false });
                }
                if (index === updatedIndex) {
                    return Object.assign(Object.assign({}, el), { hover: true });
                }
                return el;
            }));
        };
        const eventHandler = (e) => {
            var _a, _b;
            if (e.key === "ArrowDown") {
                if (!hover) {
                    setHover((_a = showingList[0]) === null || _a === void 0 ? void 0 : _a.id);
                    return;
                }
                updateHover("next");
            }
            if (e.key === "ArrowUp") {
                if (!hover) {
                    setHover((_b = showingList[0]) === null || _b === void 0 ? void 0 : _b.id);
                    return;
                }
                updateHover("previous");
            }
            if (e.key === "Enter") {
                onItemChange(hover, !checkedItems.has(hover));
            }
        };
        if (reference) {
            reference.addEventListener("keydown", eventHandler);
        }
        return () => {
            reference === null || reference === void 0 ? void 0 : reference.removeEventListener("keydown", eventHandler);
        };
    }, [parentRef, hover, showingList, onItemChange, root, checkedItems]);
    const path = searchStack.map(el => el.name).join("/") || translate("List");
    return (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-search-list zen-search-list__container", className || ""]), children: (0, jsx_runtime_1.jsx)(comboList_1.ComboList, { listId: listId, hoverId: hover, lastItemId: searchStack[searchStack.length - 1] ? searchStack[searchStack.length - 1].name : "", checkedItems: checkedItems, items: showingList, onChange: onItemChange, path: path }) });
};
exports.TRANSLATIONS = [
    ...searchListHelpers_1.TRANSLATIONS,
    "List",
    "No data"
];
exports.default = (0, react_1.memo)(SearchSingleList);
