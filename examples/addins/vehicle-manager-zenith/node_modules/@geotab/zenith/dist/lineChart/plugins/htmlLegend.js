"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.htmlLegendPlugin = exports.LEGEND_PLUGIN_ID = void 0;
const getOrCreateLegendList = (id, isDrive) => {
    const legendContainer = document.getElementById(id);
    let listContainer = legendContainer === null || legendContainer === void 0 ? void 0 : legendContainer.querySelector("ul");
    if (!listContainer) {
        listContainer = document.createElement("ul");
        listContainer.classList.add("zen-legend-list", "zen-legend-list--flexible");
        isDrive ? listContainer.classList.add("zen-legend-list--drive") : listContainer.classList.remove("zen-legend-list--drive");
        legendContainer === null || legendContainer === void 0 ? void 0 : legendContainer.appendChild(listContainer);
    }
    return listContainer;
};
const clearList = (containerId) => {
    const legendContainer = document.getElementById(containerId);
    const ul = legendContainer === null || legendContainer === void 0 ? void 0 : legendContainer.querySelector("ul");
    if (!ul) {
        return;
    }
    // Remove old legend items
    while (ul.firstChild) {
        ul.removeChild(ul.firstChild);
    }
};
exports.LEGEND_PLUGIN_ID = "htmlLegend";
const htmlLegendPlugin = () => ({
    id: exports.LEGEND_PLUGIN_ID,
    isDrive: false,
    afterUpdate(chart, _args, options) {
        var _a, _b, _c;
        const uls = {
            "default": getOrCreateLegendList(options.containerID, this.isDrive)
        };
        const renderers = {
            "default": options.renderer || (item => item.text)
        };
        (options.containers || []).forEach(container => {
            const ul = getOrCreateLegendList(container.containerID, this.isDrive);
            container.labels.forEach(label => {
                uls[label] = ul;
                renderers[label] = container.renderer || undefined;
            });
        });
        clearList(options.containerID);
        (options.containers || []).forEach(container => clearList(container.containerID));
        let items = [];
        // Reuse the built-in legendItems generator
        const generateLabelsFn = (_c = (_b = (_a = chart.options.plugins) === null || _a === void 0 ? void 0 : _a.legend) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.generateLabels;
        if (generateLabelsFn) {
            items = generateLabelsFn(chart);
        }
        items.forEach(item => {
            const li = document.createElement("li");
            li.classList.add("zen-legend-list__item");
            li.onclick = () => {
                if (item.datasetIndex !== undefined) {
                    chart.setDatasetVisibility(item.datasetIndex, !chart.isDatasetVisible(item.datasetIndex));
                }
                chart.update();
            };
            // Color box
            const boxSpan = document.createElement("span");
            boxSpan.classList.add("zen-legend-list__item-color");
            if (item.strokeStyle) {
                boxSpan.style.background = item.strokeStyle.toString();
            }
            // Text
            const textContainer = document.createElement("p");
            textContainer.classList.add("zen-legend-list__item-text");
            textContainer.style.textDecoration = item.hidden ? "line-through" : "";
            const renderer = renderers[item.text] || renderers.default;
            const dataset = chart.data.datasets[item.datasetIndex];
            textContainer.innerHTML = renderer(item, dataset);
            li.appendChild(boxSpan);
            li.appendChild(textContainer);
            (uls[item.text] || uls.default).appendChild(li);
        });
    }
});
exports.htmlLegendPlugin = htmlLegendPlugin;
