"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withSortableColumns = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const sortableColumnsStorage_1 = require("./sortableColumnsStorage");
const toBasicColumn_1 = require("../extensions/toBasicColumn");
const actionsColumn_1 = require("../columns/actionsColumn/actionsColumn");
const sortableColumnWrapper_1 = require("./columns/sortableColumnWrapper");
const columnSortDirection_1 = require("./columns/columnSortDirection");
// T - type of entity
// P - props of wrapped component
// eslint-disable-next-line @typescript-eslint/naming-convention
const withSortableColumns = (DataGridComponent) => (0, react_1.forwardRef)(
// eslint-disable-next-line @typescript-eslint/naming-convention
function InnerColumnsList(props, ref) {
    var _a, _b;
    const { columns, options, onSortChange } = props;
    const settingsStore = (0, react_1.useMemo)(() => { var _a, _b; return new sortableColumnsStorage_1.SortableColumnsStorage(((_a = options.columnsSettingsStorage) === null || _a === void 0 ? void 0 : _a.pageName) || "", (_b = options.columnsSettingsStorage) === null || _b === void 0 ? void 0 : _b.storage); }, [(_a = options.columnsSettingsStorage) === null || _a === void 0 ? void 0 : _a.pageName, (_b = options.columnsSettingsStorage) === null || _b === void 0 ? void 0 : _b.storage]);
    const allColumns = (0, react_1.useMemo)(() => columns.map(column => {
        var _a;
        return (Object.assign(Object.assign({}, (0, toBasicColumn_1.toBasicColumn)(Object.assign({}, column))), { isSortable: column.isSortable, initialSortDirection: (_a = column.meta) === null || _a === void 0 ? void 0 : _a.initialSortDirection }));
    }), [columns]);
    const sortSettings = (0, react_1.useMemo)(() => options.sortOptions || settingsStore.getItem(), [options.sortOptions, settingsStore]);
    const saveSettingsToTheStore = (0, react_1.useCallback)((newSettings) => 
    // not to block main thread this operation can be postponed
    new Promise((resolve, reject) => {
        setTimeout(() => {
            try {
                settingsStore.setItem(newSettings);
                resolve();
            }
            catch (e) {
                reject(e);
            }
        }, 0);
    }), [settingsStore]);
    const onSort = (0, react_1.useCallback)(async (newSortSettings) => {
        await saveSettingsToTheStore(newSortSettings);
        onSortChange(newSortSettings);
    }, [saveSettingsToTheStore, onSortChange]);
    const sortedColumns = (0, react_1.useMemo)(() => allColumns.map(column => {
        const wrappers = column.wrappers;
        const isSortable = column.isSortable !== false && !(column.columnComponent instanceof actionsColumn_1.ActionsColumn);
        const isSortedBy = isSortable && sortSettings.sortColumn === column.name;
        return (Object.assign(Object.assign({}, column), { wrappers: wrappers.some(w => w instanceof sortableColumnWrapper_1.SortableColumnWrapper) || !isSortable ? wrappers : [
                ...wrappers,
                new sortableColumnWrapper_1.SortableColumnWrapper(column.name, {
                    isSortedBy,
                    sortDirection: isSortedBy ? sortSettings.sortDirection : columnSortDirection_1.ColumnSortDirection.None,
                    initialSortDirection: column.initialSortDirection
                }, column.title, onSort)
            ] }));
    }), [allColumns, sortSettings, onSort]);
    return (0, jsx_runtime_1.jsx)(DataGridComponent, Object.assign({}, props, { columns: [...sortedColumns], ref: ref }), "grid");
});
exports.withSortableColumns = withSortableColumns;
exports.withSortableColumns.translations = [
    ...sortableColumnWrapper_1.SortableColumnWrapper.translations
];
