"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataGridRow = exports.MIN_CELL_WIDTH = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const classNames_1 = require("../../commonHelpers/classNames/classNames");
const cell_1 = require("../cell/cell");
exports.MIN_CELL_WIDTH = 100;
const getColumnWidth = (defaultWidth) => Math.floor(Math.max(defaultWidth, exports.MIN_CELL_WIDTH));
const Row = ({ id, entity, columns, visibleRows, flexibleColumnWidth, isLastRow, className, expanded, onExpandedChange, isTreeGrid, ariaPosinset, ariaSetsize }) => {
    const isVisible = visibleRows.has(entity.id);
    const listOfDefaultWidthColumns = (0, react_1.useMemo)(() => columns.map(column => column.meta.defaultWidth), [columns]);
    const getColWidth = (0, react_1.useCallback)((columnIndex, colspan) => {
        const colsp = colspan || 1;
        let columnWidth = 0;
        for (let i = 0; i < colsp; i++) {
            if (i >= listOfDefaultWidthColumns.length) {
                continue;
            }
            const defaultWidth = listOfDefaultWidthColumns[columnIndex + i];
            // If the column is the last one or doesn't have a default width, it should be limited to the remaining space
            const width = getColumnWidth(defaultWidth || flexibleColumnWidth);
            columnWidth += width;
        }
        return columnWidth;
    }, [flexibleColumnWidth, listOfDefaultWidthColumns]);
    const getCellParams = (0, react_1.useCallback)((columnIndex, colspan) => {
        const width = getColWidth(columnIndex, colspan);
        const defaultWidth = listOfDefaultWidthColumns[columnIndex];
        const limited = !!defaultWidth && defaultWidth > 0;
        const isFirst = columnIndex === 0;
        const isLast = columnIndex === listOfDefaultWidthColumns.length - 1;
        return { limited, isFirst, isLast, width };
    }, [getColWidth, listOfDefaultWidthColumns]);
    const mainRowId = (0, react_1.useId)();
    const renderCells = (0, react_1.useCallback)((rowEntity, isNested) => columns.reduce((acc, column, index) => {
        const colspanFn = column.colspan;
        let colspan = colspanFn
            ? typeof colspanFn === "function"
                ? colspanFn(rowEntity)
                : colspanFn
            : undefined;
        colspan = colspan && colspan > 1 ? colspan : undefined;
        const { limited, width } = getCellParams(index, colspan);
        if (acc.colspan > 0) {
            acc.colspan--;
            return acc;
        }
        if (colspan) {
            acc.colspan = colspan - 1;
        }
        const renderWrappers = (value, ent) => column.wrappers.reduce((result, wrapper) => wrapper.render(result, ent, isNested), value);
        const renderFn = isNested
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            ? (("renderNested" in column.columnComponent && column.columnComponent.renderNested !== undefined)
                ? column.columnComponent.renderNested.bind(column.columnComponent)
                : column.columnComponent.render.bind(column.columnComponent))
            : column.columnComponent.render.bind(column.columnComponent);
        acc.cells.push((0, jsx_runtime_1.jsx)(cell_1.DataGridCell, { render: (e) => renderFn(e, isNested), renderPlaceholder: column.meta.renderPlaceholder, renderWrappers: renderWrappers, defaultValue: column.meta.defaultValue, entity: rowEntity, index: index, limited: limited, visibleOnHover: column.meta.visibleOnHover, width: column.meta.visibleOnHover ? 0 : width, isVisible: isVisible, colspan: colspan, onClick: !isNested && onExpandedChange ? () => onExpandedChange(!expanded) : undefined, className: isNested ? "zen-data-grid__row-cell--nested" : "" }, `${rowEntity.id}_${column.name}`));
        return acc;
    }, { cells: [], colspan: 0 }).cells, [columns, expanded, getCellParams, isVisible, onExpandedChange]);
    const cells = (0, react_1.useMemo)(() => renderCells(entity, false), [entity, renderCells]);
    const nestedCells = (0, react_1.useMemo)(() => (expanded && entity.children ? entity.children : []).map((nestedEntity) => renderCells(nestedEntity, true)), [entity.children, expanded, renderCells]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("tr", { "data-row-id": id, id: mainRowId, role: "row", "aria-level": isTreeGrid ? 1 : undefined, "aria-posinset": isTreeGrid ? ariaPosinset : undefined, "aria-setsize": isTreeGrid ? ariaSetsize : undefined, "aria-expanded": isTreeGrid ? expanded : undefined, className: (0, classNames_1.classNames)([
                    "zen-data-grid__row",
                    className || "",
                    isLastRow ? "zen-data-grid__row--last" : ""
                ]), children: cells }, mainRowId), nestedCells.map((nestedRow, index) => ((0, jsx_runtime_1.jsx)("tr", { id: `${mainRowId}_child_${index}`, role: "row", "aria-level": 2, "aria-posinset": index + 1, "aria-setsize": nestedCells.length, className: "zen-data-grid__row zen-data-grid__row--nested", children: nestedRow }, `${mainRowId}_child_${index}`)))] });
};
exports.DataGridRow = (0, react_1.memo)(Row);
