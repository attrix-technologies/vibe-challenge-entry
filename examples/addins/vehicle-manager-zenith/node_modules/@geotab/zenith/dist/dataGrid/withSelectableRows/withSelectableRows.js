"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withSelectableRows = exports.getSelections = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const checkboxColumnWrapper_1 = require("../columns/checkboxColumn/checkboxColumnWrapper");
const controlledPopup_1 = require("../../controlledPopup/controlledPopup");
const selectList_1 = require("../../selectList/selectList");
const checkboxState_1 = require("../../checkbox/checkboxState");
const selectableRowsColumnWrapper_1 = require("./columns/selectableRowsColumnWrapper");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const selectionOptions = [{
        id: "all",
        value: checkboxColumnWrapper_1.SelectionState.All,
        element: "all",
        label: "Select all"
    }, {
        id: "page",
        value: checkboxColumnWrapper_1.SelectionState.CurrentPage,
        element: "page",
        label: "Select current page"
    }, {
        id: "none",
        value: checkboxColumnWrapper_1.SelectionState.None,
        element: "none",
        label: "Deselect all"
    }];
const getSelections = (selections) => {
    const res = new Set();
    if (selections !== undefined) {
        selections.selected.forEach(id => res.add(id));
    }
    return res;
};
exports.getSelections = getSelections;
const calculateSelectionState = (entities, selections, allSelected, options) => {
    if (selections.size === 0) {
        return allSelected ? checkboxColumnWrapper_1.SelectionState.All : checkboxColumnWrapper_1.SelectionState.None;
    }
    return entities.every(entity => {
        if (options.condition && !options.condition(entity)) {
            return true;
        }
        if (options.checkboxVisible && !options.checkboxVisible(entity)) {
            return true;
        }
        if (options.checkboxDisabled && options.checkboxDisabled(entity)) {
            return true;
        }
        return selections.has(entity.id);
    }) ? checkboxColumnWrapper_1.SelectionState.CurrentPage : checkboxColumnWrapper_1.SelectionState.Partial;
};
// T - type of entity
// P - props of wrapped component
// eslint-disable-next-line @typescript-eslint/naming-convention
const withSelectableRows = (DataGridComponent) => (0, react_1.forwardRef)(
// eslint-disable-next-line @typescript-eslint/naming-convention
function InnerList(props, ref) {
    const { selectMode, selection, columns, entities, options, onSelect, translate: _1 } = props;
    const { translate } = (0, useLanguage_1.useLanguage)();
    const [isOpen, setIsOpen] = (0, react_1.useState)(false);
    const selectId = (0, react_1.useId)();
    const selectMenuRef = (0, react_1.useRef)(null);
    const selections = (0, exports.getSelections)(selection);
    const allSelected = selection !== undefined && selection.allSelected;
    const wrapper = (0, react_1.useMemo)(() => selectMode ? new selectableRowsColumnWrapper_1.SelectableRowsColumnWrapper(selections, {
        createTitle: options.createTitle,
        headerTitle: options.headerTitle,
        condition: options.condition || options.checkboxVisible,
        disabled: options.checkboxDisabled
            ? options.checkboxDisabled
            : (entity) => options.selectionLimit !== undefined
                ? (!selections.has(entity.id) && selections.size >= options.selectionLimit)
                : false,
        header: (options.selectionLimit === undefined
            && options.checkboxDisabled === undefined
            && options.checkboxVisible === undefined
            && options.condition === undefined) || (options.checkboxInHeader === true && !options.selectionLimit)
    }, selectMenuRef) : null, [
        selectMode,
        selections,
        options.createTitle,
        options.headerTitle,
        options.condition,
        options.checkboxVisible,
        options.checkboxDisabled,
        options.selectionLimit,
        options.checkboxInHeader
    ]);
    if (wrapper) {
        wrapper.selectionState = calculateSelectionState(entities, selections, allSelected, options);
    }
    const selectAll = (0, react_1.useCallback)((checked) => {
        const newSelections = new Set(selections);
        entities.forEach(entity => {
            if (checked) {
                const isVisible = options.condition
                    ? options.condition(entity)
                    : options.checkboxVisible
                        ? options.checkboxVisible(entity)
                        : true;
                const isEnabled = !options.checkboxDisabled || !options.checkboxDisabled(entity);
                if (isVisible && isEnabled) {
                    newSelections.add(entity.id);
                }
                return;
            }
            newSelections.delete(entity.id);
        });
        const newState = calculateSelectionState(entities, newSelections, false, options);
        onSelect({
            selected: [...newSelections],
            allSelected: newState === checkboxColumnWrapper_1.SelectionState.All,
            turnOffSelectAll: selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll
        });
    }, [selections, entities, options, onSelect, selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll]);
    const onSelectListener = (0, react_1.useCallback)(([id, checked]) => {
        if (allSelected) {
            const newSelection = new Set(entities.map(entity => entity.id));
            newSelection.delete(id);
            onSelect({
                selected: [...newSelection],
                allSelected: false,
                turnOffSelectAll: selection.turnOffSelectAll
            });
            return;
        }
        if (checked) {
            selections.add(id);
        }
        else {
            selections.delete(id);
        }
        const newState = calculateSelectionState(entities, selections, allSelected, options);
        onSelect({
            selected: [...selections],
            allSelected: newState === checkboxColumnWrapper_1.SelectionState.All,
            turnOffSelectAll: selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll
        });
    }, [entities, selections, allSelected, options, onSelect, selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll]);
    const onSelectAll = (0, react_1.useCallback)(([checked]) => {
        if (checked && ((selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll) || options.turnOffSelectAll)) {
            selectAll(true);
            return;
        }
        onSelect({
            selected: [],
            allSelected: checked,
            turnOffSelectAll: selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll
        });
    }, [onSelect, selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll, options.turnOffSelectAll, selectAll]);
    const onTriggerClick = (0, react_1.useCallback)(() => {
        setIsOpen(!isOpen);
    }, [isOpen]);
    const onSelectMenuChange = (0, react_1.useCallback)((state) => {
        var _a, _b;
        const selectedId = (_a = [...state].find(([_, v]) => v === checkboxState_1.CheckboxState.On)) === null || _a === void 0 ? void 0 : _a[0];
        const value = selectedId && ((_b = selectionOptions.find(o => o.id === selectedId)) === null || _b === void 0 ? void 0 : _b.value);
        if (value === undefined) {
            return;
        }
        setIsOpen(false);
        if (value === checkboxColumnWrapper_1.SelectionState.All) {
            onSelect({
                selected: [],
                allSelected: true,
                turnOffSelectAll: selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll
            });
            return;
        }
        if (value === checkboxColumnWrapper_1.SelectionState.None) {
            onSelect({
                selected: [],
                allSelected: false,
                turnOffSelectAll: selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll
            });
            return;
        }
        selectAll(true);
    }, [onSelect, selectAll, selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll]);
    (0, react_1.useEffect)(() => {
        if (!wrapper) {
            return () => { };
        }
        wrapper.detach();
        wrapper.attach("change", onSelectListener);
        wrapper.attach("change-all", onSelectAll);
        wrapper.attach("toggle", onTriggerClick);
        return () => {
            wrapper.detach();
        };
    }, [wrapper, onSelectListener, onSelectAll, onTriggerClick]);
    const listColumns = (0, react_1.useMemo)(() => {
        const newColumns = columns.map(c => (Object.assign({}, c)));
        // Remove CheckboxColumnWrappers from wrappers list
        newColumns.forEach(c => {
            if (c.wrappers) {
                c.wrappers = c.wrappers.filter(w => !(w instanceof selectableRowsColumnWrapper_1.SelectableRowsColumnWrapper));
            }
        });
        // Add new CheckboxColumnWrapper to wrappers list of the first column
        const firstColumn = newColumns.find(c => c.id === options.firstColumnId);
        if (firstColumn && wrapper) {
            firstColumn.wrappers = [...firstColumn.wrappers || [], wrapper];
        }
        return newColumns;
    }, [columns, options.firstColumnId, wrapper]);
    const listItems = (0, react_1.useMemo)(() => selectionOptions
        .filter(option => (!(selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll) && !options.turnOffSelectAll) || option.value !== checkboxColumnWrapper_1.SelectionState.All)
        .map(option => ({
        id: option.id,
        value: option.value,
        label: translate(option.label),
        children: translate(option.label)
    })).filter(option => option.value !== calculateSelectionState(entities, selections, allSelected, options)), [selection === null || selection === void 0 ? void 0 : selection.turnOffSelectAll, translate, entities, selections, allSelected, options]);
    const listValue = (0, react_1.useMemo)(() => listItems.reduce((res, item) => {
        res.set(item.id, checkboxState_1.CheckboxState.Off);
        return res;
    }, new Map()), [listItems]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [columns.length > 0
                ? (0, jsx_runtime_1.jsx)(controlledPopup_1.ControlledPopup, { triggerRef: selectMenuRef, isOpen: isOpen, onOpenChange: setIsOpen, alignment: "bottom-left", children: (0, jsx_runtime_1.jsx)(selectList_1.SelectList, { id: selectId, title: translate("Select menu"), items: listItems, value: listValue, selectItemOnFocus: false, onChange: onSelectMenuChange }) })
                : null, (0, jsx_runtime_1.jsx)(DataGridComponent, Object.assign({}, props, { columns: listColumns, ref: ref }))] });
});
exports.withSelectableRows = withSelectableRows;
exports.withSelectableRows.translations = [
    "Select menu",
    "Select all",
    "Select current page",
    "Deselect all",
    ...checkboxColumnWrapper_1.CheckboxColumnWrapper.translations
];
