"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFlexibleColumns = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const flexibleColumnsStorage_1 = require("./flexibleColumnsStorage");
const flexibleColumnsResizer_1 = require("./flexibleColumnsResizer");
const flexibleColumnsReorder_1 = require("./flexibleColumnsReorder");
const toBasicColumn_1 = require("../extensions/toBasicColumn");
const popup_1 = require("../../popup/popup");
const actionsColumn_1 = require("../columns/actionsColumn/actionsColumn");
const flexibleColumnWrapper_1 = require("./columns/flexibleColumnWrapper");
const columnSettings_1 = require("./components/columnSettings");
const columnSettingsList_1 = require("./components/columnSettingsList");
const columnSettingsSidePanel_1 = require("./components/columnSettingsSidePanel");
// T - type of entity
// P - props of wrapped component
// eslint-disable-next-line @typescript-eslint/naming-convention
const withFlexibleColumns = (DataGridComponent) => (0, react_1.forwardRef)(
// eslint-disable-next-line @typescript-eslint/naming-convention
function InnerFlColumnsList(props, ref) {
    var _a, _b;
    const { columns, options, popupTriggerRef, onChangeSettings, onResetSettings = () => { }, sortGroups, sortColumns } = props;
    const settingsStore = (0, react_1.useMemo)(() => { var _a, _b; return new flexibleColumnsStorage_1.ColumnsSettingsStorage(((_a = options.columnsSettingsStorage) === null || _a === void 0 ? void 0 : _a.pageName) || "", (_b = options.columnsSettingsStorage) === null || _b === void 0 ? void 0 : _b.storage); }, [(_a = options.columnsSettingsStorage) === null || _a === void 0 ? void 0 : _a.pageName, (_b = options.columnsSettingsStorage) === null || _b === void 0 ? void 0 : _b.storage]);
    const [isPanelOpen, setIsPanelOpen] = (0, react_1.useState)(false);
    const allColumns = (0, react_1.useMemo)(() => columns.map(column => (Object.assign(Object.assign({}, (0, toBasicColumn_1.toBasicColumn)(Object.assign({}, column))), { visible: column.visible !== false, group: column.group || "" }))), [columns]);
    const columnsSettings = (0, react_1.useMemo)(() => (0, flexibleColumnsStorage_1.mergeColumnsSettings)(allColumns, options.columnsSettings || settingsStore.getItem()), [allColumns, options.columnsSettings, settingsStore]);
    const visibleColumns = (0, react_1.useMemo)(() => {
        const visibleColumnsMap = new Map(allColumns.map(c => [c.name, c]));
        return columnsSettings.map((s, index) => {
            const column = visibleColumnsMap.get(s.name);
            if (column === undefined || !s.visible) {
                return undefined;
            }
            const wrappers = column.wrappers;
            return (Object.assign(Object.assign({}, column), { meta: Object.assign(Object.assign({}, column.meta), { defaultWidth: s.width }), wrappers: wrappers.some(w => w instanceof flexibleColumnWrapper_1.FlexibleColumnWrapper) ? wrappers : [
                    ...wrappers,
                    new flexibleColumnWrapper_1.FlexibleColumnWrapper({
                        draggable: !(column.columnComponent instanceof actionsColumn_1.ActionsColumn),
                        resizable: index !== 0
                    })
                ] }));
        }).filter(c => c !== undefined);
    }, [allColumns, columnsSettings]);
    const gridRef = (0, react_1.useRef)(null);
    const resizerRef = (0, react_1.useRef)();
    const reordererRef = (0, react_1.useRef)();
    (0, react_1.useImperativeHandle)(ref, () => gridRef.current, []);
    const saveSettingsToTheStore = (0, react_1.useCallback)((newSettings) => 
    // not to block main thread this operation can be postponed
    new Promise((resolve, reject) => {
        setTimeout(() => {
            try {
                settingsStore.setItem(newSettings);
                resolve();
            }
            catch (e) {
                reject(e);
            }
        }, 0);
    }), [settingsStore]);
    const listOfColumns = (0, react_1.useMemo)(() => {
        var _a;
        const firstColumn = (((_a = visibleColumns[0]) === null || _a === void 0 ? void 0 : _a.name) || "");
        const columnSettingsMap = new Map(columnsSettings.map(s => [s.name, s.visible]));
        return (0, jsx_runtime_1.jsx)(columnSettingsList_1.ColumnSettingsList, { columns: allColumns.filter(c => c.title), settings: columnSettingsMap, firstColumn: firstColumn, onChange: async (newSettings) => {
                const settings = (columnsSettings.map(s => {
                    const visible = newSettings.get(s.name) !== false;
                    return Object.assign(Object.assign({}, s), { visible });
                }));
                await saveSettingsToTheStore(settings);
                onChangeSettings(settings);
            }, sortGroups: sortGroups, sortColumns: sortColumns });
    }, [columnsSettings, allColumns, saveSettingsToTheStore, onChangeSettings, visibleColumns, sortGroups, sortColumns]);
    const onReorderListener = (0, react_1.useCallback)(async ([from, to]) => {
        if (from === to) {
            return;
        }
        const column = visibleColumns[from];
        // we should avoid moving actions column
        const limitedTo = Math.min(to, visibleColumns.length - 1);
        const where = visibleColumns[limitedTo];
        if (column === undefined) {
            return;
        }
        // update order in settings
        const settingsWithoutColumn = columnsSettings.filter(s => s.name !== column.name);
        const originalSettings = columnsSettings.filter(s => s.name === column.name)[0];
        const sIndex = settingsWithoutColumn.findIndex(s => s.name === where.name);
        const newColumnSettings = [
            ...settingsWithoutColumn.slice(0, sIndex),
            originalSettings,
            ...settingsWithoutColumn.slice(sIndex)
        ];
        await saveSettingsToTheStore(newColumnSettings);
        onChangeSettings(newColumnSettings);
    }, [columnsSettings, visibleColumns, onChangeSettings, saveSettingsToTheStore]);
    const onResizeColumn = (0, react_1.useCallback)(async ([index, width]) => {
        const column = visibleColumns[index];
        if (column === undefined) {
            return;
        }
        const newColumnSettings = columnsSettings.map(s => {
            if (s.name === column.name) {
                return Object.assign(Object.assign({}, s), { width });
            }
            return s;
        });
        await saveSettingsToTheStore(newColumnSettings);
        onChangeSettings(newColumnSettings);
    }, [columnsSettings, visibleColumns, onChangeSettings, saveSettingsToTheStore]);
    (0, react_1.useEffect)(() => {
        if (!gridRef.current) {
            return;
        }
        // resizer
        if (!resizerRef.current) {
            const resizer = new flexibleColumnsResizer_1.FlexibleColumnResizer(gridRef.current);
            resizerRef.current = resizer;
        }
        resizerRef.current.detach("resize");
        resizerRef.current.attach("resize", onResizeColumn);
        resizerRef.current.add(visibleColumns);
        // reorder
        if (!reordererRef.current) {
            const reorder = new flexibleColumnsReorder_1.FlexibleColumnReorder(gridRef.current, resizerRef.current, () => true);
            reordererRef.current = reorder;
        }
        reordererRef.current.detach("reorder");
        reordererRef.current.attach("reorder", onReorderListener);
        reordererRef.current.add();
    }, [columnsSettings, visibleColumns, onResizeColumn, onReorderListener]);
    const onResetListener = (0, react_1.useCallback)(async () => {
        await saveSettingsToTheStore([]);
        onResetSettings();
        setIsPanelOpen(false);
    }, [onResetSettings, saveSettingsToTheStore]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [popupTriggerRef && visibleColumns.length > 0
                ? options.isFeed
                    ? (0, jsx_runtime_1.jsx)(columnSettingsSidePanel_1.ColumnSettingsSidePanel, { triggerRef: popupTriggerRef, isOpen: isPanelOpen, onOpen: () => setIsPanelOpen(true), onClose: () => setIsPanelOpen(false), onReset: onResetListener, children: (0, jsx_runtime_1.jsx)(columnSettings_1.ColumnSettings, { onReset: onResetListener, showFooter: false, children: listOfColumns }) })
                    : (0, jsx_runtime_1.jsx)(popup_1.Popup, { triggerRef: popupTriggerRef, alignment: "bottom-right", children: (0, jsx_runtime_1.jsx)(columnSettings_1.ColumnSettings, { onReset: onResetListener, children: listOfColumns }) }, "flexible-popup")
                : null, (0, jsx_runtime_1.jsx)(DataGridComponent, Object.assign({}, props, { columns: [...visibleColumns], ref: gridRef }), "grid")] });
});
exports.withFlexibleColumns = withFlexibleColumns;
exports.withFlexibleColumns.translations = [
    ...columnSettings_1.ColumnSettings.translations,
    ...columnSettingsSidePanel_1.ColumnSettingsSidePanel.translations
];
