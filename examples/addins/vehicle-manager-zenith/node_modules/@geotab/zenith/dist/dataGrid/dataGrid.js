"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.DataGrid = exports.Footer = exports.EmptyList = exports.MIN_CELL_WIDTH = exports.VERTICAL_SCROLL_MODIFIER = exports.HORIZONTAL_SCROLL_MODIFIER = exports.DRAGGING_MODIFIER = exports.NOT_INTERACTIVE_MODIFIER = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const row_1 = require("./row/row");
const headerCell_1 = require("./headerCell/headerCell");
const findVisible_1 = require("./extensions/findVisible");
const toBasicColumn_1 = require("./extensions/toBasicColumn");
const useResize_1 = require("../commonHelpers/hooks/useResize");
const useResizeObserver_1 = require("../commonHelpers/hooks/useResizeObserver");
const useLanguage_1 = require("../utils/localization/useLanguage");
const getRowClassName_1 = require("./getRowClassName");
exports.NOT_INTERACTIVE_MODIFIER = "zen-data-grid--not-interactive";
exports.DRAGGING_MODIFIER = "zen-data-grid--dragging";
exports.HORIZONTAL_SCROLL_MODIFIER = "zen-data-grid--horizontal-scroll";
exports.VERTICAL_SCROLL_MODIFIER = "zen-data-grid--vertical-scroll";
exports.MIN_CELL_WIDTH = 100;
const renderHeaderWrappers = (wrappers, value) => wrappers.reduce((result, wrapper) => wrapper.renderHeader(result), value);
const getColumnWidth = (defaultWidth) => Math.floor(Math.max(defaultWidth, exports.MIN_CELL_WIDTH));
const EmptyList = ({ children }) => (0, jsx_runtime_1.jsx)("div", { className: "zen-data-grid__empty", children: children });
exports.EmptyList = EmptyList;
const Footer = ({ children }) => (0, jsx_runtime_1.jsx)("div", { className: "zen-data-grid__footer", children: children });
exports.Footer = Footer;
const FIRST_RENDERED_ROWS = 100;
const DataGridInner = ({ entities, columns, className = "", description, emptyCellTitle, children, rowClassName, expandedRows, onExpandedChange }, ref) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const emptyCellTitleValue = emptyCellTitle || translate("Action");
    // States
    const columnsList = (0, react_1.useMemo)(() => columns.map(toBasicColumn_1.toBasicColumn), [columns]);
    const initialVisibleRows = (0, react_1.useMemo)(() => entities.slice(0, FIRST_RENDERED_ROWS).map(r => r.id), [entities]);
    const [visibleRows, setVisibleRows] = (0, react_1.useState)(new Set(initialVisibleRows));
    const [horizontalScrollApplied, setHorizontalScrollApplied] = (0, react_1.useState)(false);
    const [verticalScrollApplied, setVerticalScrollApplied] = (0, react_1.useState)(false);
    // Refs
    const gridRef = (0, react_1.useRef)(null);
    const bodyRef = (0, react_1.useRef)(null);
    const lazyRenderTimerRef = (0, react_1.useRef)(0);
    const rowsMap = (0, react_1.useMemo)(() => new Map(entities.map(entity => [entity.id, entity])), [entities]);
    const emptyList = (0, react_1.useMemo)(() => react_1.Children.toArray(children).find(child => child.type === exports.EmptyList), [children]);
    const footer = (0, react_1.useMemo)(() => react_1.Children.toArray(children).find(child => child.type === exports.Footer), [children]);
    (0, react_1.useImperativeHandle)(ref, () => gridRef.current, []);
    const getVisibleRows = () => {
        if (!gridRef.current || !bodyRef.current) {
            return [];
        }
        const { top, bottom } = gridRef.current.getBoundingClientRect();
        return (0, findVisible_1.findVisibleRows)([...bodyRef.current.children], top, bottom);
    };
    const scheduleVisibleChanges = (0, react_1.useCallback)(() => requestAnimationFrame(() => {
        const visible = getVisibleRows();
        const newVisibleRows = visible.filter(row => {
            const id = row.dataset.rowId;
            if (id === undefined) {
                return false;
            }
            const entity = rowsMap.get(id);
            if (entity === undefined) {
                return false;
            }
            return row;
        }).map(row => row.dataset.rowId);
        const hasNewRows = newVisibleRows.some(id => !visibleRows.has(id));
        if (hasNewRows) {
            const newRowsSet = new Set(visibleRows);
            newVisibleRows.forEach(row => newRowsSet.add(row));
            setVisibleRows(newRowsSet);
        }
    }), [rowsMap, setVisibleRows, visibleRows]);
    const scheduleLazyRender = (0, react_1.useCallback)(() => {
        cancelAnimationFrame(lazyRenderTimerRef.current);
        lazyRenderTimerRef.current = scheduleVisibleChanges();
    }, [scheduleVisibleChanges]);
    (0, react_1.useEffect)(() => {
        const visible = new Set(entities.slice(0, FIRST_RENDERED_ROWS).map(r => r.id));
        const currentlyVisibleRows = getVisibleRows();
        currentlyVisibleRows.forEach(row => {
            const id = row.dataset.rowId;
            if (id) {
                visible.add(id);
            }
        });
        setVisibleRows(visible);
    }, [entities]);
    const listOfDefaultWidthColumns = (0, react_1.useMemo)(() => columnsList.map(column => column.meta.defaultWidth), [columnsList]);
    const { result: observerResult } = (0, useResizeObserver_1.useResizeObserver)({ target: gridRef.current });
    const allocatedSpace = listOfDefaultWidthColumns.reduce((acc, width) => acc + (width === undefined ? 0 : getColumnWidth(width)), 0);
    const unallocatedSpace = observerResult && (observerResult.contentRect.width - allocatedSpace) || 0;
    const flexibleColumnsQty = listOfDefaultWidthColumns.filter(width => width === undefined).length;
    const flexibleColumnWidth = getColumnWidth(unallocatedSpace / flexibleColumnsQty);
    const updateScroll = (0, react_1.useCallback)(() => {
        if (!gridRef.current) {
            return;
        }
        const scrollLeft = gridRef.current.scrollLeft;
        const scrollTop = gridRef.current.scrollTop;
        if (horizontalScrollApplied !== scrollLeft > 0) {
            setHorizontalScrollApplied(scrollLeft > 0);
        }
        if (verticalScrollApplied !== scrollTop > 0) {
            setVerticalScrollApplied(scrollTop > 0);
        }
    }, [horizontalScrollApplied, setHorizontalScrollApplied, verticalScrollApplied, setVerticalScrollApplied]);
    const handleScroll = (0, react_1.useCallback)(() => {
        updateScroll();
        scheduleLazyRender();
    }, [updateScroll, scheduleLazyRender]);
    const getCellParams = (0, react_1.useCallback)((columnIndex) => {
        const defaultWidth = listOfDefaultWidthColumns[columnIndex];
        const limited = !!defaultWidth && defaultWidth > 0;
        const isFirst = columnIndex === 0;
        const isLast = columnIndex === listOfDefaultWidthColumns.length - 1;
        // If the column is the last one or doesn't have a default width, it should be limited to the remaining space
        const width = getColumnWidth(defaultWidth || flexibleColumnWidth);
        return { limited, isFirst, isLast, width };
    }, [listOfDefaultWidthColumns, flexibleColumnWidth]);
    const renderHeaderCell = (0, react_1.useCallback)((column, columnIndex) => {
        var _a;
        const { isFirst, isLast, width } = getCellParams(columnIndex);
        const text = ((_a = column.columnComponent.renderHeader) === null || _a === void 0 ? void 0 : _a.bind(column.columnComponent)) ? column.columnComponent.renderHeader(column.title) : column.title;
        return (0, jsx_runtime_1.jsx)(headerCell_1.DataGridHeaderCell, { id: column.id, isFirst: isFirst, isLast: isLast, name: column.name, width: width, hidden: !text, children: (0, jsx_runtime_1.jsx)("div", { className: "zen-data-grid__header-cell-content", children: renderHeaderWrappers(column.wrappers, (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-data-grid-header", column.title ? "" : "zen-visually-hidden"]), children: column.title ? text : emptyCellTitleValue })) }) }, `header_${column.name}`);
    }, [getCellParams, emptyCellTitleValue]);
    const isTreeGrid = (0, react_1.useMemo)(() => !!entities.find(e => e.children && e.children.length > 0), [entities]);
    const renderRow = (0, react_1.useCallback)((entity, entityIndex, total) => (0, jsx_runtime_1.jsx)(row_1.DataGridRow, { id: entity.id, isLastRow: entityIndex === total - 1, columns: columnsList, entity: entity, visibleRows: visibleRows, flexibleColumnWidth: flexibleColumnWidth, className: (0, getRowClassName_1.getRowClassName)(rowClassName, entity), expanded: expandedRows && expandedRows.indexOf(entity.id) > -1, onExpandedChange: entity.children && entity.children.length > 0 ? (isExpanded) => onExpandedChange && onExpandedChange(entity.id, isExpanded) : undefined, isTreeGrid: isTreeGrid, ariaPosinset: entityIndex + 1, ariaSetsize: total }, entity.id), [columnsList, expandedRows, flexibleColumnWidth, onExpandedChange, rowClassName, visibleRows, isTreeGrid]);
    const body = (0, react_1.useMemo)(() => entities.map((entity, entityIndex) => renderRow(entity, entityIndex, entities.length)), [entities, renderRow]);
    const headerContent = (0, react_1.useMemo)(() => columnsList.map((column, index) => renderHeaderCell(column, index)), [columnsList, renderHeaderCell]);
    (0, useResize_1.useResize)(() => {
        handleScroll();
    }, true);
    const gridClasses = (0, classNames_1.classNames)([
        "zen-data-grid",
        className,
        horizontalScrollApplied ? exports.HORIZONTAL_SCROLL_MODIFIER : "",
        verticalScrollApplied ? exports.VERTICAL_SCROLL_MODIFIER : ""
    ]);
    return (0, jsx_runtime_1.jsx)("div", { className: "zen-data-grid-wrapper", children: (0, jsx_runtime_1.jsxs)("div", { className: gridClasses, ref: gridRef, onScroll: handleScroll, children: [(0, jsx_runtime_1.jsxs)("table", { className: "zen-data-grid__table", "aria-label": description, role: isTreeGrid ? "treegrid" : undefined, children: [(0, jsx_runtime_1.jsx)("thead", { className: "zen-data-grid__header", children: (0, jsx_runtime_1.jsx)("tr", { className: "zen-data-grid__header-row", children: headerContent }) }), (0, jsx_runtime_1.jsx)("tbody", { ref: bodyRef, children: body })] }), emptyList && entities.length === 0 ? emptyList : null, footer] }) });
};
const DataGrid = (0, react_1.forwardRef)(DataGridInner);
exports.DataGrid = DataGrid;
DataGrid.EmptyList = exports.EmptyList;
DataGrid.Footer = exports.Footer;
exports.TRANSLATIONS = [
    "Action"
];
