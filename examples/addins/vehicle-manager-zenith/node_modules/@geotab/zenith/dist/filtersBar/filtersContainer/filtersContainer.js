"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.FiltersContainer = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const textIconButton_1 = require("../../textIconButton/textIconButton");
const classNames_1 = require("../../commonHelpers/classNames/classNames");
const react_1 = require("react");
const iconChevronRight_1 = require("../../icons/iconChevronRight");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const useDriveClassName_1 = require("../../utils/theme/useDriveClassName");
const getScrollButtonType = (element) => {
    const scrollLeft = element.scrollLeft;
    const scrollWidth = element.scrollWidth;
    const clientWidth = element.clientWidth;
    if (scrollLeft === 0 && scrollWidth === clientWidth) {
        return "";
    }
    if (scrollLeft > 0 && (scrollWidth > clientWidth + scrollLeft + 1)) {
        return "both";
    }
    if (scrollLeft === 0) {
        return "end";
    }
    return "start";
};
const FiltersContainer = ({ className, children }) => {
    const scrollableStep = 200;
    const fadeTransitionDuration = 300;
    const { translate } = (0, useLanguage_1.useLanguage)();
    const gradientClass = "zen-filters-toolbar__gradient";
    const scrollerClass = "zen-filters-toolbar__scroller";
    const driveClassNameScroller = (0, useDriveClassName_1.useDriveClassName)(scrollerClass);
    const driveClassNameGradient = (0, useDriveClassName_1.useDriveClassName)(gradientClass);
    const [scrollButtonType, setScrollButtonType] = (0, react_1.useState)("");
    const scrollableRef = (0, react_1.useRef)(null);
    const [isHiddenDisplay, setIsHiddenDisplay] = (0, react_1.useState)({ left: true, right: true });
    const leftTimeoutRef = (0, react_1.useRef)();
    const rightTimeoutRef = (0, react_1.useRef)();
    const showLeft = scrollButtonType === "start" || scrollButtonType === "both";
    const showRight = scrollButtonType === "end" || scrollButtonType === "both";
    (0, react_1.useEffect)(() => {
        if (!scrollableRef.current) {
            return () => { };
        }
        let timer = undefined;
        const resizeHandler = () => {
            const scrollableElt = scrollableRef.current;
            if (scrollableElt) {
                timer && window.clearTimeout(timer);
                timer = window.setTimeout(() => {
                    setScrollButtonType(getScrollButtonType(scrollableElt));
                }, 200);
            }
        };
        const scrollableElement = scrollableRef.current;
        scrollableElement.addEventListener("scroll", resizeHandler);
        window.addEventListener("resize", resizeHandler);
        resizeHandler();
        return () => {
            timer && window.clearTimeout(timer);
            scrollableElement.removeEventListener("scroll", resizeHandler);
            window.removeEventListener("resize", resizeHandler);
        };
    }, [scrollableRef]);
    (0, react_1.useEffect)(() => {
        if (scrollableRef.current) {
            setScrollButtonType(getScrollButtonType(scrollableRef.current));
        }
    }, [scrollableRef, children]);
    (0, react_1.useEffect)(() => {
        if (showLeft) {
            if (leftTimeoutRef.current) {
                clearTimeout(leftTimeoutRef.current);
            }
            setIsHiddenDisplay(prev => (Object.assign(Object.assign({}, prev), { left: false })));
        }
        else {
            leftTimeoutRef.current = window.setTimeout(() => {
                setIsHiddenDisplay(prev => (Object.assign(Object.assign({}, prev), { left: true })));
            }, fadeTransitionDuration);
        }
        if (showRight) {
            if (rightTimeoutRef.current) {
                clearTimeout(rightTimeoutRef.current);
            }
            setIsHiddenDisplay(prev => (Object.assign(Object.assign({}, prev), { right: false })));
        }
        else {
            rightTimeoutRef.current = window.setTimeout(() => {
                setIsHiddenDisplay(prev => (Object.assign(Object.assign({}, prev), { right: true })));
            }, fadeTransitionDuration);
        }
        return () => {
            if (leftTimeoutRef.current) {
                clearTimeout(leftTimeoutRef.current);
            }
            if (rightTimeoutRef.current) {
                clearTimeout(rightTimeoutRef.current);
            }
        };
    }, [showLeft, showRight]);
    const handleScrollButtonClick = (0, react_1.useCallback)((delta) => () => {
        var _a;
        (_a = scrollableRef.current) === null || _a === void 0 ? void 0 : _a.scrollBy({
            left: delta,
            behavior: "smooth"
        });
    }, []);
    const filtersForRender = react_1.Children.map(children, (child, index) => {
        if (child.props.hideInBar) {
            return null;
        }
        const childComponent = (0, react_1.cloneElement)(child, { useSidePanelView: false });
        return (0, jsx_runtime_1.jsx)("div", { className: "zen-filters-toolbar__filters-item", children: childComponent }, `filtersBarItem_${index}`);
    });
    return filtersForRender.length ? (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-filters-toolbar__filters-container", className !== null && className !== void 0 ? className : "", `zen-filters-toolbar__filters-container--${scrollButtonType || "none"}`]), children: [(0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)([
                    gradientClass,
                    driveClassNameGradient || "",
                    `${gradientClass}--left`,
                    showLeft ? `${gradientClass}--visible` : "",
                    isHiddenDisplay.left ? `${gradientClass}--hidden` : ""
                ]) }), (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { title: translate("Scroll left"), className: (0, classNames_1.classNames)([
                    "zen-filters-toolbar__scroller",
                    driveClassNameScroller || "",
                    "zen-filters-toolbar__start",
                    showLeft ? `${scrollerClass}--visible` : "",
                    isHiddenDisplay.left ? `${scrollerClass}--hidden` : ""
                ]), icon: iconChevronRight_1.IconChevronRight, iconPosition: textIconButton_1.ButtonIconPosition.Start, onClick: handleScrollButtonClick(-scrollableStep), iconClasses: "zen-filters-toolbar__start-icon" }), (0, jsx_runtime_1.jsx)("div", { ref: scrollableRef, className: (0, classNames_1.classNames)([
                    "zen-filters-toolbar__scrollable",
                    !isHiddenDisplay.left ? "has-left-scroller" : "",
                    !isHiddenDisplay.right ? "has-right-scroller" : ""
                ]), children: (0, jsx_runtime_1.jsx)("div", { className: "zen-filters-toolbar__filters", children: filtersForRender }) }), (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)([
                    gradientClass,
                    driveClassNameGradient || "",
                    `${gradientClass}--right`,
                    showRight ? `${gradientClass}--visible` : "",
                    isHiddenDisplay.right ? `${gradientClass}--hidden` : ""
                ]) }), (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { title: translate("Scroll right"), className: (0, classNames_1.classNames)([
                    scrollerClass,
                    driveClassNameScroller || "", "zen-filters-toolbar__end",
                    showRight ? `${scrollerClass}--visible` : "",
                    isHiddenDisplay.right ? `${scrollerClass}--hidden` : ""
                ]), icon: iconChevronRight_1.IconChevronRight, onClick: handleScrollButtonClick(scrollableStep), iconPosition: textIconButton_1.ButtonIconPosition.End })] }) : null;
};
exports.FiltersContainer = FiltersContainer;
exports.TRANSLATIONS = [
    "Scroll left",
    "Scroll right"
];
