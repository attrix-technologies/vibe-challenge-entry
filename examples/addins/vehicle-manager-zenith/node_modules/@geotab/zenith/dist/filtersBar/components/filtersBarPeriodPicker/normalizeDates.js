"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeDates = void 0;
const dateUtils_1 = require("../../../calendar/dateUtils");
// eslint-disable-next-line complexity
const getAvailableRange = (availablePeriod, startDate, endDate, disableDatesBefore, disableDatesAfter) => {
    const now = new Date().toISOString();
    let fromDate = startDate;
    let toDate = endDate;
    if (availablePeriod === "all") {
        fromDate = startDate ? startDate : endDate ? (0, dateUtils_1.addDays)(new Date(endDate), -1).toISOString() : now;
        toDate = endDate ? endDate : startDate ? (0, dateUtils_1.addDays)(new Date(startDate), 1).toISOString() : (0, dateUtils_1.addDays)(new Date(now), 1).toISOString();
        return { from: fromDate, to: toDate };
    }
    if (availablePeriod === "before" && disableDatesAfter) {
        toDate = endDate && new Date(endDate) <= new Date(disableDatesAfter) ? endDate : disableDatesAfter;
        fromDate = startDate && new Date(startDate) < new Date(disableDatesAfter) && new Date(startDate) < new Date(toDate) ? startDate : (0, dateUtils_1.addDays)(new Date(toDate), -1).toISOString();
    }
    if (availablePeriod === "after" && disableDatesBefore) {
        fromDate = startDate && new Date(startDate) >= new Date(disableDatesBefore) ? startDate : disableDatesBefore;
        toDate = endDate && new Date(endDate) > new Date(disableDatesBefore) && new Date(endDate) > new Date(fromDate) ? endDate : (0, dateUtils_1.addDays)(new Date(fromDate), 1).toISOString();
    }
    if (availablePeriod === "outside" && disableDatesBefore && disableDatesAfter) {
        let isAvailableRangeReady = false;
        if (startDate && new Date(startDate) <= new Date(disableDatesAfter)) {
            fromDate = startDate;
            toDate = endDate && new Date(endDate) <= new Date(disableDatesAfter) && new Date(endDate) >= new Date(fromDate) ? endDate : disableDatesAfter;
            isAvailableRangeReady = true;
        }
        if (startDate && new Date(startDate) > new Date(disableDatesBefore)) {
            fromDate = startDate;
            toDate = endDate && new Date(endDate) > new Date(fromDate) ? endDate : (0, dateUtils_1.addDays)(new Date(fromDate), 1).toISOString();
            isAvailableRangeReady = true;
        }
        if (endDate && !isAvailableRangeReady && new Date(endDate) <= new Date(disableDatesAfter)) {
            toDate = endDate;
            fromDate = startDate && new Date(startDate) < new Date(toDate) ? startDate : (0, dateUtils_1.addDays)(new Date(toDate), -1).toISOString();
            isAvailableRangeReady = true;
        }
        if (endDate && !isAvailableRangeReady && new Date(endDate) > new Date(disableDatesBefore)) {
            toDate = endDate;
            fromDate = startDate && new Date(startDate) > new Date(disableDatesBefore) && new Date(startDate) < new Date(toDate) ? startDate
                : ((0, dateUtils_1.addDays)(new Date(toDate), -1) >= new Date(disableDatesBefore) ? (0, dateUtils_1.addDays)(new Date(toDate), -1).toISOString() : disableDatesBefore);
            isAvailableRangeReady = true;
        }
        if (!isAvailableRangeReady) {
            fromDate = disableDatesBefore;
            toDate = (0, dateUtils_1.addDays)(new Date(fromDate), 1).toISOString();
        }
    }
    if (availablePeriod === "inside" && disableDatesBefore && disableDatesAfter) {
        fromDate = startDate && new Date(startDate) >= new Date(disableDatesBefore) && new Date(startDate) < new Date(disableDatesAfter) ? startDate : disableDatesBefore;
        const fromDatePlusOne = (0, dateUtils_1.addDays)(new Date(fromDate), 1).toISOString();
        toDate = endDate && new Date(endDate) > new Date(fromDate) && new Date(endDate) < new Date(disableDatesAfter) ? endDate
            : new Date(fromDatePlusOne) < new Date(disableDatesAfter) ? fromDatePlusOne : disableDatesAfter;
    }
    return { from: fromDate || now, to: toDate || now };
};
// eslint-disable-next-line complexity
const normalizeDates = (startDate, endDate, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter) => {
    const minuteReserve = 2;
    const now = new Date();
    const moreNow = (0, dateUtils_1.addMinutes)(new Date(now), minuteReserve);
    const availablePeriod = (0, dateUtils_1.getAvailablePeriod)(disableDatesBefore, disableDatesAfter);
    if (disableFutureDates && availablePeriod === "all") {
        const updatedStartDate = (0, dateUtils_1.addDays)(new Date(now), -1);
        if (startDate && new Date(startDate) > now) {
            return { from: updatedStartDate.toISOString(), to: now.toISOString() };
        }
        if (endDate && new Date(endDate) > now) {
            return { from: startDate && new Date(startDate) < now ? startDate : updatedStartDate.toISOString(), to: now.toISOString() };
        }
        return { from: startDate && new Date(startDate) < now ? startDate : updatedStartDate.toISOString(), to: endDate || now.toISOString() };
    }
    if (disablePastDates && availablePeriod === "all") {
        const updatedEndDate = (0, dateUtils_1.addDays)(new Date(now), 1);
        if (endDate && new Date(endDate) < moreNow) {
            return { from: moreNow.toISOString(), to: updatedEndDate.toISOString() };
        }
        if (startDate && new Date(startDate) < moreNow) {
            return { from: moreNow.toISOString(), to: endDate || updatedEndDate.toISOString() };
        }
        if (startDate && new Date(startDate) >= moreNow) {
            return { from: startDate, to: endDate && new Date(endDate) > new Date(startDate) ? endDate : (0, dateUtils_1.addDays)(new Date(startDate), 1).toISOString() };
        }
        return { from: moreNow.toISOString(), to: endDate || updatedEndDate.toISOString() };
    }
    return getAvailableRange(availablePeriod, startDate, endDate, disableDatesBefore, disableDatesAfter);
};
exports.normalizeDates = normalizeDates;
