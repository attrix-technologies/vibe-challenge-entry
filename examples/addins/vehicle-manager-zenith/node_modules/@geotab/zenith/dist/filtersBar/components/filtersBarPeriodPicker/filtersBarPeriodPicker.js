"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.FiltersBarPeriodPicker = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const sidePanelCell_1 = require("../../../sidePanel/sidePanelCell/sidePanelCell");
const classNames_1 = require("../../../commonHelpers/classNames/classNames");
const dateRangeInner_1 = require("../../../dateRangeInner/dateRangeInner");
const useUniqueId_1 = require("../../../commonHelpers/useUniqueId");
const useLanguage_1 = require("../../../utils/localization/useLanguage");
const getRangeOption_1 = require("./getRangeOption");
const dateRange_1 = require("../../../dateRange/dateRange");
const userFormatContext_1 = require("../../../utils/userFormat/userFormatContext");
const normalizeDates_1 = require("./normalizeDates");
const DateRangeInnerMemo = (0, react_1.memo)(dateRangeInner_1.DateRangeInner);
const FiltersBarPeriodPicker = ({ props, hasApplyButton, className, useSidePanelView, sidePanelTitle, state, defaultState, onChange, checkError, sidePanelMaxGroupedItemsLength = 5 }) => {
    const { options: optionsArg, withCalendar, timeSelect, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter, lockStartDate, lockEndDate, classNamePopup } = props;
    const { translate } = (0, useLanguage_1.useLanguage)();
    const { toLocalDateTime, toReverseOffsetDateTime, weekStartsOnSunday } = (0, react_1.useContext)(userFormatContext_1.userFormatContext);
    const id = (0, useUniqueId_1.useUniqueId)();
    const optionsMap = (0, react_1.useMemo)(() => (0, getRangeOption_1.getOptionsPeriodMap)(optionsArg, translate, toLocalDateTime, weekStartsOnSunday ? "Sunday" : "Monday", toReverseOffsetDateTime), [optionsArg, toLocalDateTime, toReverseOffsetDateTime, translate, weekStartsOnSunday]);
    const [selectedRange, setSelectedRange] = (0, react_1.useState)((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, state));
    const filterBarLabelledId = (0, useUniqueId_1.useUniqueId)();
    const [prevSelection, setPrevSelection] = (0, react_1.useState)((0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, state));
    const getCustomRange = (0, react_1.useCallback)(() => ({ from: (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.from) || new Date(), to: (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.to) || new Date() }), [prevSelection]);
    const options = (0, react_1.useMemo)(() => (0, getRangeOption_1.getRangeOptionsArray)(optionsArg, translate, toLocalDateTime, weekStartsOnSunday ? "Sunday" : "Monday", toReverseOffsetDateTime, withCalendar || false, prevSelection && prevSelection.label === dateRangeInner_1.CUSTOM_CALENDAR_ID, prevSelection ? getCustomRange : undefined), [optionsArg, translate, toLocalDateTime, weekStartsOnSunday, toReverseOffsetDateTime, withCalendar, prevSelection, getCustomRange]);
    const hasCustomOption = (0, react_1.useMemo)(() => options.find(option => option.id === dateRangeInner_1.CUSTOM_CALENDAR_ID) !== undefined, [options]);
    const [customDate, setCustomDate] = (0, react_1.useState)((0, normalizeDates_1.normalizeDates)(state === null || state === void 0 ? void 0 : state.from.toISOString(), state === null || state === void 0 ? void 0 : state.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter));
    const handleDateRangeSelection = (0, react_1.useCallback)((val) => {
        var _a, _b;
        const selection = options.find(option => option.id === val);
        if (selection && val !== dateRangeInner_1.CUSTOM_CALENDAR_ID && selection.getRange) {
            const range = selection.getRange();
            const normalizedDates = (0, normalizeDates_1.normalizeDates)(range.from.toISOString(), range.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
            const newRange = val === dateRangeInner_1.CUSTOM_CALENDAR_ID ?
                { from: new Date(normalizedDates.from), to: new Date(normalizedDates.to) }
                : range;
            setCustomDate({ from: newRange.from.toISOString(), to: newRange.to.toISOString() });
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            checkError && checkError(!range.from || !range.to);
            onChange(Object.assign({ label: selection.id }, newRange));
        }
        else {
            const startDateForNormalize = ((_a = selection === null || selection === void 0 ? void 0 : selection.getRange) === null || _a === void 0 ? void 0 : _a.call(selection)) && (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) !== val ? selection.getRange().from.toISOString() : state === null || state === void 0 ? void 0 : state.from.toISOString();
            const endDateForNormalize = ((_b = selection === null || selection === void 0 ? void 0 : selection.getRange) === null || _b === void 0 ? void 0 : _b.call(selection)) && (selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label) !== val ? selection.getRange().to.toISOString() : state === null || state === void 0 ? void 0 : state.to.toISOString();
            const normalizedDates = (0, normalizeDates_1.normalizeDates)(startDateForNormalize, endDateForNormalize, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
            const newRange = val === dateRangeInner_1.CUSTOM_CALENDAR_ID ?
                { from: new Date(normalizedDates.from), to: new Date(normalizedDates.to) }
                : undefined;
            const newValueFrom = (newRange === null || newRange === void 0 ? void 0 : newRange.from) || new Date();
            const newValueTo = (newRange === null || newRange === void 0 ? void 0 : newRange.to) || new Date();
            setSelectedRange({ label: val, from: newValueFrom, to: newValueTo });
            setCustomDate({ from: newValueFrom.toISOString(), to: newValueTo.toISOString() });
            onChange({ label: val, from: newValueFrom, to: newValueTo });
        }
    }, [options, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter, checkError, onChange, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, state === null || state === void 0 ? void 0 : state.from, state === null || state === void 0 ? void 0 : state.to]);
    (0, react_1.useEffect)(() => {
        const currentState = (0, getRangeOption_1.getSelectedRangeFromValue)(optionsMap, state);
        if ((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.label) !== (currentState === null || currentState === void 0 ? void 0 : currentState.label)) {
            setSelectedRange(currentState);
            setPrevSelection(currentState);
        }
        if (useSidePanelView && (defaultState === null || defaultState === void 0 ? void 0 : defaultState.label) === dateRangeInner_1.CUSTOM_CALENDAR_ID && (currentState === null || currentState === void 0 ? void 0 : currentState.label) === dateRangeInner_1.CUSTOM_CALENDAR_ID &&
            (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.label) === dateRangeInner_1.CUSTOM_CALENDAR_ID &&
            defaultState.from.toISOString() === currentState.from.toISOString() && defaultState.to.toISOString() === currentState.to.toISOString()
            && customDate.from && customDate.to && (customDate.from !== defaultState.from.toISOString() || customDate.to !== defaultState.to.toISOString())) {
            const normalizedDates = (0, normalizeDates_1.normalizeDates)(defaultState.from.toISOString(), defaultState.to.toISOString(), disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter);
            const newRange = { from: new Date(normalizedDates.from), to: new Date(normalizedDates.to) };
            const updatedState = { label: dateRangeInner_1.CUSTOM_CALENDAR_ID, from: newRange.from, to: newRange.to };
            setSelectedRange(updatedState);
            setPrevSelection(updatedState);
            setCustomDate({ from: newRange.from.toISOString(), to: newRange.to.toISOString() });
        }
    }, [prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.label, state, defaultState, useSidePanelView, customDate.from, customDate.to,
        disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter, optionsMap]);
    const handleCustomDate = (0, react_1.useCallback)((value) => {
        const isHasError = !value.from || !value.to;
        checkError && checkError(isHasError);
        setSelectedRange({ label: dateRangeInner_1.CUSTOM_CALENDAR_ID, from: lockStartDate || value.from, to: lockEndDate || (lockStartDate ? value.to || value.from : value.to) });
        setCustomDate({ from: lockStartDate || value.from, to: lockEndDate || (lockStartDate ? value.to || value.from : value.to) });
        !isHasError && onChange({
            label: dateRangeInner_1.CUSTOM_CALENDAR_ID,
            from: new Date((lockStartDate || value.from)),
            to: new Date((lockEndDate || (lockStartDate ? value.to || value.from : value.to)))
        });
    }, [checkError, lockEndDate, lockStartDate, onChange]);
    const range = (0, react_1.useMemo)(() => ({ from: customDate.from, to: customDate.to }), [customDate.from, customDate.to]);
    const component = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)(DateRangeInnerMemo, { id: `${id}-daterange`, options: options, onOptionSelect: handleDateRangeSelection, onCalendarSelect: hasCustomOption ? handleCustomDate : undefined, selection: selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, range: range, timeSelect: timeSelect, disableFutureDates: disableFutureDates, disablePastDates: disablePastDates, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter }) }), [id, options, handleDateRangeSelection, hasCustomOption, handleCustomDate, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.label, range, timeSelect, disableFutureDates, disablePastDates, disableDatesBefore, disableDatesAfter]);
    const popup = (0, react_1.useMemo)(() => {
        const commonProps = Object.assign(Object.assign({}, props), { hasApplyButton: useSidePanelView ? false : props.hasApplyButton || hasApplyButton, id: id, className: (0, classNames_1.classNames)(["zen-filters-bar-period-picker", useSidePanelView ? "zen-filters-bar-period-picker--full-width" : "", className !== null && className !== void 0 ? className : ""]), classNamePopup: (0, classNames_1.classNames)(["zen-filters-bar-period-picker__popup", useSidePanelView ? "zen-filters-bar-period-picker__popup--full-width" : "", classNamePopup || ""]), classNameWrapper: (0, classNames_1.classNames)([useSidePanelView ? "zen-filters-bar-period-picker-wrapper" : ""]), options: optionsArg });
        return props.allowUnsetValue ? (0, jsx_runtime_1.jsx)(dateRange_1.DateRange, Object.assign({}, commonProps, { value: state, onChange: onChange, defaultValue: defaultState, allowUnsetValue: true })) : (0, jsx_runtime_1.jsx)(dateRange_1.DateRange, Object.assign({}, commonProps, { value: state, onChange: onChange, defaultValue: defaultState, allowUnsetValue: false }));
    }, [props, useSidePanelView, id, className, classNamePopup, optionsArg, state, onChange, defaultState, hasApplyButton]);
    if (!options.length && !hasCustomOption) {
        return "";
    }
    if (!useSidePanelView) {
        return popup;
    }
    const isUsePopup = options.length > sidePanelMaxGroupedItemsLength;
    return (0, jsx_runtime_1.jsx)(sidePanelCell_1.SidePanelCell, { role: "group", labelledBy: filterBarLabelledId, titleId: filterBarLabelledId, title: sidePanelTitle, withoutSidePaddings: !isUsePopup, children: isUsePopup ? popup : component });
};
exports.FiltersBarPeriodPicker = FiltersBarPeriodPicker;
exports.TRANSLATIONS = [
    "Clear",
    "Reset",
    "Apply",
    "Date range filter",
    "The start date cannot be empty.",
    "The end date cannot be empty."
];
