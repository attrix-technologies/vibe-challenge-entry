"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateRangeAdjustedFn = exports.getDateRangeAdjustedStep = exports.PERIOD_THIRTY_DAYS_STEP_OPTION = exports.PERIOD_SEVEN_DAYS_STEP_OPTION = exports.PERIOD_ONE_DAY_STEP_OPTION = exports.QUARTER_STEP_OPTION = exports.YEAR_STEP_OPTION = exports.DEFAULT_STEP_OPTION = exports.MONTH_STEP_OPTION = exports.getSelectedRangeFromValue = exports.getOptionsPeriodMap = exports.getRangeOptionsArray = exports.getRangeOption = void 0;
const dateRangeUtils_1 = require("../../../dateRange/dateRangeUtils");
const dateRangeInner_1 = require("../../../dateRangeInner/dateRangeInner");
const options = {
    "Today": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_TODAY_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "Yesterday": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_YESTERDAY_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "ThisWeek": (translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_THIS_WEEK_OPTION)(toLocalDateTime, translate, firstDayOfWeek, toReverseOffsetDateTime),
    "NextWeek": (translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_NEXT_WEEK_OPTION)(toLocalDateTime, translate, firstDayOfWeek, toReverseOffsetDateTime),
    "LastWeek": (translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_WEEK_OPTION)(toLocalDateTime, translate, firstDayOfWeek, toReverseOffsetDateTime),
    "ThisMonth": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_THIS_MONTH_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "NextMonth": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_NEXT_MONTH_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastMonth": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_MONTH_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastSevenDays": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_SEVEN_DAYS_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastThirtyDays": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_THIRTY_DAYS_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastTwelveMonths": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_TWELVE_MONTHS_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastThreeMonths": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_THREE_MONTH_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "ThisQuarter": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_THIS_QUARTER_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastQuarter": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_QUARTER_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "LastYear": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_LAST_YEAR_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime),
    "ThisYear": (translate, toLocalDateTime, _firstDayOfWeek, toReverseOffsetDateTime) => (0, dateRangeUtils_1.GET_THIS_YEAR_OPTION)(toLocalDateTime, translate, toReverseOffsetDateTime)
};
function getRangeOption(option, translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime) {
    if (typeof option === "string") {
        if (options[option]) {
            return Object.assign({ id: option }, options[option](translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime));
        }
        return undefined;
    }
    return Object.assign({ id: option.label }, option);
}
exports.getRangeOption = getRangeOption;
const getSecondaryLabelOptions = (translate) => (["ThisWeek", "NextWeek", "LastWeek", "ThisMonth",
    "LastMonth", "NextMonth", "LastThreeMonths", "LastYear", "ThisYear", "ThisQuarter", "LastQuarter", "LastTwelveMonths",
    translate("This week"), translate("Next week"), translate("Last week"), translate("This month"),
    translate("Last month"), translate("Next month"), translate("Last 3 months"), translate("Last year"),
    translate("This year"), translate("This quarter"), translate("Last quarter"), translate("Last 12 months")]);
const getRangeOptionsArray = (initialOptions, translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime, customLabel, isPrevRangeCustom, customGetRangeOptions) => {
    const optionsArray = initialOptions.map(opt => getRangeOption(opt, translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime)).filter(option => !!option);
    const hasCustomOption = customLabel || initialOptions.includes("Custom");
    const customOptionIndex = optionsArray.findIndex(el => el.label === "Custom");
    const secondaryLabelOptions = getSecondaryLabelOptions(translate);
    let customOption;
    if (customOptionIndex !== -1) {
        customOption = optionsArray.splice(customOptionIndex, 1)[0];
    }
    const preparedOptions = optionsArray.map(option => { var _a; return (Object.assign(Object.assign({}, option), { hasSecondaryLabel: (_a = option.hasSecondaryLabel) !== null && _a !== void 0 ? _a : secondaryLabelOptions.includes(option.id) })); });
    if (hasCustomOption && !customOption || customOption && !customOption.getRange) {
        customOption = Object.assign(Object.assign({ id: "Custom", label: translate("Custom") }, (customGetRangeOptions ? { getRange: customGetRangeOptions } : {})), { hasSecondaryLabel: customOption ? customOption.hasSecondaryLabel || false : false });
    }
    if (customOption && isPrevRangeCustom) {
        customOption.getRange = customGetRangeOptions;
    }
    customOption && preparedOptions.push(Object.assign(Object.assign({}, customOption), { label: translate("Custom") }));
    return preparedOptions;
};
exports.getRangeOptionsArray = getRangeOptionsArray;
const getOptionsPeriodMap = (initialOptions, translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime) => {
    const optionsArray = initialOptions.map(opt => getRangeOption(opt, translate, toLocalDateTime, firstDayOfWeek, toReverseOffsetDateTime))
        .filter(option => !!option && option.id !== dateRangeInner_1.CUSTOM_CALENDAR_ID);
    const optionsMap = new Map();
    optionsArray.forEach(opt => {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (opt.getRange) {
            const range = opt.getRange();
            const key = `${range.from.toISOString()}_${range.to.toISOString()}`;
            if (optionsMap.has(key)) {
                optionsMap.set(`${key}_${opt.id}`, Object.assign(Object.assign({}, opt), { getRange: () => range }));
            }
            else {
                optionsMap.set(`${key}`, Object.assign(Object.assign({}, opt), { getRange: () => range }));
            }
            return;
        }
    });
    return optionsMap;
};
exports.getOptionsPeriodMap = getOptionsPeriodMap;
const getSelectedRangeFromValue = (optionsMap, value) => {
    if (!value) {
        return undefined;
    }
    const currentOption = optionsMap.get(`${value.from.toISOString()}_${value.to.toISOString()}`);
    if (!currentOption || value.label === dateRangeInner_1.CUSTOM_CALENDAR_ID) {
        return {
            label: dateRangeInner_1.CUSTOM_CALENDAR_ID,
            from: value.from,
            to: value.to
        };
    }
    function findValueByLabel(val) {
        for (const [_, mapVal] of optionsMap.entries()) {
            if (mapVal.id === val.label) {
                const mapValRange = mapVal.getRange();
                return mapValRange.from.getTime() === val.from.getTime() && mapValRange.to.getTime() === val.to.getTime() ? { id: mapVal.id, from: mapValRange.from, to: mapValRange.to } : undefined;
            }
        }
        return undefined;
    }
    const optionToReturn = value.label && currentOption.id && value.label !== currentOption.id ? findValueByLabel(value) : undefined;
    if (optionToReturn) {
        return {
            label: optionToReturn.id,
            from: value.from,
            to: value.to
        };
    }
    return {
        label: currentOption.id,
        from: value.from,
        to: value.to
    };
};
exports.getSelectedRangeFromValue = getSelectedRangeFromValue;
const adjustDateRange = (dateRange, increase, toLocalDateTime, toReverseOffsetDateTime) => {
    const { from, to } = dateRange;
    const interval = to.getTime() - from.getTime();
    let newFrom;
    let newTo;
    const fromToLocalDateTime = toLocalDateTime(from);
    const toToLocalDateTime = toLocalDateTime(to);
    if (!increase) {
        // Decrease logic
        newTo = new Date(fromToLocalDateTime);
        newTo.setDate(fromToLocalDateTime.getDate() - 1);
        newTo.setHours(toToLocalDateTime.getHours());
        newTo.setMinutes(toToLocalDateTime.getMinutes());
        newTo.setSeconds(toToLocalDateTime.getSeconds());
        newTo.setMilliseconds(toToLocalDateTime.getMilliseconds());
        newFrom = new Date(newTo.getTime() - interval);
    }
    else {
        // Increase logic
        newFrom = new Date(toToLocalDateTime);
        newFrom.setDate(toToLocalDateTime.getDate() + 1);
        newFrom.setHours(fromToLocalDateTime.getHours());
        newFrom.setMinutes(fromToLocalDateTime.getMinutes());
        newFrom.setSeconds(fromToLocalDateTime.getSeconds());
        newFrom.setMilliseconds(fromToLocalDateTime.getMilliseconds());
        newTo = new Date(newFrom.getTime() + interval);
    }
    return { from: toReverseOffsetDateTime(newFrom), to: toReverseOffsetDateTime(newTo) };
};
const adjustDateDaysRange = (offset) => (dateRange, increase, toLocalDateTime, toReverseOffsetDateTime) => {
    const { from, to } = dateRange;
    const fromLocal = toLocalDateTime(from);
    const toLocal = toLocalDateTime(to);
    const dayOffset = increase ? 1 * offset : -1 * offset;
    const newFromLocal = new Date(fromLocal);
    const newToLocal = new Date(toLocal);
    newFromLocal.setDate(fromLocal.getDate() + dayOffset);
    newToLocal.setDate(toLocal.getDate() + dayOffset);
    return {
        from: toReverseOffsetDateTime(newFromLocal),
        to: toReverseOffsetDateTime(newToLocal)
    };
};
const adjustDateRangeMonth = (dateRange, increase, toLocalDateTime, toReverseOffsetDateTime) => {
    const { from, to } = dateRange;
    let newFrom;
    let newTo;
    const fromToLocalDateTime = toLocalDateTime(from);
    const toToLocalDateTime = toLocalDateTime(to);
    const fromMonth = fromToLocalDateTime.getMonth();
    const fromYear = fromToLocalDateTime.getFullYear();
    const toMonth = toToLocalDateTime.getMonth();
    const toYear = toToLocalDateTime.getFullYear();
    // Calculate the number of months in the original range
    const monthsDifference = (toYear - fromYear) * 12 + (toMonth - fromMonth) + 1;
    if (!increase) {
        // Decrease
        let newFromMonth = fromMonth - monthsDifference;
        let newFromYear = fromYear;
        while (newFromMonth < 0) {
            newFromMonth += 12;
            newFromYear--;
        }
        newFrom = new Date(newFromYear, newFromMonth, 1); // First day of the month
        let newToMonth = toMonth - monthsDifference;
        let newToYear = toYear;
        while (newToMonth < 0) {
            newToMonth += 12;
            newToYear--;
        }
        // Get the last day of the month for newTo
        const nextMonth = new Date(newToYear, newToMonth + 1, 1);
        newTo = new Date(nextMonth.getTime() - (24 * 60 * 60 * 1000));
    }
    else {
        // Increase
        let newFromMonth = fromMonth + monthsDifference;
        let newFromYear = fromYear;
        while (newFromMonth >= 12) {
            newFromMonth -= 12;
            newFromYear++;
        }
        newFrom = new Date(newFromYear, newFromMonth, 1); // First day of the month
        let newToMonth = toMonth + monthsDifference;
        let newToYear = toYear;
        while (newToMonth >= 12) {
            newToMonth -= 12;
            newToYear++;
        }
        // Get the last day of the month for newTo
        const nextMonth = new Date(newToYear, newToMonth + 1, 1);
        newTo = new Date(nextMonth.getTime() - (24 * 60 * 60 * 1000));
    }
    // Preserve original time components
    newFrom.setHours(fromToLocalDateTime.getHours());
    newFrom.setMinutes(fromToLocalDateTime.getMinutes());
    newFrom.setSeconds(fromToLocalDateTime.getSeconds());
    newFrom.setMilliseconds(fromToLocalDateTime.getMilliseconds());
    newTo.setHours(toToLocalDateTime.getHours());
    newTo.setMinutes(toToLocalDateTime.getMinutes());
    newTo.setSeconds(toToLocalDateTime.getSeconds());
    newTo.setMilliseconds(toToLocalDateTime.getMilliseconds());
    return { from: toReverseOffsetDateTime(newFrom), to: toReverseOffsetDateTime(newTo) };
};
const adjustDateRangeQuarter = (dateRange, increase, toLocalDateTime, toReverseOffsetDateTime) => {
    const { from, to } = dateRange;
    const quarterStartMonth = [0, 3, 6, 9]; // January, April, July, October
    const fromToLocalDateTime = toLocalDateTime(from);
    const toToLocalDateTime = toLocalDateTime(to);
    const fromMonth = fromToLocalDateTime.getMonth();
    const fromYear = fromToLocalDateTime.getFullYear();
    let newFrom;
    let newTo;
    const monthsInQuarter = 3;
    const currentQuarterIndex = quarterStartMonth.findIndex(month => month === fromMonth);
    if (!increase) {
        // Previous Quarter
        const newFromMonth = currentQuarterIndex === 0 ? 9 : quarterStartMonth[currentQuarterIndex - 1];
        const newFromYear = currentQuarterIndex === 0 ? fromYear - 1 : fromYear;
        newFrom = new Date(newFromYear, newFromMonth, fromToLocalDateTime.getDate(), fromToLocalDateTime.getHours(), fromToLocalDateTime.getMinutes(), fromToLocalDateTime.getSeconds(), fromToLocalDateTime.getMilliseconds());
        newTo = new Date(newFromYear, newFromMonth + monthsInQuarter - 1, newFromMonth === 0 || newFromMonth === 9 ? 31 : 30, toToLocalDateTime.getHours(), toToLocalDateTime.getMinutes(), toToLocalDateTime.getSeconds(), toToLocalDateTime.getMilliseconds());
    }
    else {
        // Next Quarter
        const newFromMonth = currentQuarterIndex === 3 ? 0 : quarterStartMonth[currentQuarterIndex + 1];
        const newFromYear = currentQuarterIndex === 3 ? fromYear + 1 : fromYear;
        newFrom = new Date(newFromYear, newFromMonth, fromToLocalDateTime.getDate(), fromToLocalDateTime.getHours(), fromToLocalDateTime.getMinutes(), fromToLocalDateTime.getSeconds(), fromToLocalDateTime.getMilliseconds());
        newTo = new Date(newFromYear, newFromMonth + monthsInQuarter - 1, newFromMonth === 0 || newFromMonth === 9 ? 31 : 30, toToLocalDateTime.getHours(), toToLocalDateTime.getMinutes(), toToLocalDateTime.getSeconds(), toToLocalDateTime.getMilliseconds());
    }
    return { from: toReverseOffsetDateTime(newFrom), to: toReverseOffsetDateTime(newTo) };
};
const adjustDateRangeYear = (dateRange, increase, _, _1) => {
    const { from, to } = dateRange;
    let newFrom;
    let newTo;
    const fromYear = from.getFullYear();
    const toYear = to.getFullYear();
    if (!increase) {
        const previousFromYear = fromYear - 1;
        const previousToYear = toYear - 1;
        newFrom = new Date(from);
        newFrom.setFullYear(previousFromYear);
        newTo = new Date(to);
        newTo.setFullYear(previousToYear);
    }
    else {
        const nextFromYear = fromYear + 1;
        const nextToYear = toYear + 1;
        newFrom = new Date(from);
        newFrom.setFullYear(nextFromYear);
        newTo = new Date(to);
        newTo.setFullYear(nextToYear);
    }
    return { from: newFrom, to: newTo };
};
exports.MONTH_STEP_OPTION = "month_step_option";
exports.DEFAULT_STEP_OPTION = "default_step_option";
exports.YEAR_STEP_OPTION = "year_step_option";
exports.QUARTER_STEP_OPTION = "quarter_step_option";
exports.PERIOD_ONE_DAY_STEP_OPTION = "period_one_day_step_option";
exports.PERIOD_SEVEN_DAYS_STEP_OPTION = "period_seven_days_step_option";
exports.PERIOD_THIRTY_DAYS_STEP_OPTION = "period_thirty_days_step_option";
const getDateRangeAdjustedStep = (translate, label) => {
    const monthsAdjusted = ["LastMonth", "ThisMonth", "NextMonth", "LastThreeMonths", translate("This month"), translate("Last month"), translate("Next month"), translate("Last 3 months")];
    const periodDayAdjusted = ["Today", "Yesterday", translate("Today"), translate("Yesterday")];
    const periodSevenDaysAdjusted = ["ThisWeek", "NextWeek", "LastWeek", "LastSevenDays", translate("This week"), translate("Next week"), translate("Last week"), translate("Last 7 days")];
    const periodThirtyDaysAdjusted = ["LastThirtyDays", translate("Last 30 days")];
    const yearAdjusted = ["LastYear", "ThisYear", "LastTwelveMonths", translate("Last 12 months"), translate("Last year"), translate("This year")];
    const quarterAdjusted = ["ThisQuarter", "LastQuarter", translate("This quarter"), translate("Last quarter")];
    if (!label) {
        return exports.DEFAULT_STEP_OPTION;
    }
    if (monthsAdjusted.includes(label)) {
        return exports.MONTH_STEP_OPTION;
    }
    if (quarterAdjusted.includes(label)) {
        return exports.QUARTER_STEP_OPTION;
    }
    if (yearAdjusted.includes(label)) {
        return exports.YEAR_STEP_OPTION;
    }
    if (periodDayAdjusted.includes(label)) {
        return exports.PERIOD_ONE_DAY_STEP_OPTION;
    }
    if (periodSevenDaysAdjusted.includes(label)) {
        return exports.PERIOD_SEVEN_DAYS_STEP_OPTION;
    }
    if (periodThirtyDaysAdjusted.includes(label)) {
        return exports.PERIOD_THIRTY_DAYS_STEP_OPTION;
    }
    return exports.DEFAULT_STEP_OPTION;
};
exports.getDateRangeAdjustedStep = getDateRangeAdjustedStep;
exports.dateRangeAdjustedFn = {
    [exports.MONTH_STEP_OPTION]: adjustDateRangeMonth,
    [exports.YEAR_STEP_OPTION]: adjustDateRangeYear,
    [exports.QUARTER_STEP_OPTION]: adjustDateRangeQuarter,
    [exports.PERIOD_ONE_DAY_STEP_OPTION]: adjustDateDaysRange(1),
    [exports.PERIOD_SEVEN_DAYS_STEP_OPTION]: adjustDateDaysRange(7),
    [exports.PERIOD_THIRTY_DAYS_STEP_OPTION]: adjustDateDaysRange(30),
    [exports.DEFAULT_STEP_OPTION]: adjustDateRange
};
