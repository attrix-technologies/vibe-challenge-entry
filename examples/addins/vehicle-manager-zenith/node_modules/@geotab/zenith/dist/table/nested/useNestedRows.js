"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNestedRows = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const iconChevronTop_1 = require("../../icons/iconChevronTop");
const iconChevronBottom_1 = require("../../icons/iconChevronBottom");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const NestedWrapperName = "Nested";
const useNestedRows = (expandedRows, onExpand, columns, isMobile) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const [intExpanded, setExpanded] = (0, react_1.useState)([]);
    const expanded = (0, react_1.useMemo)(() => {
        if (expandedRows) {
            return expandedRows;
        }
        return intExpanded;
    }, [expandedRows, intExpanded]);
    const onExpandedChange = (0, react_1.useCallback)((id, isExpanded) => {
        if (onExpand) {
            onExpand(id, isExpanded);
            return;
        }
        if (isExpanded) {
            setExpanded([id]);
        }
        else {
            setExpanded(intExpanded.filter(i => i !== id));
        }
    }, [intExpanded, onExpand]);
    const firstColumnId = (0, react_1.useMemo)(() => columns.length > 0 ? columns[0].id : null, [columns]);
    const wrapper = (0, react_1.useMemo)(() => ({
        name: NestedWrapperName,
        render(value, entity, isNested) {
            if (!entity) {
                return null;
            }
            if (isMobile) {
                return value;
            }
            if (isNested) {
                return value;
            }
            const isExpanded = expanded.indexOf(entity.id) !== -1;
            const onExpandCallback = () => {
                onExpandedChange(entity.id, !isExpanded);
            };
            if ("children" in entity) {
                return (0, jsx_runtime_1.jsxs)("div", { className: "zen-nested-button", children: [(0, jsx_runtime_1.jsx)("button", { className: "zen-nested-button__button", onClick: onExpandCallback, "aria-label": translate(isExpanded ? "Collapse" : "Expand"), children: isExpanded ? (0, jsx_runtime_1.jsx)(iconChevronTop_1.IconChevronTop, { size: "large" }) : (0, jsx_runtime_1.jsx)(iconChevronBottom_1.IconChevronBottom, { size: "large" }) }), (0, jsx_runtime_1.jsx)("div", { className: "zen-nested-button__content", children: value })] });
            }
            return value;
        },
        renderHeader(title) {
            return title;
        }
    }), [expanded, onExpandedChange, isMobile, translate]);
    const nestedColumns = (0, react_1.useMemo)(() => {
        const newColumns = columns.map(c => (Object.assign({}, c)));
        // Add nested wrapper to the first column
        const firstColumn = newColumns.find(c => c.id === firstColumnId);
        if (firstColumn) {
            firstColumn.wrappers = [...firstColumn.wrappers || [], wrapper];
        }
        return newColumns;
    }, [columns, firstColumnId, wrapper]);
    const nestedFeedWrapper = (0, react_1.useCallback)((primaryData, secondaryData, entity, isNested) => {
        if (!entity.children) {
            return [primaryData, secondaryData];
        }
        if (isNested) {
            return [primaryData, secondaryData];
        }
        if (!isMobile) {
            return [primaryData, secondaryData];
        }
        const isExpanded = expanded.indexOf(entity.id) !== -1;
        const onExpandCallback = () => {
            onExpandedChange(entity.id, !isExpanded);
        };
        return [
            (0, jsx_runtime_1.jsxs)("div", { className: "zen-nested-button", children: [(0, jsx_runtime_1.jsx)("button", { className: "zen-nested-button__button", onClick: onExpandCallback, "aria-label": translate(isExpanded ? "Collapse" : "Expand"), children: isExpanded ? (0, jsx_runtime_1.jsx)(iconChevronTop_1.IconChevronTop, { size: "large" }) : (0, jsx_runtime_1.jsx)(iconChevronBottom_1.IconChevronBottom, { size: "large" }) }), (0, jsx_runtime_1.jsx)("div", { className: "zen-nested-button__content", children: primaryData })] }, "nested-button"),
            (0, jsx_runtime_1.jsx)("div", { className: "zen-nested-button__padding", children: secondaryData }, "nested-value")
        ];
    }, [expanded, onExpandedChange, isMobile, translate]);
    return { nestedColumns, nestedFeedWrapper, expanded, onExpandedChange };
};
exports.useNestedRows = useNestedRows;
