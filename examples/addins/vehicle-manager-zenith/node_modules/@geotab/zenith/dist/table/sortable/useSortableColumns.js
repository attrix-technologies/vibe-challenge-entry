"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSortableColumns = exports.getSortableValue = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const sortableStorage_1 = require("./sortableStorage");
const sortableHeader_1 = require("./sortableHeader");
const actionsColumn_1 = require("../../dataGrid/columns/actionsColumn/actionsColumn");
const SortableWrapperName = "Sortable";
const getSortableValue = (pageName, defaultValue) => {
    const storage = new sortableStorage_1.SortableColumnsStorage(pageName, defaultValue);
    return storage.getItem();
};
exports.getSortableValue = getSortableValue;
const useSortableColumns = (columns, sortable, isMobile) => {
    const settingsStore = (0, react_1.useMemo)(() => (sortable === null || sortable === void 0 ? void 0 : sortable.storage) || new sortableStorage_1.SortableColumnsStorage((sortable === null || sortable === void 0 ? void 0 : sortable.pageName) || ""), [sortable === null || sortable === void 0 ? void 0 : sortable.pageName, sortable === null || sortable === void 0 ? void 0 : sortable.storage]);
    const sortSettings = (0, react_1.useMemo)(() => (sortable === null || sortable === void 0 ? void 0 : sortable.value) || settingsStore.getItem(), [settingsStore, sortable === null || sortable === void 0 ? void 0 : sortable.value]);
    const saveSettingsToTheStore = (0, react_1.useCallback)((newSettings) => 
    // not to block main thread this operation can be postponed
    new Promise((resolve, reject) => {
        setTimeout(() => {
            try {
                settingsStore.setItem(newSettings);
                resolve();
            }
            catch (e) {
                reject(e);
            }
        }, 0);
    }), [settingsStore]);
    const onSort = (0, react_1.useCallback)(async (newSortSettings) => {
        await saveSettingsToTheStore(newSortSettings);
        sortable === null || sortable === void 0 ? void 0 : sortable.onChange(newSortSettings);
    }, [saveSettingsToTheStore, sortable]);
    const sortableColumns = (0, react_1.useMemo)(() => {
        if (!sortable) {
            return columns;
        }
        return columns.map(column => {
            const isSortable = column.sortable !== false && !(column.columnComponent instanceof actionsColumn_1.ActionsColumn);
            if (!isSortable) {
                return column;
            }
            const isSortedBy = (sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortColumn) === column.id;
            const wrapper = {
                name: SortableWrapperName,
                renderHeader: (title) => {
                    var _a;
                    return (0, jsx_runtime_1.jsx)(sortableHeader_1.SortableHeaderCell, { columnName: column.id, isSortedBy: isSortedBy, sortDirection: isSortedBy ? sortSettings.sortDirection : undefined, title: title, tooltip: column.title, onSortChange: onSort, initialSortDirection: (_a = column.meta) === null || _a === void 0 ? void 0 : _a.initialSortDirection });
                },
                render: (value, _) => value
            };
            const columnWrappers = (column.wrappers || []).filter(w => w.name !== SortableWrapperName);
            return Object.assign(Object.assign({}, column), { wrappers: [...columnWrappers, wrapper] });
        });
    }, [columns, onSort, sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortColumn, sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortDirection, sortable]);
    const feedSortControl = (0, react_1.useMemo)(() => {
        var _a;
        if (!sortable) {
            return null;
        }
        if (!isMobile) {
            return null;
        }
        const column = columns[0];
        const isSortedBy = (sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortColumn) === column.id;
        return (0, jsx_runtime_1.jsx)(sortableHeader_1.SortableHeaderCell, { columnName: column.id.toString(), isSortedBy: isSortedBy, sortDirection: isSortedBy ? sortSettings.sortDirection : undefined, title: column.title, tooltip: column.title, onSortChange: onSort, isMobile: true, initialSortDirection: (_a = column.meta) === null || _a === void 0 ? void 0 : _a.initialSortDirection });
    }, [columns, isMobile, onSort, sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortColumn, sortSettings === null || sortSettings === void 0 ? void 0 : sortSettings.sortDirection, sortable]);
    return { sortableColumns, feedSortControl };
};
exports.useSortableColumns = useSortableColumns;
