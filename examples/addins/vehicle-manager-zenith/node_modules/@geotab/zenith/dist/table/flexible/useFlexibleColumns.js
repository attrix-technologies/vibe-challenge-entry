"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFlexibleColumns = exports.getColumnSettings = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const flexibleHeader_1 = require("./flexibleHeader");
const flexibleColumnsResizer_1 = require("../../dataGrid/withFlexibleColumns/flexibleColumnsResizer");
const flexibleColumnsReorder_1 = require("../../dataGrid/withFlexibleColumns/flexibleColumnsReorder");
const useSettingsStorage_1 = require("./useSettingsStorage");
const getDefaultSettings_1 = require("./getDefaultSettings");
const columnsPopup_1 = require("./columnsPopup");
const columnSettingsStorage_1 = require("./columnSettingsStorage");
const actionsColumn_1 = require("../../dataGrid/columns/actionsColumn/actionsColumn");
const mergeColumnSettings_1 = require("./mergeColumnSettings");
const getColumnSettings = (pageName, defaultValue) => {
    const storage = new columnSettingsStorage_1.ColumnSettingsStorage(pageName || "", localStorage, defaultValue);
    return storage.getItem();
};
exports.getColumnSettings = getColumnSettings;
const FlexibleWrapperName = "Flexible";
const useFlexibleColumns = (columns, flexible, gridRef, columnsPopupRef, isFeed) => {
    const { settingsStorage, saveSettingsToTheStorage } = (0, useSettingsStorage_1.useSettingsStorage)((flexible === null || flexible === void 0 ? void 0 : flexible.pageName) || "", flexible === null || flexible === void 0 ? void 0 : flexible.storage);
    const defaultColumnSettings = (0, react_1.useMemo)(() => (0, getDefaultSettings_1.getDefaultSettings)(columns), [columns]);
    const columnSettingsFromStorage = settingsStorage.getItem();
    const [columnSettingsState, setColumnSettingsState] = (0, react_1.useState)(columnSettingsFromStorage && columnSettingsFromStorage.length > 0 ? columnSettingsFromStorage : defaultColumnSettings);
    const columnSettings = (0, react_1.useMemo)(() => {
        const value = flexible && flexible.value ? flexible.value : columnSettingsState;
        if (value.length === 0) {
            return defaultColumnSettings;
        }
        return (0, mergeColumnSettings_1.mergeColumnsSettings)(columns, value);
    }, [columnSettingsState, columns, defaultColumnSettings, flexible]);
    const onChangeColumnSettings = (0, react_1.useCallback)((newSettings) => {
        var _a;
        setColumnSettingsState(newSettings);
        (_a = flexible === null || flexible === void 0 ? void 0 : flexible.onChange) === null || _a === void 0 ? void 0 : _a.call(flexible, newSettings);
    }, [flexible]);
    const onResetListener = (0, react_1.useCallback)(async () => {
        await saveSettingsToTheStorage([]);
        onChangeColumnSettings(defaultColumnSettings);
    }, [defaultColumnSettings, onChangeColumnSettings, saveSettingsToTheStorage]);
    const onChangeListener = (0, react_1.useCallback)(async (newSettings) => {
        await saveSettingsToTheStorage(newSettings);
        onChangeColumnSettings(newSettings);
    }, [onChangeColumnSettings, saveSettingsToTheStorage]);
    const flexibleColumns = (0, react_1.useMemo)(() => {
        if (!flexible) {
            return columns;
        }
        const visibleColumnsMap = new Map(columns.map(c => [c.id, c]));
        return columnSettings.map((s, index) => {
            var _a;
            const column = visibleColumnsMap.get(s.name);
            if (column === undefined || !s.visible) {
                return undefined;
            }
            const wrapper = {
                name: FlexibleWrapperName,
                render: (value) => value,
                renderHeader: (title) => (0, jsx_runtime_1.jsx)(flexibleHeader_1.FlexibleHeader, { title: title, draggable: !(column.columnComponent instanceof actionsColumn_1.ActionsColumn || column.draggable === false), resizable: index !== 0 })
            };
            const wrappers = (column.wrappers || []).filter(w => w.name !== FlexibleWrapperName);
            const width = s.width || ((_a = column.meta) === null || _a === void 0 ? void 0 : _a.defaultWidth);
            return (Object.assign(Object.assign({}, column), { meta: Object.assign(Object.assign({}, (column.meta || {})), { defaultWidth: width }), wrappers: [
                    ...wrappers,
                    wrapper
                ] }));
        }).filter(c => c !== undefined);
    }, [columnSettings, columns, flexible]);
    const columnsPopup = (0, react_1.useMemo)(() => {
        if (!flexible) {
            return null;
        }
        if (!columnsPopupRef) {
            return null;
        }
        if (flexible.columnsPopup === false) {
            return null;
        }
        if (flexibleColumns.length === 0) {
            return null;
        }
        return (0, jsx_runtime_1.jsx)(columnsPopup_1.ColumnsPopup, { columns: columns.filter(c => !(c.columnComponent instanceof actionsColumn_1.ActionsColumn)), columnSettings: columnSettings, triggerRef: columnsPopupRef, sortGroups: flexible.sortGroups, sortColumns: flexible.sortColumns, onReset: onResetListener, onChange: onChangeListener });
    }, [columnSettings, columns, columnsPopupRef, flexible, flexibleColumns.length, onChangeListener, onResetListener]);
    const onReorderListener = (0, react_1.useCallback)(async ([from, to]) => {
        if (from === to) {
            return;
        }
        const column = flexibleColumns[from];
        // we should avoid moving actions column
        const limitedTo = Math.min(to, flexibleColumns.length - 1);
        const where = flexibleColumns[limitedTo];
        if (column === undefined) {
            return;
        }
        // update order in settings
        const settingsWithoutColumn = columnSettings.filter(s => s.name !== column.id);
        const originalSettings = columnSettings.filter(s => s.name === column.id)[0];
        const sIndex = settingsWithoutColumn.findIndex(s => s.name === where.id);
        const newColumnSettings = [
            ...settingsWithoutColumn.slice(0, sIndex),
            originalSettings,
            ...settingsWithoutColumn.slice(sIndex)
        ];
        await saveSettingsToTheStorage(newColumnSettings);
        onChangeColumnSettings(newColumnSettings);
    }, [flexibleColumns, columnSettings, saveSettingsToTheStorage, onChangeColumnSettings]);
    const onResizeColumn = (0, react_1.useCallback)(async ([index, width]) => {
        const column = flexibleColumns[index];
        if (column === undefined) {
            return;
        }
        const newColumnSettings = columnSettings.map(s => {
            if (s.name === column.id) {
                return Object.assign(Object.assign({}, s), { width });
            }
            return s;
        });
        await saveSettingsToTheStorage(newColumnSettings);
        onChangeColumnSettings(newColumnSettings);
    }, [flexibleColumns, columnSettings, saveSettingsToTheStorage, onChangeColumnSettings]);
    const isDraggable = (0, react_1.useCallback)((index) => {
        const column = flexibleColumns[index];
        return !(column.columnComponent instanceof actionsColumn_1.ActionsColumn || column.draggable === false);
    }, [flexibleColumns]);
    (0, react_1.useEffect)(() => {
        if (!gridRef.current) {
            return () => { };
        }
        const resizer = new flexibleColumnsResizer_1.FlexibleColumnResizer(gridRef.current);
        resizer.attach("resize", onResizeColumn);
        resizer.add(flexibleColumns);
        // reorder
        const reorder = new flexibleColumnsReorder_1.FlexibleColumnReorder(gridRef.current, resizer, isDraggable);
        reorder.attach("reorder", onReorderListener);
        reorder.add();
        return () => {
            resizer.detach("resize");
            resizer.remove();
            reorder.detach("reorder");
            reorder.remove();
            return;
        };
    }, [onResizeColumn, onReorderListener, gridRef, flexibleColumns, isFeed, isDraggable]);
    return { flexibleColumns, columnsPopup };
};
exports.useFlexibleColumns = useFlexibleColumns;
