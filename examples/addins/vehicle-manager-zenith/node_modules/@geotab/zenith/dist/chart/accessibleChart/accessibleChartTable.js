"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessibleChartTable = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const userFormatContext_1 = require("../../utils/userFormat/userFormatContext");
const formatDate_1 = require("../../utils/formatDate");
const resampleArrayEvenly_1 = require("../utils/resampleArrayEvenly");
const isDateString_1 = require("../utils/isDateString");
const getFormattedLabel_1 = require("../utils/getFormattedLabel");
const truncateDecimals_1 = require("../../utils/truncateDecimals");
const calculateMinTruncationPrecision_1 = require("../utils/calculateMinTruncationPrecision");
const removeTrendDataFromDatasets_1 = require("../utils/removeTrendDataFromDatasets");
const MAX_TABLE_ROWS = 150;
const getXLabels = (type, data, translate) => {
    if (type === "pie") {
        return [translate("Value")];
    }
    const filteredDatasets = (0, removeTrendDataFromDatasets_1.removeTrendDataFromDatasets)(data.datasets);
    return filteredDatasets.map(dataset => dataset.label || translate("Value"));
};
const getYLabels = (type, data) => {
    if (type === "pie" || type === "line-mini") {
        const labels = data.labels;
        if (labels && labels.length > 0) {
            const filteredLabels = labels.filter(l => l !== null && l !== undefined);
            return filteredLabels.map(l => (typeof l === "string" ? l || "-" : l));
        }
        return [];
    }
    const allXValues = data.datasets.flatMap(ds => ds.data.map(d => d.x));
    const allXValueKeys = allXValues.map(x => x instanceof Date ? x.toISOString() : x);
    const uniqueXValues = Array.from(new Set(allXValueKeys));
    return uniqueXValues.sort((a, b) => {
        const aIsDate = a instanceof Date || (typeof a === "string" && (0, isDateString_1.isDateString)(a));
        const bIsDate = b instanceof Date || (typeof b === "string" && (0, isDateString_1.isDateString)(b));
        if (aIsDate && bIsDate) {
            return new Date(a).getTime() - new Date(b).getTime();
        }
        return a - b;
    });
};
const AccessibleChartTable = ({ type, data, options }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const tableCaption = translate("Chart data");
    const { dateFormat, toLocalDateTime } = (0, react_1.useContext)(userFormatContext_1.userFormatContext);
    const dateFormatter = (d, format = dateFormat) => (0, formatDate_1.formatDate)(toLocalDateTime(d), format, translate);
    const filteredDatasets = (0, react_1.useMemo)(() => (0, removeTrendDataFromDatasets_1.removeTrendDataFromDatasets)(data.datasets), [data.datasets]);
    const decimalPlacesPerDataset = (0, react_1.useMemo)(() => {
        const precisionMap = new Map();
        filteredDatasets.forEach((dataset, index) => {
            const numericValues = [];
            if (type === "pie" || type === "line-mini") {
                dataset.data.forEach(yValue => {
                    if (typeof yValue === "number") {
                        numericValues.push(yValue);
                    }
                });
            }
            else {
                dataset.data.forEach(dataPoint => {
                    if (typeof dataPoint.y === "number") {
                        numericValues.push(dataPoint.y);
                    }
                });
            }
            precisionMap.set(index, (0, calculateMinTruncationPrecision_1.calculateMinTruncationPrecision)(numericValues));
        });
        return precisionMap;
    }, [filteredDatasets, type]);
    const xLabels = (0, react_1.useMemo)(() => getXLabels(type, data, translate), [type, data, translate]);
    const { yLabels, isLengthLimited } = (0, react_1.useMemo)(() => {
        const allYLabels = getYLabels(type, data);
        const initialRowLength = allYLabels.length;
        const limited = initialRowLength > MAX_TABLE_ROWS;
        const finalLabels = limited ? (0, resampleArrayEvenly_1.resampleArrayEvenly)(allYLabels, MAX_TABLE_ROWS) : allYLabels;
        return { yLabels: finalLabels, isLengthLimited: limited };
    }, [type, data]);
    return ((0, jsx_runtime_1.jsxs)("div", { className: "screen-reader-only", children: [isLengthLimited && (0, jsx_runtime_1.jsx)("div", { children: translate("Chart contains too many data points so their number has been reduced. If you want to see more, change the Report Range") }), (0, jsx_runtime_1.jsxs)("table", { children: [(0, jsx_runtime_1.jsx)("caption", { children: tableCaption }), (0, jsx_runtime_1.jsx)("thead", { children: (0, jsx_runtime_1.jsxs)("tr", { children: [(0, jsx_runtime_1.jsx)("th", { scope: "col", children: type === "line" ? translate("X-axis") : translate("Category") }), xLabels.map((xLabel, xIndex) => (0, jsx_runtime_1.jsx)("th", { scope: "col", children: xLabel.toString() || "-" }, xIndex))] }) }), (0, jsx_runtime_1.jsxs)("tbody", { children: [type === "line" && yLabels.map((yLabel, yIndex) => (0, jsx_runtime_1.jsxs)("tr", { children: [(0, jsx_runtime_1.jsx)("th", { scope: "row", children: (0, getFormattedLabel_1.getFormattedLabel)(yLabel, dateFormatter, options) }), filteredDatasets.map((dataset, dsIndex) => {
                                        const datasetDecimalPlaces = decimalPlacesPerDataset.get(dsIndex);
                                        const matchingDataPoint = dataset.data.find(ds => {
                                            if (!ds.x) {
                                                return false;
                                            }
                                            const dsXKey = ds.x instanceof Date ? ds.x.toISOString() : ds.x.toString();
                                            return dsXKey === yLabel.toString();
                                        });
                                        let cellContent = "-";
                                        if (matchingDataPoint) {
                                            const yValue = matchingDataPoint.y;
                                            cellContent = typeof yValue === "number" ? (0, truncateDecimals_1.truncateDecimals)(yValue, datasetDecimalPlaces) : yValue;
                                        }
                                        return (0, jsx_runtime_1.jsx)("td", { children: cellContent }, dsIndex);
                                    })] }, yIndex)), (type === "pie" || type === "line-mini") && yLabels.map((yLabel, yIndex) => (0, jsx_runtime_1.jsxs)("tr", { children: [(0, jsx_runtime_1.jsx)("th", { scope: "row", children: yLabel.toString() }), data.datasets.map((dataset, dsIndex) => {
                                        const yValue = dataset.data[yIndex];
                                        const datasetDecimalPlaces = decimalPlacesPerDataset.get(dsIndex);
                                        return (0, jsx_runtime_1.jsx)("td", { children: typeof yValue === "number" ? (0, truncateDecimals_1.truncateDecimals)(yValue, datasetDecimalPlaces) : yValue }, dsIndex);
                                    })] }, yIndex)), (type === "bar") && yLabels.map((yLabel, yIndex) => (0, jsx_runtime_1.jsxs)("tr", { children: [(0, jsx_runtime_1.jsx)("th", { scope: "row", children: yLabel.toString() }), data.datasets.map((dataset, dsIndex) => {
                                        var _a;
                                        const y = (_a = dataset.data[yIndex]) === null || _a === void 0 ? void 0 : _a.y;
                                        const datasetDecimalPlaces = decimalPlacesPerDataset.get(dsIndex);
                                        const yValue = typeof y === "number" ? (0, truncateDecimals_1.truncateDecimals)(y, datasetDecimalPlaces) : y || "";
                                        return (0, jsx_runtime_1.jsx)("td", { children: yValue }, dsIndex);
                                    })] }, yIndex))] })] })] }));
};
exports.AccessibleChartTable = AccessibleChartTable;
