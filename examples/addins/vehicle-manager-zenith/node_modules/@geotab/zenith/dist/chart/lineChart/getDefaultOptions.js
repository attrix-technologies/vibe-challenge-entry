"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultOptions = void 0;
const formatDate_1 = require("../../utils/formatDate");
const defaultGridStyle = {
    drawTicks: false,
    color: "#C0CCD8"
};
const defaultGridBorderStyle = {
    display: false,
    dash: [2, 2]
};
const getFormatFromDateRange = (minDate, maxDate, ticks) => {
    const min = new Date(minDate);
    const max = new Date(maxDate);
    const diff = max.getTime() - min.getTime();
    const stepDiff = diff / ticks;
    //const diffInMinutes = diff / (1000 * 60);
    //const diffInDays = diff / (1000 * 60 * 60 * 24);
    if (stepDiff > 31536000000) { // 1 year
        return { unit: "year", format: "MMM, yyyy" };
    }
    if (stepDiff > 2592000000) { // 30 days
        return { unit: "month", format: "MMM dd, yyyy" };
    }
    if (stepDiff > 604800000) { // 7 days
        return { unit: "week", format: "MMM dd" };
    }
    if (stepDiff > 86400000) { // 1 day
        return { unit: "day", format: "MMM dd" };
    }
    if (stepDiff > 3600000) { // 1 hour
        return { unit: "hour", format: "MMM dd HH:mm" };
    }
    if (stepDiff > 60000) { // 1 minute
        return { unit: "minute", format: "HH:mm" };
    }
    if (stepDiff > 1000) { // 1 second
        return { unit: "second", format: "HH:mm:ss" };
    }
    return { unit: "millisecond", format: "HH:mm:ss.l" };
};
const getDefaultOptions = (yAxis, xAxis, isTimedData, ticks, isDark, translate) => {
    const time = getFormatFromDateRange(xAxis.minDate, xAxis.maxDate, ticks);
    const textColor = isDark ? "#C0CCD8" : "#4E677E";
    const scales = {
        x: {
            title: {
                display: false
            },
            grid: {
                display: false
            },
            type: isTimedData ? "time" : "linear",
            time: isTimedData ? {
                unit: time.unit,
                displayFormats: {
                    [time.unit]: time.format
                }
            } : undefined,
            ticks: isTimedData ? {
                autoSkip: false,
                maxRotation: 0,
                count: ticks,
                maxTicksLimit: ticks,
                color: textColor,
                callback: (value) => (0, formatDate_1.formatDate)(new Date(value), time.format, translate)
            } : {
                source: "data",
                autoSkip: false,
                maxRotation: 0,
                count: ticks,
                maxTicksLimit: ticks,
                color: textColor
            },
            border: defaultGridBorderStyle
        }
    };
    for (let i = 0; i < yAxis.length; i++) {
        const yAxisId = yAxis[i].name;
        scales[yAxisId] = {
            title: {
                display: false
            },
            ticks: {
                color: textColor,
                padding: 10,
                source: "data",
                autoSkip: true
            },
            beginAtZero: true,
            grid: i === 0 ? defaultGridStyle : { display: false },
            border: defaultGridBorderStyle,
            min: yAxis[i].min,
            max: yAxis[i].max,
            position: i === 0 ? "left" : "right"
        };
    }
    return {
        responsive: true,
        maintainAspectRatio: false,
        scales,
        plugins: {
            legend: {
                display: false
            },
            tooltip: {
                enabled: false
            }
        },
        hover: {
            mode: "nearest",
            axis: "x",
            intersect: false
        },
        animation: false
    };
};
exports.getDefaultOptions = getDefaultOptions;
