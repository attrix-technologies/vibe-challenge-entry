"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stateReducer = exports.getInitialState = void 0;
const stateActionType_1 = require("./stateActionType");
const stateReducerHelper_1 = require("./stateReducerHelper");
const groupsFilterHelper_1 = require("../../groupsFilter/groupsFilterHelper");
const groupsHelper_1 = require("../../groupsFilter/groupsHelper");
const getInitialState = (isFullSelectionMode, comboItems, selection, defaultValue, isAllSelected, defaultValueIsAllSelected, isChecked, defaultValueIsChecked) => {
    const updatedGroupsMapSelected = new Map();
    const updatedGroupsMap = comboItems.length ? (0, groupsFilterHelper_1.createGroupsMap)(comboItems, groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID) : {};
    const namelessIds = new Set();
    if (selection.length > 0) {
        selection.forEach(id => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            const item = updatedGroupsMap[id];
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (item) {
                updatedGroupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
            }
            else {
                namelessIds.add(id);
            }
        });
    }
    const isCurrentListNested = Object.keys(updatedGroupsMap).length > 0 && (updatedGroupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID].children || []).some(el => el.children && el.children.length);
    return {
        groupsMap: updatedGroupsMap,
        selectedIds: selection,
        globalSelectedIds: selection,
        defaultValue: defaultValue || [],
        listData: [],
        currentId: undefined,
        showWaiting: false,
        showEmptyList: false,
        showList: false,
        inputValue: "",
        isOpenCombo: false,
        hasDataProblem: false,
        groupsMapSelected: updatedGroupsMapSelected,
        namelessIds: namelessIds,
        pendingNamelessIds: false,
        isNestedList: isCurrentListNested,
        isFullSelectionMode: isFullSelectionMode,
        isAllSelected: isAllSelected,
        globalIsAllSelected: isFullSelectionMode ? isAllSelected || false : undefined,
        defaultValueIsAllSelected: isFullSelectionMode ? defaultValueIsAllSelected || false : undefined,
        isChecked: isChecked,
        defaultValueIsChecked: isChecked !== undefined ? defaultValueIsChecked || false : undefined,
        globalIsChecked: isChecked
    };
};
exports.getInitialState = getInitialState;
// eslint-disable-next-line complexity
function stateReducer(state, action) {
    var _a, _b, _c, _d;
    const { type, payload } = action;
    switch (type) {
        case stateActionType_1.StateActionType.CreateMap: {
            const updatedGroupsMap = payload.length ? (0, groupsFilterHelper_1.createGroupsMap)(payload, groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID) : {};
            const newNamelessIds = new Set(state.namelessIds);
            if (Object.keys(updatedGroupsMap).length && state.selectedIds.length) {
                state.selectedIds.forEach(id => {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = updatedGroupsMap[id];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (item) {
                        state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                        newNamelessIds.delete(id);
                    }
                    else {
                        newNamelessIds.add(id);
                    }
                });
            }
            const isCurrentListNested = Object.keys(updatedGroupsMap).length > 0 && (updatedGroupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID].children || []).some(el => el.children && el.children.length);
            return Object.assign(Object.assign({}, state), { groupsMap: updatedGroupsMap, namelessIds: newNamelessIds, isNestedList: state.isNestedList ? state.isNestedList : isCurrentListNested });
        }
        case stateActionType_1.StateActionType.SetListData: {
            state.selectedIds.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    const item = payload.find(el => el.id === id);
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                    item && state.namelessIds.delete(id);
                }
            });
            const isCurrentDataNested = payload.some(el => el.children && el.children.length > 0);
            return Object.assign(Object.assign({}, state), { listData: payload, hasDataProblem: Object.keys(state.groupsMap).length === 0 && isCurrentDataNested, isNestedList: isCurrentDataNested ? isCurrentDataNested : state.isNestedList });
        }
        case stateActionType_1.StateActionType.SetDataProblem:
            return Object.assign(Object.assign({}, state), { hasDataProblem: payload });
        case stateActionType_1.StateActionType.SetIsChecked:
            return Object.assign(Object.assign({}, state), { isChecked: payload });
        case stateActionType_1.StateActionType.SetDefaultIsChecked:
            return Object.assign(Object.assign({}, state), { defaultValueIsChecked: payload });
        case stateActionType_1.StateActionType.SetCurrentId:
            return Object.assign(Object.assign({}, state), { currentId: payload || undefined });
        case stateActionType_1.StateActionType.SetIsOpenCombo:
            return Object.assign(Object.assign({}, state), { isOpenCombo: payload });
        case stateActionType_1.StateActionType.ResetSelection:
            return Object.assign(Object.assign({}, state), { selectedIds: [...state.defaultValue], isAllSelected: state.defaultValueIsAllSelected, isChecked: typeof state.isChecked === "boolean" ? state.defaultValueIsChecked || false : undefined });
        case stateActionType_1.StateActionType.ResetStateToGlobal:
            return Object.assign(Object.assign({}, state), { selectedIds: [...state.globalSelectedIds], isAllSelected: state.globalIsAllSelected, isChecked: state.globalIsChecked });
        case stateActionType_1.StateActionType.NothingToShow:
            return Object.assign(Object.assign({}, state), { showWaiting: false, showEmptyList: false, showList: false });
        case stateActionType_1.StateActionType.Show:
            return Object.assign(Object.assign({}, state), { [payload.show]: payload.value });
        case stateActionType_1.StateActionType.ShowWaiting:
            return Object.assign(Object.assign({}, state), { showWaiting: true, showEmptyList: false, showList: false });
        case stateActionType_1.StateActionType.ShowEmptyList:
            return Object.assign(Object.assign({}, state), { showWaiting: false, showEmptyList: true, showList: false });
        case stateActionType_1.StateActionType.ShowList:
            return Object.assign(Object.assign({}, state), { showWaiting: false, showEmptyList: false, showList: true });
        case stateActionType_1.StateActionType.SetInputValue:
            return Object.assign(Object.assign({}, state), { inputValue: payload });
        case stateActionType_1.StateActionType.SetState: {
            const newNamelessIds = new Set(state.namelessIds);
            payload.selected.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    !item && newNamelessIds.add(id);
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: payload.selected, namelessIds: newNamelessIds, isAllSelected: payload.isAllSelected });
        }
        case stateActionType_1.StateActionType.UpdateNamelessItems: {
            if (state.pendingNamelessIds) {
                return state;
            }
            const newNamelessIds = new Set(state.namelessIds);
            state.selectedIds.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    !item && newNamelessIds.add(id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && newNamelessIds.delete(id);
                }
                else {
                    newNamelessIds.delete(id);
                }
            });
            return Object.assign(Object.assign({}, state), { namelessIds: newNamelessIds });
        }
        case stateActionType_1.StateActionType.UpdateSelectedItems: {
            payload.forEach(item => {
                if (!state.groupsMapSelected.has(item.id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    state.groupsMapSelected.set(item.id, Object.assign(Object.assign({ id: item.id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            const newNamelessIds = new Set();
            return Object.assign(Object.assign({}, state), { namelessIds: newNamelessIds, pendingNamelessIds: false });
        }
        case stateActionType_1.StateActionType.SetPendingState: {
            return Object.assign(Object.assign({}, state), { pendingNamelessIds: payload });
        }
        case stateActionType_1.StateActionType.SetGlobalState:
            return Object.assign(Object.assign({}, state), { globalSelectedIds: payload.selected, globalIsAllSelected: payload.isAllSelected, globalIsChecked: payload.isChecked !== undefined ? payload.isChecked : state.globalIsChecked });
        case stateActionType_1.StateActionType.SetDefaultValue: {
            const newNamelessIds = new Set(state.namelessIds);
            payload.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    !item && newNamelessIds.add(id);
                }
            });
            return Object.assign(Object.assign({}, state), { defaultValue: payload, namelessIds: newNamelessIds });
        }
        case stateActionType_1.StateActionType.SetDefaultAllSelected: {
            return Object.assign(Object.assign({}, state), { defaultValueIsAllSelected: payload });
        }
        case stateActionType_1.StateActionType.ChangeSingleSelection: {
            const newSelectedId = payload.value ? payload.value : state.defaultValue[0];
            if (newSelectedId && !state.groupsMapSelected.has(newSelectedId)) {
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                const item = state.groupsMap[newSelectedId] || state.listData.find(el => el.id === newSelectedId);
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                item && state.groupsMapSelected.set(newSelectedId, Object.assign(Object.assign({ id: newSelectedId }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
            }
            return Object.assign(Object.assign({}, state), { selectedIds: payload.value ? [payload.value] : (payload.reset ? [...state.defaultValue] : []) });
        }
        case stateActionType_1.StateActionType.ChangeSelection: {
            const currentSelectedIds = new Set(state.selectedIds);
            if (currentSelectedIds.has(payload.itemId)) {
                currentSelectedIds.delete(payload.itemId);
            }
            else {
                currentSelectedIds.add(payload.itemId);
            }
            if (payload.value) {
                // deselect parent
                const parentForDeselect = [];
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                let parent = (_b = (_a = state.groupsMap[payload.itemId]) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.id;
                while (parent && parent !== "root") {
                    parentForDeselect.push(parent);
                    parent = (_c = state.groupsMap[parent].parent) === null || _c === void 0 ? void 0 : _c.id;
                }
                parentForDeselect.forEach(parentId => {
                    currentSelectedIds.delete(parentId);
                });
                // deselect children
                const childrenForDeselect = [];
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                const currentChild = (0, stateReducerHelper_1.getChildList)((_d = state.groupsMap[payload.itemId]) === null || _d === void 0 ? void 0 : _d.children);
                currentChild.forEach(el => {
                    childrenForDeselect.push(el.id);
                });
                childrenForDeselect.forEach(childId => currentSelectedIds.delete(childId));
            }
            currentSelectedIds.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: Array.from(currentSelectedIds) });
        }
        case stateActionType_1.StateActionType.ChangeBulkSelection: {
            const { itemsIds, value } = payload;
            const currentSelectedIds = new Set(state.selectedIds);
            const parentsToProcess = new Set();
            const childrenToProcess = new Set();
            itemsIds.forEach(itemId => {
                var _a, _b, _c, _d;
                if (value) {
                    currentSelectedIds.add(itemId);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    let parent = (_b = (_a = state.groupsMap[itemId]) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.id;
                    while (parent && parent !== "root") {
                        parentsToProcess.add(parent);
                        parent = (_c = state.groupsMap[parent].parent) === null || _c === void 0 ? void 0 : _c.id;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const currentChild = (0, stateReducerHelper_1.getChildList)((_d = state.groupsMap[itemId]) === null || _d === void 0 ? void 0 : _d.children);
                    currentChild.forEach(childId => childrenToProcess.add(childId.id));
                }
                else {
                    currentSelectedIds.delete(itemId);
                }
            });
            childrenToProcess.forEach(childId => currentSelectedIds.delete(childId));
            parentsToProcess.forEach(parentId => currentSelectedIds.delete(parentId));
            currentSelectedIds.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: Array.from(currentSelectedIds) });
        }
        case stateActionType_1.StateActionType.SelectAllChildren: {
            const currentEl = state.groupsMap[payload];
            const newSelected = new Set(state.selectedIds);
            const isDisableStateProhibited = state.isNestedList;
            (currentEl.children || []).forEach(el => {
                var _a, _b;
                if (!newSelected.has(el.id)) {
                    // select when isDisableStateProhibited, or when disabled elements are allowed to be displayed, and this element is not disabled
                    (isDisableStateProhibited || !el.disabled) && newSelected.add(el.id);
                    // deselect parent
                    const parentForDeselect = [];
                    let parent = (_a = state.groupsMap[el.id].parent) === null || _a === void 0 ? void 0 : _a.id;
                    while (parent && parent !== "root") {
                        parentForDeselect.push(parent);
                        parent = (_b = state.groupsMap[parent].parent) === null || _b === void 0 ? void 0 : _b.id;
                    }
                    parentForDeselect.forEach(parentId => {
                        newSelected.delete(parentId);
                    });
                    //deselect children
                    const childrenForDeselect = [];
                    const currentChild = (0, stateReducerHelper_1.getChildList)(state.groupsMap[el.id].children);
                    currentChild.forEach(elt => {
                        childrenForDeselect.push(elt.id);
                    });
                    childrenForDeselect.forEach(childId => newSelected.delete(childId));
                }
            });
            newSelected.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: Array.from(newSelected) });
        }
        case stateActionType_1.StateActionType.DeselectItemsFromAllSelected: {
            const currentEl = state.groupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID];
            // action not submitted for disabled item, other items, even if disabled, not change their state
            const deselectedItems = payload ? new Set([payload]) : new Set(state.listData.filter(elem => !elem.disabled).map(el => el.id));
            const newSelected = new Set();
            (currentEl.children || []).forEach(el => {
                if (!newSelected.has(el.id) && !deselectedItems.has(el.id)) {
                    newSelected.add(el.id);
                }
            });
            state.listData.forEach(el => {
                if (!newSelected.has(el.id) && !deselectedItems.has(el.id)) {
                    newSelected.add(el.id);
                }
            });
            newSelected.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: Array.from(newSelected), isAllSelected: state.isFullSelectionMode ? false : undefined });
        }
        case stateActionType_1.StateActionType.ToggleValueForAllSelected: {
            const currentEl = state.groupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID];
            const newSelected = new Set();
            state.isAllSelected && (currentEl.children || []).forEach(el => {
                if (!newSelected.has(el.id) && el.disabled) {
                    newSelected.add(el.id);
                }
            });
            newSelected.forEach(id => {
                if (!state.groupsMapSelected.has(id)) {
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    const item = state.groupsMap[id] || state.listData.find(el => el.id === id);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    item && state.groupsMapSelected.set(id, Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})));
                }
            });
            return Object.assign(Object.assign({}, state), { selectedIds: state.isAllSelected ? Array.from(newSelected) : [], isAllSelected: state.isFullSelectionMode ? !state.isAllSelected : undefined });
        }
        case stateActionType_1.StateActionType.DeselectAllChildren: {
            const childrenForDeselect = [];
            const currentChild = (0, stateReducerHelper_1.getChildList)(state.groupsMap[payload].children);
            const isDisableStateProhibited = state.isNestedList;
            currentChild.forEach(el => {
                // deselect when isDisableStateProhibited, or when disabled elements are allowed to be displayed, and this element is not disabled
                (isDisableStateProhibited || !el.disabled) && childrenForDeselect.push(el.id);
            });
            const newSelected = new Set(state.selectedIds);
            childrenForDeselect.forEach(childId => newSelected.delete(childId));
            return Object.assign(Object.assign({}, state), { selectedIds: Array.from(newSelected) });
        }
        default: {
            throw Error("Unknown action: " + type);
        }
    }
}
exports.stateReducer = stateReducer;
