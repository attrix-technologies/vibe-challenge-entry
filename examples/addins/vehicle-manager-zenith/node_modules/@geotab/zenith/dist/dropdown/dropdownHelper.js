"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSelectedCount = exports.getStringFromAllSelected = exports.getStringFromSelected = exports.checkIsDataProblem = exports.prepareSelectedIdsToItems = exports.compareObjectsArrays = exports.compareStringsArrays = exports.createListDataOptions = exports.createSingleListOptions = exports.sortDropdownItemArray = exports.createOptions = exports.prepareComboOptionsForList = exports.isAllItemsHasOneParent = exports.getDataForChange = exports.isEveryItemSelected = exports.isAllChildrenSelected = exports.getListDataWithDisabled = exports.getGroupsTreeItem = void 0;
const groupsHelper_1 = require("../groupsFilter/groupsHelper");
const stateReducerHelper_1 = require("./stateReducer/stateReducerHelper");
const getGroupsTreeItem = (stateObj, itemId) => {
    const item = stateObj.groupsMap[itemId];
    return item ? Object.assign({}, item) : undefined;
};
exports.getGroupsTreeItem = getGroupsTreeItem;
const getListDataWithDisabled = (listData, isIgnoreDisabled) => isIgnoreDisabled ? listData : listData.filter(el => !el.disabled);
exports.getListDataWithDisabled = getListDataWithDisabled;
const isAllChildrenSelected = (stateObj, currentId) => {
    if (!currentId) {
        return false;
    }
    const selectedIds = new Set(stateObj.selectedIds);
    const currentEl = (0, exports.getGroupsTreeItem)(stateObj, currentId);
    return currentEl && currentEl.children && currentEl.children.length ? (0, exports.getListDataWithDisabled)(currentEl.children, stateObj.isNestedList).every(el => selectedIds.has(el.id)) : false;
};
exports.isAllChildrenSelected = isAllChildrenSelected;
const isEveryItemSelected = (listData, selectedItems) => {
    if (!selectedItems.length || !listData.length) {
        return false;
    }
    const selectedItemsSet = new Set(selectedItems);
    return listData.every(el => selectedItemsSet.has(el.id));
};
exports.isEveryItemSelected = isEveryItemSelected;
const getDataForChange = (listData, selectedItems, isDeselect) => {
    const selectedItemsSet = new Set(selectedItems);
    const result = [];
    for (const item of listData) {
        const isSelected = selectedItemsSet.has(item.id);
        if ((isDeselect && isSelected) || (!isDeselect && !isSelected)) {
            result.push(item.id);
        }
    }
    return result;
};
exports.getDataForChange = getDataForChange;
const isAllItemsHasOneParent = (listData, childrenArr) => {
    if (listData.length === 0) {
        return true;
    }
    const childrenArrSet = new Set(childrenArr);
    return !listData.every(el => childrenArrSet.has(el.id));
};
exports.isAllItemsHasOneParent = isAllItemsHasOneParent;
function prepareComboOptionsForList(actionListData, translate, options, getSelectedFn, getSelectedChildFn, isFlatList, getTitle, isAllSelected) {
    const selectedIds = new Set(getSelectedFn());
    const preparedOptions = options && options.length ? options.map(option => {
        const selectedChild = getSelectedChildFn(option.id);
        return Object.assign({ label: (0, groupsHelper_1.getGroupDescription)(option, translate), property: option.id, checked: isAllSelected ? true : selectedIds.has(option.id), isWithAction: actionListData.has(option.id), partialChecked: isAllSelected ? false : selectedChild.length > 0, countSelectedChild: 0, blocked: isFlatList ? option.disabled || false : false }, (getTitle ? { title: getTitle(option.id) } : {}));
    }) : [];
    return preparedOptions;
}
exports.prepareComboOptionsForList = prepareComboOptionsForList;
const getSelectedChildren = (stateObj, currentId) => {
    const currentEl = stateObj.groupsMap[currentId];
    let selectedChild = [];
    const currentChild = currentEl ? (0, stateReducerHelper_1.getChildList)(currentEl.children) : [];
    currentChild.forEach(el => {
        if (stateObj.selectedIds.includes(el.id)) {
            selectedChild = [...selectedChild, el.id];
        }
    });
    return selectedChild;
};
const createOptions = (stateObj, translate, listItem, isAllSelected) => {
    const actionListData = new Set();
    listItem.forEach(el => {
        const elem = stateObj.groupsMap[el.id];
        if (elem && elem.children && elem.children.length) {
            actionListData.add(el.id);
        }
    });
    const preparedOptions = prepareComboOptionsForList(actionListData, translate, listItem, () => stateObj.selectedIds, (id) => getSelectedChildren(stateObj, id), !stateObj.isNestedList, (id) => stateObj.groupsMap[id] ? (0, groupsHelper_1.getGroupDescription)(stateObj.groupsMap[id], translate) : "", isAllSelected);
    return preparedOptions;
};
exports.createOptions = createOptions;
const sortDropdownItemArray = (arr, sortFn) => {
    if (sortFn) {
        return [...arr].sort(sortFn);
    }
    return arr;
};
exports.sortDropdownItemArray = sortDropdownItemArray;
const createSingleListOptions = (stateObj, translate, listItem) => {
    const preparedOptions = listItem && listItem.length ? listItem.map(option => ({
        id: option.id,
        children: (0, groupsHelper_1.getGroupDescription)(stateObj.groupsMap[option.id] || option, translate),
        disabled: option.disabled,
        multiLevel: Object.keys(stateObj.groupsMap).length === 0 ? false : option.children && option.children.length > 0 && stateObj.groupsMap[option.id] !== undefined
    })) : [];
    return preparedOptions;
};
exports.createSingleListOptions = createSingleListOptions;
const createListDataOptions = (stateObj, translate, listItem, isMultiselect, isAllSelected) => isMultiselect ? (0, exports.createOptions)(stateObj, translate, listItem, isAllSelected) : (0, exports.createSingleListOptions)(stateObj, translate, listItem);
exports.createListDataOptions = createListDataOptions;
const compareStringsArrays = (arr1, arr2) => {
    if (arr1.length !== arr2.length) {
        return false;
    }
    const set2 = new Set(arr2);
    return arr1.every(el => set2.has(el));
};
exports.compareStringsArrays = compareStringsArrays;
const compareObjectsArrays = (arr1, arr2) => arr1.length === arr2.length && arr1.every((el, ind) => {
    const el2 = arr2[ind];
    const sameId = el.id === el2.id;
    const sameDisabled = (el.disabled === el2.disabled) || (el.disabled === undefined && el2.disabled === false) || (el2.disabled === undefined && el.disabled === false);
    return sameId && sameDisabled;
});
exports.compareObjectsArrays = compareObjectsArrays;
const prepareSelectedIdsToItems = (selectedIds, groupsMap, groupsMapSelected) => {
    const selectedItems = selectedIds.map(id => {
        if (groupsMapSelected.has(id)) {
            return groupsMapSelected.get(id);
        }
        const item = groupsMap[id];
        return item ? Object.assign(Object.assign({ id }, (item.name ? { name: item.name } : {})), (item.color ? { color: item.color } : {})) : { id };
    });
    return selectedItems;
};
exports.prepareSelectedIdsToItems = prepareSelectedIdsToItems;
const checkIsDataProblem = (selectedIds, groupsMap) => {
    const isHasDataProblem = selectedIds.some(id => !groupsMap[id]) && Object.keys(groupsMap).length > 1;
    return isHasDataProblem;
};
exports.checkIsDataProblem = checkIsDataProblem;
const getStringFromSelected = (selectedIds, groupsMapSelected, translate) => {
    if (!selectedIds.length || (selectedIds.length === 1 && selectedIds[0] === groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID)) {
        return "";
    }
    const selectedItems = selectedIds.map(id => groupsMapSelected.has(id) ? (0, groupsHelper_1.getGroupDescription)(groupsMapSelected.get(id), translate) : undefined).filter(el => el);
    return selectedItems.join(", ");
};
exports.getStringFromSelected = getStringFromSelected;
const getStringFromAllSelected = (groupsMap, translate) => {
    var _a;
    if (!((_a = groupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID]) === null || _a === void 0 ? void 0 : _a.children) || groupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID].children.length === 0) {
        return "";
    }
    const selectedItems = groupsMap[groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID].children.map(el => groupsMap[el.id] ? (0, groupsHelper_1.getGroupDescription)(groupsMap[el.id], translate) : undefined).filter(el => el);
    return selectedItems.join(", ");
};
exports.getStringFromAllSelected = getStringFromAllSelected;
const getSelectedCount = (selectedIds) => selectedIds.length === 1 && selectedIds[0] === groupsHelper_1.ENTIRE_ORGANIZATION_GROUP_ID ? 0 : selectedIds.length;
exports.getSelectedCount = getSelectedCount;
