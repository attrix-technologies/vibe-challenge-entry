"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineChartMini = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const typedCharts_1 = require("../react-chartjs/typedCharts");
const auto_1 = require("chart.js/auto");
const utils_1 = require("../commonHelpers/utils");
const utils_2 = require("../lineChart/utils");
const useDrive_1 = require("../utils/theme/useDrive");
const useMobile_1 = require("../commonHelpers/hooks/useMobile");
const themeContext_1 = require("../utils/theme/themeContext");
const accessibleChart_1 = require("../chart/accessibleChart/accessibleChart");
auto_1.Chart.defaults.font = {
    family: "Roboto",
    size: 12
};
auto_1.Chart.register(auto_1.CategoryScale, auto_1.LinearScale, auto_1.PointElement, auto_1.LineElement, auto_1.Filler);
const defaultGridStyle = {
    display: false
};
const defaultGridBorderStyle = {
    display: false
};
const defaultOptions = {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
        x: {
            grid: defaultGridStyle,
            border: defaultGridBorderStyle
        },
        y: {
            grid: defaultGridStyle,
            border: defaultGridBorderStyle,
            ticks: {
                display: false
            }
        }
    },
    plugins: {
        legend: {
            display: false
        },
        tooltip: {
            enabled: false
        }
    }
};
const LineChartMini = (_a) => {
    var _b, _c;
    var { data, options = {} } = _a, rest = __rest(_a, ["data", "options"]);
    const isDrive = (0, useDrive_1.useDrive)();
    const isMobile = (0, useMobile_1.useMobile)();
    const memoizedFontSize = (0, react_1.useMemo)(() => isDrive ? (isMobile ? 14 : 16) : 12, [isDrive, isMobile]);
    const { dark } = (0, react_1.useContext)(themeContext_1.themeContext);
    (0, react_1.useEffect)(() => {
        auto_1.Chart.defaults.font = {
            family: "Roboto",
            size: memoizedFontSize
        };
        auto_1.Chart.defaults.color = dark ? "#FFFFFF" : "#1F2833";
    }, [memoizedFontSize, dark]);
    const adaptedData = Object.assign({}, data);
    const adaptedOptions = (0, utils_1.deepMerge)(defaultOptions, options);
    if (((_b = adaptedData.labels) === null || _b === void 0 ? void 0 : _b.length) === 2) {
        const maxLabelsCount = Math.max(...data.datasets.map(ds => ds.data.length));
        const newLabels = Array(maxLabelsCount).fill("");
        newLabels[0] = (_c = data.labels) === null || _c === void 0 ? void 0 : _c[0];
        newLabels[newLabels.length - 1] = data.labels ? data.labels[data.labels.length - 1] : "";
        adaptedData.labels = newLabels;
    }
    adaptedData.datasets = adaptedData.datasets.map((ds, i) => (0, utils_2.getDefaultDatasetStyle)(ds, i, true));
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(typedCharts_1.Line, Object.assign({ options: adaptedOptions, data: adaptedData, "aria-hidden": true }, rest)), (0, jsx_runtime_1.jsx)(accessibleChart_1.AccessibleChart, { type: "line-mini", data: adaptedData })] });
};
exports.LineChartMini = LineChartMini;
