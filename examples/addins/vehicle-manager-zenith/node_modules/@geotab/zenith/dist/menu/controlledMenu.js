"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSLATIONS = exports.ControlledMenu = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
/* eslint-disable @typescript-eslint/naming-convention */
const react_1 = require("react");
const menuItem_1 = require("./components/menuItem");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const findContent_1 = require("./utils/findContent");
const findFirstFocusable_1 = require("./utils/findFirstFocusable");
const findLastFocusable_1 = require("./utils/findLastFocusable");
const findNextFocusable_1 = require("./utils/findNextFocusable");
const isButton_1 = require("./utils/isButton");
const isLink_1 = require("./utils/isLink");
const findPrevFocusable_1 = require("./utils/findPrevFocusable");
const menuButton_1 = require("./components/menuButton");
const iconArrowLeft_1 = require("../icons/iconArrowLeft");
const controlledPopup_1 = require("../controlledPopup/controlledPopup");
const mobileSheet_1 = require("../mobileSheet/mobileSheet");
const deviceType_1 = require("../commonHelpers/hooks/deviceType");
const useDeviceType_1 = require("../commonHelpers/hooks/useDeviceType");
const utils_1 = require("../commonHelpers/utils");
const pathProvider_1 = require("./contexts/pathProvider");
const menuSeparator_1 = require("./components/menuSeparator");
// eslint-disable-next-line react/prop-types
const ControlledMenu = ({ children, isOpen, setIsOpen, triggerRef, ariaLabel, ariaLabelledby, id, title, className = "", listClassName = "", paddingX = 0, paddingY = 0, alignment }) => {
    const [deviceType, setDeviceType] = (0, react_1.useState)(deviceType_1.DeviceType.Desktop);
    const isMobile = deviceType === deviceType_1.DeviceType.Mobile;
    const memoizedOnChange = (0, react_1.useCallback)(setIsOpen, [setIsOpen]);
    (0, useDeviceType_1.useDeviceType)(setDeviceType);
    const [path, setPath] = (0, react_1.useState)([]);
    (0, react_1.useEffect)(() => {
        if (path.length && !isOpen) {
            setPath([]);
        }
    }, [isOpen, path, setPath]);
    const onOpenBranch = (0, react_1.useCallback)((branchId) => {
        if (!branchId) {
            return;
        }
        if (!path.includes(branchId)) {
            setPath([...path, branchId]);
            return;
        }
        if (path.includes(branchId)) {
            setPath((v) => {
                const newPath = [...v];
                newPath.pop();
                return newPath;
            });
        }
    }, [setPath, path]);
    const closeBranch = (0, react_1.useCallback)(() => {
        setPath((v) => {
            const newPath = [...v];
            newPath.pop();
            return newPath;
        });
    }, [setPath]);
    const [content, parent] = (0, react_1.useMemo)(() => {
        let par = null;
        let currentChildren = children;
        if (isMobile && path.length > 0) {
            const el = (0, findContent_1.findContent)(children, exports.ControlledMenu.Item, path[path.length - 1]);
            if (el || (0, react_1.isValidElement)(el)) {
                currentChildren = el.props.children;
                par = el;
            }
        }
        let cont = [];
        react_1.Children.map(currentChildren, (child) => {
            if (!child) {
                return;
            }
            if (typeof child === "string") {
                cont.push((0, jsx_runtime_1.jsx)("li", { role: "presentation", className: (0, classNames_1.classNames)(["zen-menu-item__content"]), children: child }, (0, utils_1.generateId)()));
                return;
            }
            if (child.type === menuSeparator_1.MenuSeparator) {
                const clone = (0, react_1.cloneElement)(child, {
                    key: child.props.key || (0, utils_1.generateId)()
                });
                cont.push(clone);
                return;
            }
            if (child.type === exports.ControlledMenu.Item) {
                const clone = (0, react_1.cloneElement)(child, {
                    isMobile,
                    key: child.props.id,
                    setIsOpen,
                    onClick: child.props.onClick
                });
                cont.push(clone);
                return;
            }
            cont.push((0, jsx_runtime_1.jsx)("li", { className: (0, classNames_1.classNames)(["zen-menu-item__content"]), role: "presentation", children: child }, child.props.id || child.props["data-id"] || (0, utils_1.generateId)()));
        });
        while (cont[0] && cont[0].type === menuSeparator_1.MenuSeparator) {
            cont.shift();
        }
        while (cont[cont.length - 1] && cont[cont.length - 1].type === menuSeparator_1.MenuSeparator) {
            cont.pop();
        }
        cont = cont.filter((el, indx, arr) => {
            var _a;
            if (el.type === menuSeparator_1.MenuSeparator && ((_a = arr[indx - 1]) === null || _a === void 0 ? void 0 : _a.type) === menuSeparator_1.MenuSeparator) {
                return false;
            }
            return true;
        });
        return [cont, par];
    }, [children, isMobile, path, setIsOpen]);
    const onKeyDown = (e) => {
        var _a, _b, _c, _d;
        const target = e.target;
        if ((0, isButton_1.isButton)(target) || (0, isLink_1.isLink)(target)) {
            if (e.key === "ArrowDown") {
                e.preventDefault();
                (_a = (0, findNextFocusable_1.findNextFocusable)(target)) === null || _a === void 0 ? void 0 : _a.focus();
                return;
            }
            if (e.key === "ArrowUp") {
                e.preventDefault();
                (_b = (0, findPrevFocusable_1.findPrevFocusable)(target)) === null || _b === void 0 ? void 0 : _b.focus();
                return;
            }
            if (e.key === "Home") {
                e.preventDefault();
                (_c = (0, findFirstFocusable_1.findFirstFocusable)(target)) === null || _c === void 0 ? void 0 : _c.focus();
                return;
            }
            if (e.key === "End") {
                e.preventDefault();
                (_d = (0, findLastFocusable_1.findLastFocusable)(target)) === null || _d === void 0 ? void 0 : _d.focus();
                return;
            }
        }
        if ((0, isButton_1.isButton)(target)) {
            if (e.key === "ArrowRight" && target.classList.contains("zen-menu-button__action--has-children")) {
                e.preventDefault();
                target.click();
                return;
            }
        }
    };
    const renderMenuList = () => (0, jsx_runtime_1.jsx)("div", { onKeyDown: onKeyDown, className: (0, classNames_1.classNames)(["zen-action-list", className]), children: (0, jsx_runtime_1.jsxs)("ul", { role: "menu", className: (0, classNames_1.classNames)(["zen-menu-item", className, listClassName]), children: [parent ? (0, jsx_runtime_1.jsx)(menuButton_1.MenuButton, { id: "root", name: parent.props.name, icon: iconArrowLeft_1.IconArrowLeft, onClick: closeBranch, hasChildren: false, disabled: false }, "root") : null, content] }) });
    const hideMenu = (0, react_1.useCallback)(() => {
        closeBranch();
        setIsOpen(false);
    }, [closeBranch, setIsOpen]);
    if (isMobile) {
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)(pathProvider_1.PathProvider, { path: path, onOpenBranch: onOpenBranch, closeBranch: closeBranch, children: (0, jsx_runtime_1.jsxs)(mobileSheet_1.MobileSheet, { label: title, isOpen: isOpen, triggerRef: triggerRef, onHidePanel: hideMenu, onCloseClick: hideMenu, children: [(0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Title, { children: title }), (0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Content, { children: renderMenuList() })] }) }) });
    }
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)(pathProvider_1.PathProvider, { path: path, onOpenBranch: onOpenBranch, closeBranch: closeBranch, children: (0, jsx_runtime_1.jsx)(controlledPopup_1.ControlledPopup, { id: id, useTrapFocusWithTrigger: "on", className: (0, classNames_1.classNames)(["zen-controlled-menu", className]), onOpenChange: memoizedOnChange, isOpen: isOpen, triggerRef: triggerRef, paddingX: paddingX, paddingY: paddingY, alignment: alignment, ariaLabelledby: ariaLabelledby, ariaLabel: ariaLabel, recalculateOnScroll: true, children: renderMenuList() }) }) });
};
exports.ControlledMenu = ControlledMenu;
exports.ControlledMenu.Item = menuItem_1.MenuItem;
exports.ControlledMenu.Separator = menuSeparator_1.MenuSeparator;
exports.TRANSLATIONS = ["Back"];
