"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tooltip = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = __importStar(require("react"));
const useResize_1 = require("../commonHelpers/hooks/useResize");
const calculatePosition_1 = require("../utils/positioningUtils/calculatePosition");
const react_dom_1 = require("react-dom");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const calculateArrowPosition_1 = require("./helpers/calculateArrowPosition");
const deviceType_1 = require("../commonHelpers/hooks/deviceType");
const useDeviceType_1 = require("../commonHelpers/hooks/useDeviceType");
const mobileSheet_1 = require("../mobileSheet/mobileSheet");
const themeContext_1 = require("../utils/theme/themeContext");
const tooltipAlignments_1 = require("../utils/positioningUtils/tooltipAlignments");
const TOOLTIP_ARROW_HEIGHT = 6;
const TOOLTIP_VISIBILITY_DELAY = 100;
const arrowClasses = {
    "top": "zen-tooltip__arrow--top",
    "top-left": "zen-tooltip__arrow--top",
    "top-right": "zen-tooltip__arrow--top",
    "bottom": "zen-tooltip__arrow--bottom",
    "bottom-left": "zen-tooltip__arrow--bottom",
    "bottom-right": "zen-tooltip__arrow--bottom",
    "right": "zen-tooltip__arrow--right",
    "right-top": "zen-tooltip__arrow--right",
    "right-bottom": "zen-tooltip__arrow--right",
    "left": "zen-tooltip__arrow--left",
    "left-top": "zen-tooltip__arrow--left",
    "left-bottom": "zen-tooltip__arrow--left"
};
const Tooltip = ({ trigger, className = "", size = "small", alignment = "bottom", padding = 0, children, mobileView = "default", mobileSheetTitle }) => {
    const triggerRefNative = trigger.ref;
    const triggerLocalRef = (0, react_1.useRef)(null);
    const triggerRef = triggerRefNative || triggerLocalRef;
    const timerRef = (0, react_1.useRef)(null);
    const timerMouseOutRef = (0, react_1.useRef)(null);
    const tooltipRef = (0, react_1.useRef)(null);
    const arrowRef = (0, react_1.useRef)(null);
    const [isTooltipVisible, setTooltipVisible] = (0, react_1.useState)(false);
    const [deviceType, setDeviceType] = (0, react_1.useState)(deviceType_1.DeviceType.Desktop);
    const tooltipId = (0, react_1.useId)();
    const { dark } = (0, react_1.useContext)(themeContext_1.themeContext);
    (0, useDeviceType_1.useDeviceType)(setDeviceType);
    const onKeyDownHandler = (0, react_1.useCallback)((e) => {
        if (e.code === "Escape") {
            setTooltipVisible(false);
        }
    }, []);
    const triggerEvents = (0, react_1.useMemo)(() => {
        if (deviceType === deviceType_1.DeviceType.Desktop) {
            return {
                onMouseOver: () => {
                    setTooltipVisible(true);
                    timerMouseOutRef.current && clearTimeout(timerMouseOutRef.current);
                },
                onMouseLeave: () => {
                    timerRef.current = setTimeout(() => {
                        setTooltipVisible(false);
                    }, TOOLTIP_VISIBILITY_DELAY);
                },
                onFocus: () => setTooltipVisible(true),
                onBlur: () => setTooltipVisible(false),
                onKeyDown: onKeyDownHandler,
                onClick: (...args) => {
                    var _a, _b;
                    (_b = (_a = trigger.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
                    if (isTooltipVisible) {
                        setTooltipVisible(false);
                    }
                }
            };
        }
        if (mobileView === "mobileSheet") {
            return {
                onClick: () => setTooltipVisible(true)
            };
        }
        return {
            onClick: (e) => {
                var _a, _b;
                e.stopPropagation();
                if (trigger.props.onClick) {
                    (_b = (_a = trigger.props).onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
                }
                else {
                    setTooltipVisible(isVisible => !isVisible);
                }
            },
            onTouchStart: () => setTooltipVisible(true),
            onTouchEnd: () => setTooltipVisible(false)
        };
    }, [deviceType, mobileView, onKeyDownHandler, trigger.props, isTooltipVisible]);
    const triggerCloneProps = isTooltipVisible ? {
        "aria-describedby": tooltipId
    } : {};
    const triggerClone = react_1.default.cloneElement(trigger, Object.assign(Object.assign({ ref: triggerRef }, triggerCloneProps), triggerEvents));
    const arrowClass = (0, react_1.useMemo)(() => arrowClasses[alignment] || arrowClasses.bottom, [alignment]);
    const renderTooltip = () => {
        if (mobileView === "mobileSheet" && deviceType === deviceType_1.DeviceType.Mobile) {
            return (0, jsx_runtime_1.jsxs)(mobileSheet_1.MobileSheet, { onHidePanel: () => {
                    var _a;
                    setTooltipVisible(false);
                    (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                }, triggerRef: triggerRef, label: "", isOpen: isTooltipVisible, onCloseClick: () => {
                    var _a;
                    setTooltipVisible(false);
                    (_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                }, children: [(0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Content, { className: "zen-tooltip__mobile-sheet-content", children: children }), (0, jsx_runtime_1.jsx)(mobileSheet_1.MobileSheet.Title, { children: mobileSheetTitle })] });
        }
        return (0, react_dom_1.createPortal)((0, jsx_runtime_1.jsxs)("div", { id: tooltipId, role: "tooltip", ref: tooltipRef, className: (0, classNames_1.classNames)(["zen-tooltip", dark ? "zen-dark" : "", `zen-tooltip--${size}`, className]), onMouseOver: () => {
                timerRef.current && clearTimeout(timerRef.current);
                timerMouseOutRef.current && clearTimeout(timerMouseOutRef.current);
            }, onMouseOut: () => {
                timerMouseOutRef.current = setTimeout(() => setTooltipVisible(false), TOOLTIP_VISIBILITY_DELAY);
            }, children: [(0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-tooltip__arrow", arrowClass]), ref: arrowRef }), (0, jsx_runtime_1.jsx)("div", { className: (0, classNames_1.classNames)(["zen-tooltip__body", `zen-tooltip__body--${size}`]), children: children })] }), document.fullscreenElement || document.body);
    };
    const calculatePosition = (0, react_1.useCallback)(() => {
        (0, calculatePosition_1.calculatePosition)(triggerRef, tooltipRef, TOOLTIP_ARROW_HEIGHT + padding, TOOLTIP_ARROW_HEIGHT + padding, false, alignment, tooltipAlignments_1.tooltipAlignments);
        (0, calculateArrowPosition_1.calculateArrowPosition)(triggerRef, tooltipRef, arrowRef, alignment);
    }, [alignment, padding, triggerRef]);
    const handleClickOutside = (0, react_1.useCallback)((event) => {
        var _a, _b;
        if (!((_a = triggerRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target)) && !((_b = tooltipRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
            setTooltipVisible(false);
        }
    }, [triggerRef]);
    (0, useResize_1.useResize)(calculatePosition, isTooltipVisible);
    (0, react_1.useLayoutEffect)(calculatePosition, [isTooltipVisible, calculatePosition]);
    (0, react_1.useEffect)(() => {
        if (deviceType === deviceType_1.DeviceType.Mobile && isTooltipVisible) {
            document.addEventListener("click", handleClickOutside);
        }
        return () => {
            document.removeEventListener("click", handleClickOutside);
        };
    }, [deviceType, isTooltipVisible, handleClickOutside]);
    (0, react_1.useEffect)(() => {
        if (deviceType === deviceType_1.DeviceType.Mobile && isTooltipVisible) {
            document.addEventListener("click", handleClickOutside);
        }
        return () => {
            document.removeEventListener("click", handleClickOutside);
        };
    }, [deviceType, isTooltipVisible, handleClickOutside]);
    (0, react_1.useEffect)(() => {
        const escapeHandler = onKeyDownHandler;
        document.addEventListener("keydown", escapeHandler);
        return () => document.removeEventListener("keydown", escapeHandler);
    }, [onKeyDownHandler]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [isTooltipVisible && renderTooltip(), triggerClone] });
};
exports.Tooltip = Tooltip;
