"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NavItem = exports.NavItemContext = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const classNames_1 = require("../../commonHelpers/classNames/classNames");
const react_1 = require("react");
const iconBeta_1 = require("../../icons/iconBeta");
const iconChevronRight_1 = require("../../icons/iconChevronRight");
const iconOpen2_1 = require("../../icons/iconOpen2");
const tooltip_1 = require("../../tooltip/tooltip");
const controlledMenu_1 = require("../../menu/controlledMenu");
const nav_context_1 = require("../context/nav.context");
const useMobile_1 = require("../../commonHelpers/hooks/useMobile");
const ICON_SIZE = "huge";
const SUBMENU_ICON_SIZE = "large";
// Context for tracking parent level for nested navigation items
exports.NavItemContext = (0, react_1.createContext)({ parentLevel: 0 });
const isLinkNavItem = (item) => !!item.link;
const NavItemContent = ({ primaryIcon, secondaryIcon, isBeta, counter, collapsed, hasSubmenu, iconClass, level = 1, children }) => {
    const primaryIconRef = (0, react_1.useRef)(null);
    const PrimaryIconComponent = typeof primaryIcon === "function" ? primaryIcon : null;
    const SecondaryIconComponent = secondaryIcon;
    const iconSize = level > 1 ? SUBMENU_ICON_SIZE : ICON_SIZE;
    const primaryIconComponent = primaryIcon ? ((0, jsx_runtime_1.jsx)("span", { ref: primaryIconRef, className: (0, classNames_1.classNames)(["zen-nav-item__icon", counter ? "zen-nav-item__icon--with-counter" : "", iconClass || ""]), children: PrimaryIconComponent ? (0, jsx_runtime_1.jsx)(PrimaryIconComponent, { size: iconSize }) : primaryIcon })) : null;
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)("div", { className: "zen-nav-item__content-left", children: [isBeta && !collapsed ? ((0, jsx_runtime_1.jsx)("span", { className: "zen-nav-item__beta", children: (0, jsx_runtime_1.jsx)(iconBeta_1.IconBeta, { size: "big" }) })) : null, primaryIconComponent, SecondaryIconComponent && !collapsed ? ((0, jsx_runtime_1.jsx)("span", { className: "zen-nav-item__icon", children: (0, jsx_runtime_1.jsx)(SecondaryIconComponent, { size: iconSize }) })) : null, !collapsed ? (0, jsx_runtime_1.jsx)("span", { className: "zen-nav-item__title", children: children }) : null] }), !collapsed && (counter || hasSubmenu) ? ((0, jsx_runtime_1.jsxs)("div", { className: "zen-nav-item__content-right", children: [counter ? (0, jsx_runtime_1.jsx)("div", { className: "zen-nav-item__counter", children: counter }) : null, hasSubmenu ? (0, jsx_runtime_1.jsx)(iconChevronRight_1.IconChevronRight, { className: "zen-nav-item__title-icon", size: iconSize }) : null] })) : null] }));
};
const LinkNavItem = (_a) => {
    var { className, title, collapsed, active, link, isExternalLink, tabIndex } = _a, rest = __rest(_a, ["className", "title", "collapsed", "active", "link", "isExternalLink", "tabIndex"]);
    const isMobile = (0, useMobile_1.useMobile)();
    const { parentLevel = 1 } = (0, react_1.useContext)(exports.NavItemContext);
    const item = (0, jsx_runtime_1.jsx)("a", { href: link, "aria-label": title, title: title, target: isExternalLink ? "_blank" : undefined, rel: isExternalLink ? "noopener noreferrer" : undefined, tabIndex: tabIndex, role: "menuitem", className: (0, classNames_1.classNames)([
            "zen-link--light",
            "zen-nav-item",
            "zen-nav-item--link",
            isMobile ? "zen-nav-item--mobile" : "",
            collapsed ? "zen-nav-item--collapsed" : "",
            active ? "zen-nav-item--active" : "",
            className || ""
        ]), children: (0, jsx_runtime_1.jsxs)(NavItemContent, Object.assign({ title: title, collapsed: collapsed, level: parentLevel + 1 }, rest, { children: [(0, jsx_runtime_1.jsx)("span", { className: "zen-nav-item__title-text", children: title }), isExternalLink && !collapsed ? (0, jsx_runtime_1.jsx)(iconOpen2_1.IconOpen2, { className: "zen-nav-item__title-icon", size: ICON_SIZE }) : null] })) });
    return collapsed ? ((0, jsx_runtime_1.jsx)(tooltip_1.Tooltip, { trigger: item, alignment: "right", children: title })) : item;
};
LinkNavItem.displayName = "LinkNavItem";
const ButtonNavItem = (_a) => {
    var { className, title, onClick, collapsed, active, children, tabIndex, menuAlignment = "right-top" } = _a, rest = __rest(_a, ["className", "title", "onClick", "collapsed", "active", "children", "tabIndex", "menuAlignment"]);
    const [menuOpen, setMenuOpen] = (0, react_1.useState)(false);
    const { parentLevel = 1 } = (0, react_1.useContext)(exports.NavItemContext);
    const triggerRef = (0, react_1.useRef)(null);
    const validChildren = react_1.Children.toArray(children).filter(child => {
        const element = child;
        return element.type && element.type.displayName === "NavItem";
    });
    const hasNestedItems = validChildren.length > 0;
    const handleClick = () => {
        if (hasNestedItems) {
            setMenuOpen(prevOpen => !prevOpen);
        }
        else {
            onClick === null || onClick === void 0 ? void 0 : onClick();
        }
    };
    const handleKeyPress = (evt) => {
        if (evt.key !== "ArrowRight") {
            return;
        }
        if (hasNestedItems) {
            setMenuOpen(prevOpen => !prevOpen);
        }
    };
    const onMenuL2Click = (itemProps) => {
        var _a;
        setMenuOpen(false);
        !isLinkNavItem(itemProps) && ((_a = itemProps.onClick) === null || _a === void 0 ? void 0 : _a.call(itemProps));
    };
    const isMobile = (0, useMobile_1.useMobile)();
    const buttonElement = ((0, jsx_runtime_1.jsx)("button", { ref: triggerRef, "aria-label": title, title: title, tabIndex: tabIndex, role: "menuitem", className: (0, classNames_1.classNames)([
            "zen-nav-item",
            "zen-nav-item--button",
            isMobile ? "zen-nav-item--mobile" : "",
            collapsed ? "zen-nav-item--collapsed" : "",
            active ? "zen-nav-item--active" : "",
            hasNestedItems ? "zen-nav-item--has-nested" : "",
            hasNestedItems && menuOpen ? "zen-nav-item--active" : "",
            className || ""
        ]), onClick: handleClick, onKeyDown: handleKeyPress, children: (0, jsx_runtime_1.jsx)(NavItemContent, Object.assign({ title: title, collapsed: collapsed, hasSubmenu: hasNestedItems, level: parentLevel + 1 }, rest, { children: (0, jsx_runtime_1.jsx)("span", { className: "zen-nav-item__title-text", children: title }) })) }));
    const trigger = collapsed ? ((0, jsx_runtime_1.jsx)(tooltip_1.Tooltip, { trigger: buttonElement, alignment: "right", children: title })) : (buttonElement);
    if (hasNestedItems) {
        // Process children to ensure only 1 level of nesting by removing children from nested NavItems
        const processedChildren = validChildren.map((child) => {
            const childElement = child;
            if (child && typeof child === "object" && "props" in child) {
                // If this child has its own children, remove them to enforce 1-level nesting
                if (childElement.props.children) {
                    return (0, react_1.cloneElement)(childElement, Object.assign(Object.assign({}, childElement.props), { className: (0, classNames_1.classNames)(["zen-nav-item--level-2", isMobile ? "zen-nav-item--level-2--mobile" : "", childElement.props.className || ""]), children: undefined, collapsed: false, onClick: () => onMenuL2Click(childElement.props) }));
                }
            }
            return (0, react_1.cloneElement)(childElement, Object.assign(Object.assign({}, childElement.props), { className: (0, classNames_1.classNames)(["zen-nav-item--level-2", isMobile ? "zen-nav-item--level-2--mobile" : "", childElement.props.className || ""]), children: undefined, collapsed: false, onClick: () => onMenuL2Click(childElement.props) })); // Enforce submenu items are not collapsed if not set explicitly
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [trigger, (0, jsx_runtime_1.jsx)(exports.NavItemContext.Provider, { value: { parentLevel: parentLevel + 1 }, children: (0, jsx_runtime_1.jsx)(controlledMenu_1.ControlledMenu, { triggerRef: triggerRef, isOpen: menuOpen, setIsOpen: setMenuOpen, title: title, alignment: menuAlignment, className: (0, classNames_1.classNames)(["zen-nav-l2-popup", isMobile ? "zen-nav-l2-popup--mobile" : ""]), listClassName: (0, classNames_1.classNames)(["zen-nav-l2-popup__list", isMobile ? "zen-nav-l2-popup__list--mobile" : ""]), children: processedChildren }) })] }));
    }
    return trigger;
};
ButtonNavItem.displayName = "ButtonNavItem";
/**
 * @beta This component is not fully ready yet and may change in future releases.
 */
const NavItem = (props) => {
    const isLink = isLinkNavItem(props);
    const { collapsed } = (0, nav_context_1.useNavContext)();
    return isLink ? ((0, jsx_runtime_1.jsx)(LinkNavItem, Object.assign({ collapsed: collapsed }, props)) // Allow to override collapsed prop from context
    ) : ((0, jsx_runtime_1.jsx)(ButtonNavItem, Object.assign({ collapsed: collapsed }, props)));
};
exports.NavItem = NavItem;
exports.NavItem.displayName = "NavItem";
