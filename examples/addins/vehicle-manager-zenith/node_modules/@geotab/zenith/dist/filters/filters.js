"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filters = exports.FiltersDisplayName = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const headerHelpers_1 = require("../header/headerHelpers");
const react_2 = __importDefault(require("react"));
const filtersSelect_1 = require("./components/filtersSelect");
const classNames_1 = require("../commonHelpers/classNames/classNames");
const textIconButton_1 = require("../textIconButton/textIconButton");
const iconChevronDownSmall_1 = require("../icons/iconChevronDownSmall");
const useLanguage_1 = require("../utils/localization/useLanguage");
const controlledPopup_1 = require("../controlledPopup/controlledPopup");
const filtersContainer_1 = require("./components/filtersContainer");
const filtersItem_1 = require("./components/filtersItem");
const filtersDropdown_1 = require("./components/filtersDropdown");
const filtersGroups_1 = require("./components/filtersGroups");
const filtersRange_1 = require("./components/filtersRange");
const filtersChip_1 = require("./components/filtersChip");
const filtersDateRange_1 = require("./components/filtersDateRange");
const filtersModal_1 = require("./components/filtersModal");
const filtersSearchList_1 = require("./components/filtersSearchList");
const chipStatusProvider_1 = require("../chip/chipStatusProvider");
const filtersSavedItemsProvider_1 = require("./components/filtersSavedItemsProvider");
const filtersHelper_1 = require("./filtersHelper");
const filtersSearch_1 = require("./components/filtersSearch");
const useUniqueId_1 = require("../commonHelpers/useUniqueId");
const isElementsEqual_1 = require("../utils/compareElementsUtils/isElementsEqual");
const iconFilter_1 = require("../icons/iconFilter");
exports.FiltersDisplayName = "Filters";
const Filters = ({ className, children, isPinned, onPinChange, keyword, setKeyword, searchTypes, searchType, setSearchType, allFiltersState, setAllFiltersState, onToggleView, searchSelection, setSearchSelection, recentSearches, onRemoveRecentSearchItem, onSaveRecentSearch, savedFilters, onRemoveSavedFilter, onSaveFilter }) => {
    const [isOpen, setIsOpen] = (0, react_1.useState)(false);
    const isSavedFiltersMode = Boolean(savedFilters && onRemoveSavedFilter && onSaveFilter);
    const isPinMode = Boolean(typeof isPinned === "boolean" && onPinChange);
    const isRecentSearchesMode = Boolean(recentSearches && onRemoveRecentSearchItem && onSaveRecentSearch);
    const uniqueKey = (0, useUniqueId_1.useUniqueId)();
    const [isModalOpen, setIsModalOpen] = (0, react_1.useState)(false);
    const triggerRef = react_2.default.useRef(null);
    const searchTriggerRef = react_2.default.useRef(null);
    const prevIsOpenRef = react_2.default.useRef(isOpen);
    const [savedFiltersStates, setSavedFiltersStates] = (0, react_1.useState)(new Map());
    const { translate } = (0, useLanguage_1.useLanguage)();
    const searchTypesArray = (0, react_1.useMemo)(() => (0, filtersHelper_1.getArrayOfElements)(searchTypes), [searchTypes]);
    const searchTypesMap = (0, react_1.useMemo)(() => {
        const map = new Map();
        searchTypesArray.forEach(el => {
            map.set(el.id, el.name);
        });
        return map;
    }, [searchTypesArray]);
    const searchTypesToSelect = (0, react_1.useMemo)(() => searchTypesArray.map(el => ({ id: el.id, name: el.name, subItems: el.subItems ? [...el.subItems] : undefined })), [searchTypesArray]);
    const filters = (0, react_1.useMemo)(() => {
        const childrenArray = (0, headerHelpers_1.getArrayOfChildren)(children);
        return (0, filtersItem_1.getAllowedFilters)(childrenArray);
    }, [children]);
    (0, react_1.useEffect)(() => {
        if (!isSavedFiltersMode) {
            return;
        }
        const error = savedFilters.error;
        if (error) {
            console.error("Failed to fetch saved filters. Error:", error);
        }
        else if (savedFilters && savedFilters.data) {
            setSavedFiltersStates(new Map(savedFilters.data.map(item => [item.name, { id: item.id, state: item.state }])));
        }
    }, [isSavedFiltersMode, savedFilters]);
    const handleSaveRecentSearch = (0, react_1.useCallback)((searchValue) => {
        if (!onSaveRecentSearch) {
            return;
        }
        if (!(searchSelection === null || searchSelection === void 0 ? void 0 : searchSelection.length) && !searchValue) {
            return;
        }
        const entries = searchSelection || [];
        const keywordEntry = searchValue ? { id: filtersSearchList_1.KEYWORD_ID, name: searchValue, type: filtersSearchList_1.KEYWORD_TYPE } : entries.find((item) => item.id === filtersSearchList_1.KEYWORD_ID);
        const preparedItemsArray = [...entries].filter(el => el.id !== filtersSearchList_1.KEYWORD_ID).map(el => (Object.assign(Object.assign({}, el), { type: el.type || filtersSearchList_1.NO_TYPED_SEARCH_ITEM })));
        const isTyped = preparedItemsArray.length ? preparedItemsArray.every(el => el.type === preparedItemsArray[0].type) : false;
        if (keywordEntry) {
            preparedItemsArray.push(Object.assign(Object.assign({}, keywordEntry), { type: filtersSearchList_1.KEYWORD_TYPE }));
        }
        const newRecentSearchNamesArr = preparedItemsArray.filter(el => el.id !== filtersSearchList_1.KEYWORD_ID).map(el => el.name || el.id);
        keywordEntry && newRecentSearchNamesArr.push(`\%${keywordEntry.name}\%`);
        const newRecentSearchName = newRecentSearchNamesArr.join(", ");
        const newRecentSearch = { name: newRecentSearchName, type: isTyped ? preparedItemsArray[0].type : filtersSearchList_1.NO_TYPED_SEARCH_ITEM,
            description: Array.from(new Set(entries.filter(el => el.type && el.type !== filtersSearchList_1.NO_TYPED_SEARCH_ITEM && el.type !== filtersSearchList_1.KEYWORD_TYPE)
                .map(el => searchTypesMap.get(el.type) || el))).join(", "),
            itemsArray: [...preparedItemsArray] };
        onSaveRecentSearch(Object.assign({}, newRecentSearch));
    }, [onSaveRecentSearch, searchSelection, searchTypesMap]);
    const handleSearchFocus = (0, react_1.useCallback)(() => {
        if (!isOpen) {
            setIsOpen(true);
        }
    }, [isOpen]);
    (0, react_1.useEffect)(() => {
        var _a;
        isOpen && ((_a = searchTriggerRef.current) === null || _a === void 0 ? void 0 : _a.focus());
    }, [isOpen, searchTriggerRef]);
    (0, react_1.useEffect)(() => {
        if (!isOpen && prevIsOpenRef.current) {
            prevIsOpenRef.current = false;
            isRecentSearchesMode && handleSaveRecentSearch();
        }
        if (isOpen) {
            prevIsOpenRef.current = true;
        }
    }, [isOpen, isRecentSearchesMode, handleSaveRecentSearch]);
    const selectState = (0, react_1.useMemo)(() => Object.keys(searchType), [searchType]);
    const onSearchItemClick = (0, react_1.useCallback)((item) => {
        if (!(searchSelection && setSearchSelection)) {
            return;
        }
        const typeKey = item.type || filtersSearchList_1.NO_TYPED_SEARCH_ITEM;
        const currentItem = searchSelection.find(el => el.id === item.id && (el.type || filtersSearchList_1.NO_TYPED_SEARCH_ITEM) === typeKey);
        if (currentItem) {
            const newValue = searchSelection.filter(el => !(el.id === currentItem.id && (el.type || filtersSearchList_1.NO_TYPED_SEARCH_ITEM) === typeKey));
            setSearchSelection(newValue);
        }
        else {
            setSearchSelection([...searchSelection, item]);
        }
    }, [searchSelection, setSearchSelection]);
    const handleTriggerClick = (0, react_1.useCallback)(() => {
        setIsOpen(prevState => !prevState);
    }, []);
    const handleModalState = (0, react_1.useCallback)(() => {
        onToggleView && onToggleView(!isModalOpen);
        setIsModalOpen(val => !val);
    }, [isModalOpen, onToggleView]);
    const handleOpenChange = (0, react_1.useCallback)((open) => {
        setIsOpen(open);
    }, []);
    const handleModalApply = (0, react_1.useCallback)((state) => {
        filters.forEach((filter) => {
            const newState = state[filter.props.id];
            if (filter.props.id && state.hasOwnProperty(filter.props.id) && filter.props.onChange) {
                filter.props.onChange(newState);
            }
        });
    }, [filters]);
    const handleSaveFilters = (0, react_1.useCallback)((filterName, filterState) => {
        const stateForSave = filterState || (0, filtersHelper_1.createStateObject)(filters, "state");
        onSaveFilter && onSaveFilter({ name: filterName, state: stateForSave }).then((id) => {
            setSavedFiltersStates(prevStates => new Map(prevStates).set(filterName, { state: stateForSave, id: id }));
        }).catch(error => {
            console.error("Could not save the following filter configuration:", "name", filterName, "state", stateForSave, "Error:", error);
        });
    }, [filters, onSaveFilter]);
    const handleRecentSearchItemClick = (0, react_1.useCallback)((item) => {
        const newSearchSelection = item.itemsArray;
        const newItemSearch = item.itemsArray.find(el => el.id === filtersSearchList_1.KEYWORD_ID);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (newSearchSelection) {
            setSearchSelection === null || setSearchSelection === void 0 ? void 0 : setSearchSelection([...newSearchSelection]);
        }
        newItemSearch && setKeyword(newItemSearch.name);
        setIsOpen(false);
    }, [setKeyword, setSearchSelection]);
    const handlePinChange = (0, react_1.useCallback)(() => {
        onPinChange && onPinChange(!isPinned);
    }, [onPinChange, isPinned]);
    const getIconByType = (0, react_1.useCallback)((type) => {
        if (!type) {
            return iconFilter_1.IconFilter;
        }
        const foundType = searchTypesArray.find((item) => item.id === type);
        return foundType && foundType.icon ? foundType.icon : iconFilter_1.IconFilter;
    }, [searchTypesArray]);
    const memoizedSelect = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(filtersSelect_1.FiltersSelect, { id: `filtersSelect_${uniqueKey}`, 
        // name={translate("Search by")}
        value: searchType, onChange: setSearchType, items: searchTypesToSelect }), [searchType, searchTypesToSelect, setSearchType, uniqueKey]);
    const memoizedSearch = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(filtersSearch_1.FiltersSearch, { id: `filtersSearch_${uniqueKey}`, ref: isOpen ? searchTriggerRef : null, name: translate("Search page"), value: keyword, onChange: setKeyword, onSearchKeyDown: isRecentSearchesMode ? handleSaveRecentSearch : undefined, handleSearchFocus: handleSearchFocus, handleRemove: onSearchItemClick, searchSelection: searchSelection, className: "zen-filters-popup__search-with-pills" }), [uniqueKey, isOpen, translate, keyword, setKeyword, isRecentSearchesMode, handleSaveRecentSearch, handleSearchFocus, onSearchItemClick, searchSelection]);
    const allOption = (0, react_1.useMemo)(() => (0, filtersSelect_1.getAllOption)(translate), [translate]);
    const selectTrigger = (0, react_1.useMemo)(() => {
        var _a;
        return (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-filters__select-trigger", iconClasses: "zen-filters__select-trigger-icon", contentClasses: "zen-filters__select-trigger-content", onClick: handleTriggerClick, icon: iconChevronDownSmall_1.IconChevronDownSmall, iconPosition: "end", children: !isOpen ? selectState[0] === filtersSelect_1.ALL_SELECT_OPTION_ID ? allOption.name :
                (_a = searchTypesArray.find((item) => item.id === selectState[0])) === null || _a === void 0 ? void 0 : _a.name : translate("Search by") });
    }, [handleTriggerClick, selectState, isOpen, allOption.name, translate, searchTypesArray]);
    const combinedData = (0, filtersHelper_1.useCombineData)(searchTypesArray);
    const memoizedPopup = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(controlledPopup_1.ControlledPopup, { paddingY: -28, isOpen: isOpen, className: (0, classNames_1.classNames)(["zen-filters-popup"]), onOpenChange: handleOpenChange, useTrapFocusWithTrigger: "withTrigger", alignment: "bottom", shouldHoldScroll: true, triggerRef: triggerRef, ariaLabel: translate("Setting conditions"), recalculateOnScroll: true, children: (0, jsx_runtime_1.jsxs)("div", { className: "zen-filters-popup__content", children: [(0, jsx_runtime_1.jsxs)("div", { className: "zen-filters-popup__left-panel", children: [selectTrigger, memoizedSelect] }), (0, jsx_runtime_1.jsxs)("div", { className: "zen-filters-popup__right-panel", children: [memoizedSearch, (0, jsx_runtime_1.jsx)(filtersSearchList_1.FiltersSearchList, { searchValue: keyword, searchData: combinedData, searchSelection: searchSelection, getIconByType: getIconByType, handleSearchItemClick: onSearchItemClick, recentSearches: isRecentSearchesMode ? recentSearches : undefined, onRemoveRecentSearchItem: isRecentSearchesMode ? onRemoveRecentSearchItem : undefined, handleRecentSearchItemClick: isRecentSearchesMode ? handleRecentSearchItemClick : undefined })] })] }) }), [isOpen, handleOpenChange, selectTrigger, memoizedSelect, memoizedSearch, keyword, combinedData, searchSelection, getIconByType, onSearchItemClick, isRecentSearchesMode, recentSearches, translate, onRemoveRecentSearchItem, handleRecentSearchItemClick]);
    const filtersForRender = (0, react_1.useMemo)(() => filters.filter(el => typeof el.props.visible === "boolean" ? el.props.visible
        : el.props.visible === undefined ? false : el.props.visible(Array.from(selectState), undefined)), [filters, selectState]);
    // The modal has a full set of filters, so we need to calculate the number of changed filters based on all filters, not just the visible ones
    const filtersForCalculation = (0, react_1.useMemo)(() => {
        const stateObj = (0, filtersHelper_1.createStateObject)(filters, "state");
        return filters.filter(el => typeof el.props.visible === "boolean" ? el.props.visible
            : el.props.visible === undefined ? true : (el.props.visible(Array.from(selectState), stateObj) || el.props.visible(Array.from(selectState))));
    }, [filters, selectState]);
    const hasSavedFilters = savedFiltersStates.size > 0;
    const memoizedFiltersContainer = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(filtersContainer_1.FiltersContainer, { filtersClickHandler: handleModalState, filtersForCalculation: filtersForCalculation, isPinned: isPinMode ? isPinned : undefined, onPinChange: isPinMode ? onPinChange : undefined, hasSavedFilters: hasSavedFilters, children: filtersForRender }), [handleModalState, filtersForCalculation, isPinMode, isPinned, onPinChange, hasSavedFilters, filtersForRender]);
    const tabItems = (0, react_1.useMemo)(() => searchTypesArray.map((item) => ({ id: item.id, name: item.name })), [searchTypesArray]);
    const memoizedModal = (0, react_1.useMemo)(() => (0, jsx_runtime_1.jsx)(filtersModal_1.FiltersModal, { isOpen: isModalOpen, onApply: handleModalApply, onClose: handleModalState, onPin: isPinMode ? handlePinChange : undefined, isPinned: isPinMode ? isPinned : undefined, filters: filters, tabItems: tabItems, externalModalState: allFiltersState, setExternalModalState: setAllFiltersState }), [isModalOpen, handleModalApply, handleModalState, handlePinChange, isPinned, isPinMode, filters, tabItems, allFiltersState, setAllFiltersState]);
    const memoizedStatus = (0, react_1.useMemo)(() => isPinned && isPinMode ? "accent" : undefined, [isPinned, isPinMode]);
    const memoizedSavedFiltersItems = (0, react_1.useMemo)(() => new Set(savedFiltersStates.keys()), [savedFiltersStates]);
    const memoizedSavedFiltersActive = (0, react_1.useMemo)(() => {
        const activeSet = new Set();
        const currentState = (0, filtersHelper_1.createStateObject)(filters, "state");
        Array.from(savedFiltersStates.keys()).forEach(key => {
            var _a;
            const savedState = (_a = savedFiltersStates.get(key)) === null || _a === void 0 ? void 0 : _a.state;
            if (savedState) {
                if ((0, isElementsEqual_1.isElementsEqual)(currentState, savedState)) {
                    activeSet.add(key);
                }
            }
        });
        return activeSet;
    }, [savedFiltersStates, filters]);
    const removeSavedFiltersState = (0, react_1.useCallback)((item) => {
        var _a;
        setSavedFiltersStates((prev) => {
            const newState = new Map(prev);
            newState.delete(item);
            return newState;
        });
        const filterId = (_a = savedFiltersStates.get(item)) === null || _a === void 0 ? void 0 : _a.id;
        if (filterId) {
            onRemoveSavedFilter && onRemoveSavedFilter(filterId);
        }
    }, [onRemoveSavedFilter, savedFiltersStates]);
    const applySavedFiltersState = (0, react_1.useCallback)((item) => {
        var _a;
        const newState = (_a = savedFiltersStates.get(item)) === null || _a === void 0 ? void 0 : _a.state;
        if (newState) {
            filters.forEach((filter) => {
                const stateForFilter = newState[filter.props.id];
                if (filter.props.id && newState.hasOwnProperty(filter.props.id) && filter.props.onChange) {
                    filter.props.onChange(stateForFilter);
                }
            });
        }
    }, [filters, savedFiltersStates]);
    return (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-filters", className || ""]), children: [isOpen ? null : (0, jsx_runtime_1.jsxs)("div", { className: "zen-filters__main-row", children: [selectTrigger, memoizedSearch] }), (0, jsx_runtime_1.jsx)("div", { className: "zen-filters__trigger", ref: triggerRef, role: "button", tabIndex: 0, "aria-label": translate("Open search") }), (0, jsx_runtime_1.jsx)(filtersSavedItemsProvider_1.FiltersSavedItemsProvider, { items: memoizedSavedFiltersItems, active: memoizedSavedFiltersActive, onRemove: isSavedFiltersMode ? removeSavedFiltersState : undefined, onApply: isSavedFiltersMode ? applySavedFiltersState : undefined, onSave: isSavedFiltersMode ? handleSaveFilters : undefined, children: (0, jsx_runtime_1.jsx)(chipStatusProvider_1.ChipStatusProvider, { status: memoizedStatus, children: memoizedFiltersContainer }) }), memoizedPopup, isModalOpen ? (0, jsx_runtime_1.jsx)(filtersSavedItemsProvider_1.FiltersSavedItemsProvider, { items: memoizedSavedFiltersItems, active: memoizedSavedFiltersActive, onRemove: isSavedFiltersMode ? removeSavedFiltersState : undefined, onApply: isSavedFiltersMode ? applySavedFiltersState : undefined, onSave: isSavedFiltersMode ? handleSaveFilters : undefined, children: (0, jsx_runtime_1.jsx)(chipStatusProvider_1.ChipStatusProvider, { status: memoizedStatus, children: memoizedModal }) }) : null] });
};
exports.Filters = Filters;
exports.Filters.Chip = filtersChip_1.FiltersChip;
exports.Filters.DateRange = filtersDateRange_1.FiltersDateRange;
exports.Filters.Dropdown = filtersDropdown_1.FiltersDropdown;
exports.Filters.Groups = filtersGroups_1.FiltersGroups;
exports.Filters.Range = filtersRange_1.FiltersRange;
// Filters.Custom = FiltersCustom;
exports.Filters.displayName = exports.FiltersDisplayName;
