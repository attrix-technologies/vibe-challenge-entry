"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FiltersModal = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const modal_1 = require("../../modal/modal");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const tabs_1 = require("../../tabs/tabs");
const filtersHelper_1 = require("../filtersHelper");
const filtersModalItem_1 = require("./filtersModalItem");
const classNames_1 = require("../../commonHelpers/classNames/classNames");
const filtersSavedItemsProvider_1 = require("./filtersSavedItemsProvider");
const filtersSelect_1 = require("./filtersSelect");
const filtersSaveModal_1 = require("./filtersSaveModal");
const button_1 = require("../../button/button");
const iconDisk_1 = require("../../icons/iconDisk");
const useDriveClassName_1 = require("../../utils/theme/useDriveClassName");
const iconPin2_1 = require("../../icons/iconPin2");
const FiltersModal = ({ isOpen, onClose, onApply, onPin, tabItems, filters, externalModalState, setExternalModalState, isPinned = false }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const { onSave } = (0, filtersSavedItemsProvider_1.useFiltersSavedItems)();
    const iconDriveClassName = (0, useDriveClassName_1.useDriveClassName)("icon");
    const [activeTabId, setActiveTabId] = (0, react_1.useState)(filtersSelect_1.ALL_SELECT_OPTION_ID);
    const [isSaveModalOpen, setIsSaveModalOpen] = (0, react_1.useState)(false);
    const [filtersInternalModalState, setFiltersInternalModalState] = (0, react_1.useState)((0, filtersHelper_1.createStateObject)(filters, "state"));
    const [initialExternalModalState] = (0, react_1.useState)(externalModalState);
    const onTabChange = (newVal) => {
        setActiveTabId(newVal);
    };
    const externalMode = (0, react_1.useMemo)(() => {
        if (externalModalState === undefined || setExternalModalState === undefined) {
            return false;
        }
        return true;
    }, [externalModalState, setExternalModalState]);
    const handleInternalFiltersStateChange = (0, react_1.useCallback)((id) => (newState) => {
        setFiltersInternalModalState((prevState) => (Object.assign(Object.assign({}, prevState), { [id]: newState })));
    }, []);
    const handleExternalFiltersStateChange = (0, react_1.useCallback)((id) => (newState) => {
        setExternalModalState && setExternalModalState({ [id]: newState });
    }, [setExternalModalState]);
    const currentState = (0, react_1.useMemo)(() => externalMode ? externalModalState
        : filtersInternalModalState, [externalMode, externalModalState, filtersInternalModalState]);
    const currentFilters = (0, react_1.useMemo)(() => filters.filter((item) => currentState.hasOwnProperty(item.props.id)
        && (typeof item.props.visible === "boolean" ? item.props.visible
            : item.props.visible === undefined ? true : item.props.visible([activeTabId], currentState))), [activeTabId, currentState, filters]);
    const inhibitedFilters = (0, react_1.useMemo)(() => {
        const inhibited = new Set();
        if (externalMode) {
            return inhibited;
        }
        currentFilters.forEach((item) => {
            if (item.props.inhibit && item.props.inhibit.length > 0) {
                item.props.inhibit.forEach((id) => inhibited.add(id));
            }
        });
        return inhibited;
    }, [currentFilters, externalMode]);
    const handleClearClick = (0, react_1.useCallback)(() => {
        const newState = (0, filtersHelper_1.createStateObject)(filters, "defaultState");
        externalMode && setExternalModalState ? setExternalModalState(Object.assign({}, newState)) : setFiltersInternalModalState(newState);
    }, [externalMode, filters, setExternalModalState]);
    const handleApplyClick = (0, react_1.useCallback)(() => {
        const stateForApply = externalMode ? currentState : {};
        if (!externalMode) {
            Object.keys(currentState).forEach(key => {
                if (!inhibitedFilters.has(key)) {
                    stateForApply[key] = currentState[key];
                }
            });
        }
        onApply(stateForApply);
        onClose();
    }, [currentState, externalMode, inhibitedFilters, onApply, onClose]);
    const handleCancelClick = (0, react_1.useCallback)(() => {
        const newState = (0, filtersHelper_1.createStateObject)(filters, "state");
        externalMode && setExternalModalState ? setExternalModalState(Object.assign({}, newState)) : setFiltersInternalModalState(newState);
        onClose();
    }, [externalMode, filters, onClose, setExternalModalState]);
    const handleExternalModeClose = (0, react_1.useCallback)(() => {
        if (!(externalMode && initialExternalModalState && setExternalModalState)) {
            return;
        }
        setExternalModalState(initialExternalModalState);
        onClose();
    }, [externalMode, initialExternalModalState, onClose, setExternalModalState]);
    const toggleSaveModal = (0, react_1.useCallback)(() => {
        setIsSaveModalOpen(val => !val);
    }, []);
    const handleSaveFilters = (0, react_1.useCallback)((filterName) => {
        const stateForApply = externalMode ? currentState : {};
        if (!externalMode) {
            Object.keys(currentState).forEach(key => {
                if (!inhibitedFilters.has(key)) {
                    stateForApply[key] = currentState[key];
                }
            });
        }
        onSave && onSave(filterName, stateForApply);
    }, [externalMode, currentState, onSave, inhibitedFilters]);
    const modalItemChangeHandler = (0, react_1.useCallback)((id) => externalMode ? handleExternalFiltersStateChange(id) : handleInternalFiltersStateChange(id), [externalMode, handleExternalFiltersStateChange, handleInternalFiltersStateChange]);
    const tabsContent = (0, react_1.useMemo)(() => currentFilters.filter((item) => !inhibitedFilters.has(item.props.id))
        .map((item) => (0, jsx_runtime_1.jsx)(filtersModalItem_1.FiltersModalItem, { item: item, itemState: currentState[item.props.id], changeHandler: modalItemChangeHandler(item.props.id) }, item.props.id)), [currentFilters, inhibitedFilters, currentState, modalItemChangeHandler]);
    const memoizedActionButtons = (0, react_1.useCallback)((onSaveFn, onPinFn, isPin) => ((0, jsx_runtime_1.jsxs)("div", { className: "zen-filters-modal__header-buttons", children: [onSaveFn && (0, jsx_runtime_1.jsx)(button_1.Button, { type: "tertiary", "data-focusable": "save", className: "zen-filters-modal__save-button zen-filters-modal__header-button", title: translate("Save"), "aria-label": translate("Save"), onClick: onSaveFn, children: (0, jsx_runtime_1.jsx)(iconDisk_1.IconDisk, { description: translate("Save"), className: "svgIcon", size: iconDriveClassName ? "huge" : "large" }) }), onPinFn && (0, jsx_runtime_1.jsx)(button_1.Button, { type: "tertiary", "data-focusable": "pin", className: (0, classNames_1.classNames)(["zen-filters-modal__pin-button", isPin ? "zen-filters-modal__header-button--active" : "", "zen-filters-modal__header-button"]), title: translate("Pin"), "aria-label": translate("Pin"), onClick: onPinFn, children: (0, jsx_runtime_1.jsx)(iconPin2_1.IconPin2, { description: translate("Pin"), className: "svgIcon", size: iconDriveClassName ? "huge" : "large" }) })] })), [iconDriveClassName, translate]);
    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(modal_1.Modal, { className: (0, classNames_1.classNames)(["zen-filters-modal", isSaveModalOpen ? "zen-filters-modal--secondary" : ""]), isOpen: isOpen, onClose: externalMode ? handleExternalModeClose : onClose, title: translate("All Filters"), children: [memoizedActionButtons(onSave ? toggleSaveModal : undefined, onPin, isPinned), (0, jsx_runtime_1.jsx)(tabs_1.Tabs, { activeTabId: activeTabId, onTabChange: onTabChange, tabs: tabItems }), (0, jsx_runtime_1.jsx)("div", { className: "zen-filters-modal__content", children: tabsContent }), (0, jsx_runtime_1.jsx)(modal_1.Modal.TertiaryButton, { type: "tertiary", onClick: handleClearClick, children: translate("Clear") }), (0, jsx_runtime_1.jsx)(modal_1.Modal.SecondaryButton, { onClick: handleCancelClick, children: translate("Cancel") }), (0, jsx_runtime_1.jsx)(modal_1.Modal.PrimaryButton, { onClick: handleApplyClick, children: translate("Apply") })] }), (0, jsx_runtime_1.jsx)(filtersSaveModal_1.FiltersSaveModal, { isOpen: isSaveModalOpen, onClose: toggleSaveModal, onSave: handleSaveFilters })] });
};
exports.FiltersModal = FiltersModal;
