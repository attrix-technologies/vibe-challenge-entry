"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FiltersSearchList = exports.KEYWORD_TYPE = exports.KEYWORD_ID = exports.NO_TYPED_SEARCH_ITEM = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const list_1 = require("../../list/list");
const useLanguage_1 = require("../../utils/localization/useLanguage");
const button_1 = require("../../button/button");
const textIconButton_1 = require("../../textIconButton/textIconButton");
const iconChevronLeft_1 = require("../../icons/iconChevronLeft");
const textIconButton_2 = require("../../textIconButton/textIconButton");
const filtersSearchItemData_1 = require("./filtersSearchItemData");
const useMobile_1 = require("../../commonHelpers/hooks/useMobile");
const useDrive_1 = require("../../utils/theme/useDrive");
const classNames_1 = require("../../commonHelpers/classNames/classNames");
const filtersHelper_1 = require("../filtersHelper");
exports.NO_TYPED_SEARCH_ITEM = "noTypedSearchItem";
exports.KEYWORD_ID = "keywordId";
exports.KEYWORD_TYPE = "keyword";
const FiltersSearchList = ({ searchValue, searchData, recentSearches, searchSelection, handleSearchItemClick, onRemoveRecentSearchItem, handleRecentSearchItemClick, getIconByType }) => {
    const { translate } = (0, useLanguage_1.useLanguage)();
    const isSearchMode = Boolean(handleSearchItemClick && searchSelection);
    const isMobile = (0, useMobile_1.useMobile)();
    const isDrive = (0, useDrive_1.useDrive)();
    const [removedItems, setRemovedItems] = (0, react_1.useState)([]);
    const [historyMode, setHistoryMode] = (0, react_1.useState)(false);
    const waitingItemsLimit = 5;
    const isRecentSearchesMode = Boolean(recentSearches && handleRecentSearchItemClick && onRemoveRecentSearchItem);
    // Handle React Query errors
    (0, react_1.useEffect)(() => {
        if (isSearchMode && (searchData === null || searchData === void 0 ? void 0 : searchData.error)) {
            console.error("Failed to fetch search results. Error:", searchData.error);
        }
    }, [isSearchMode, searchData === null || searchData === void 0 ? void 0 : searchData.error]);
    // Reset history mode when search value changes
    (0, react_1.useEffect)(() => {
        if (historyMode && searchValue) {
            setHistoryMode(false);
        }
    }, [historyMode, searchValue]);
    const searchItems = (0, react_1.useMemo)(() => isSearchMode ? (searchData === null || searchData === void 0 ? void 0 : searchData.data) || [] : [], [isSearchMode, searchData === null || searchData === void 0 ? void 0 : searchData.data]);
    const recentItems = (0, react_1.useMemo)(() => isRecentSearchesMode ? (recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.data) || [] : [], [isRecentSearchesMode, recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.data]);
    const isLoading = searchValue && isSearchMode && (searchData === null || searchData === void 0 ? void 0 : searchData.isLoading) || (isRecentSearchesMode ? recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.isLoading : false) || false;
    const changeMode = (0, react_1.useCallback)(() => {
        setHistoryMode(prev => !prev);
        setRemovedItems([]);
        // Note: In React Query implementation, the parent component should handle
        // refetching data when switching between modes
    }, []);
    const handleRemove = (0, react_1.useCallback)((itemId) => () => {
        setRemovedItems(prev => [...prev, itemId]);
        onRemoveRecentSearchItem && onRemoveRecentSearchItem([itemId]);
    }, [onRemoveRecentSearchItem]);
    const handleRemoveAll = (0, react_1.useCallback)(() => {
        setRemovedItems(recentItems.map(item => item.id));
        onRemoveRecentSearchItem && onRemoveRecentSearchItem(recentItems.map(item => item.id));
        changeMode();
    }, [onRemoveRecentSearchItem, recentItems, changeMode]);
    const memoizedSearchItemClick = (0, react_1.useCallback)((itemId, itemType) => () => {
        const currentSearchItem = searchItems.find(item => item.id === itemId && item.type === itemType);
        currentSearchItem && handleSearchItemClick && handleSearchItemClick(currentSearchItem);
    }, [handleSearchItemClick, searchItems]);
    const memoizedRecentSearchItemClick = (0, react_1.useCallback)((itemId, itemType) => () => {
        const currentSearchItem = recentItems.find(item => item.id === itemId && item.type === itemType);
        currentSearchItem && handleRecentSearchItemClick && handleRecentSearchItemClick(currentSearchItem);
    }, [handleRecentSearchItemClick, recentItems]);
    const memoizedRecentDataArr = (0, react_1.useMemo)(() => recentItems.filter(item => !removedItems.includes(item.id)).reverse(), [recentItems, removedItems]);
    const memoizedRecentData = (0, react_1.useMemo)(() => (historyMode ? memoizedRecentDataArr : (searchValue && isSearchMode ? [] : memoizedRecentDataArr.slice(0, waitingItemsLimit))).map(item => ((0, jsx_runtime_1.jsx)(filtersSearchItemData_1.FiltersSearchItemData, { id: item.id, name: item.name, isActive: false, secondary: item.description, onClose: handleRemove(item.id), onClick: memoizedRecentSearchItemClick(item.id, item.type || exports.NO_TYPED_SEARCH_ITEM), icon: getIconByType(item.type), isMobile: isMobile, isDrive: isDrive }, `recent-${item.id}`))), [historyMode, memoizedRecentDataArr, searchValue, isSearchMode, handleRemove, memoizedRecentSearchItemClick, getIconByType, isMobile, isDrive]);
    const memoizedSearchData = (0, react_1.useMemo)(() => historyMode || !searchValue && isRecentSearchesMode ? [] : searchItems.slice(0, filtersHelper_1.MAX_TOTAL_RESULTS).map(item => ((0, jsx_runtime_1.jsx)(filtersSearchItemData_1.FiltersSearchItemData, { id: item.id, name: item.name, isActive: isSearchMode ? searchSelection.filter(el => el.id === item.id).some(el => el.type === (item.type || exports.NO_TYPED_SEARCH_ITEM)) || false : false, secondary: item.description, onClose: undefined, onClick: isSearchMode ? memoizedSearchItemClick(item.id, item.type || exports.NO_TYPED_SEARCH_ITEM) : undefined, icon: getIconByType(item.type), isMobile: isMobile, isDrive: isDrive }, `search-${item.id}-${item.type || exports.NO_TYPED_SEARCH_ITEM}`))), [historyMode, searchValue, isRecentSearchesMode, searchItems, isSearchMode, searchSelection, memoizedSearchItemClick, getIconByType, isMobile, isDrive]);
    const resultsToShow = (0, react_1.useMemo)(() => isRecentSearchesMode ? [...memoizedRecentData, ...memoizedSearchData]
        : memoizedSearchData, [isRecentSearchesMode, memoizedRecentData, memoizedSearchData]);
    return (0, jsx_runtime_1.jsxs)("div", { className: "zen-filters-search-list", children: [searchValue ? null : (0, jsx_runtime_1.jsxs)("div", { className: (0, classNames_1.classNames)(["zen-filters-search-list__header", isDrive ? (isMobile ? "zen-filters-search-list__header--drive" : "zen-filters-search-list__header--drive-tablet") : ""]), children: [historyMode ? (0, jsx_runtime_1.jsx)(textIconButton_1.TextIconButton, { className: "zen-filters-search-list__header-back-button", title: translate("Back"), type: "tertiary", onClick: changeMode, icon: iconChevronLeft_1.IconChevronLeft, iconPosition: textIconButton_2.ButtonIconPosition.Start })
                        : null, isRecentSearchesMode ? (0, jsx_runtime_1.jsx)("div", { className: "zen-filters-search-list__header-title", children: translate("Recent searches") }) : null, historyMode || !isRecentSearchesMode ? null : (0, jsx_runtime_1.jsx)(button_1.Button, { type: "tertiary", onClick: changeMode, children: translate("View history") }), historyMode && isRecentSearchesMode ? (0, jsx_runtime_1.jsx)(button_1.Button, { type: "tertiary", onClick: handleRemoveAll, children: translate("Clear all") }) : null] }), (0, jsx_runtime_1.jsx)(list_1.List, { className: "zen-filters-search-list__data", isLoading: isLoading, type: "data", waitingItems: waitingItemsLimit, children: resultsToShow })] });
};
exports.FiltersSearchList = FiltersSearchList;
