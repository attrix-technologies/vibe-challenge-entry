"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedItem = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const actionsButton_1 = require("../dataGrid/columns/actionsColumn/actionsButton");
const feedItem_1 = require("./feedItem/feedItem");
const dataFeedCell_1 = require("./dataFeedCell/dataFeedCell");
const actionsMenu_1 = require("../table/actions/actionsMenu");
const useVisibleColumns_1 = require("./hooks/useVisibleColumns");
const menu_1 = require("../menu/menu");
const getIconFromColumnComponent = (column, entity, isNested) => {
    const renderIcon = ("renderIcon" in column.columnComponent) ? column.columnComponent.renderIcon : undefined;
    if (renderIcon) {
        return column.columnComponent.renderIcon(entity, isNested);
    }
    return null;
};
const FeedItemInner = ({ columnsList, feedWrappers, expanded, collapsedColumnsQty, visibleColumns, visibleRows, entity, index, className = "", isRowExpanded, onExpandedChange, actions, actionsAsync, primaryActions }) => {
    const { mainColumns, secondaryColumns } = (0, useVisibleColumns_1.useVisibleColumns)(columnsList, expanded, { visibleColumns, collapsedColumnsQty });
    const mainColumnsMemoized = (0, react_1.useMemo)(() => mainColumns, [mainColumns]);
    const secondaryColumnsMemoized = (0, react_1.useMemo)(() => secondaryColumns, [secondaryColumns]);
    const isVisible = visibleRows.has(entity.id);
    const renderCells = (0, react_1.useCallback)((rowEntity, nested) => {
        const getActions = () => {
            let primaryActionsList = undefined;
            let primaryActionsContent = undefined;
            if (primaryActions) {
                if (typeof primaryActions === "function") {
                    primaryActionsList = primaryActions(rowEntity, !nested);
                }
                else if (Array.isArray(primaryActions)) {
                    primaryActionsList = primaryActions;
                }
                if (primaryActionsList && primaryActionsList.length > 0) {
                    primaryActionsContent = (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: primaryActionsList.map((action) => (0, jsx_runtime_1.jsx)(menu_1.Menu.Item, { id: action.id, icon: action.icon, name: action.createTitle(rowEntity), onClick: typeof action.handler === "function" ?
                                (_1, e) => { var _a; (_a = action.handler) === null || _a === void 0 ? void 0 : _a.call(action, entity, e.target); } :
                                undefined }, action.id)) });
                }
            }
            if (!actions && !actionsAsync && !primaryActionsList) {
                return null;
            }
            if (entity.isLoading) {
                return null;
            }
            if (typeof actions === "function") {
                return (0, jsx_runtime_1.jsx)(actionsMenu_1.ActionsMenu, { entity: rowEntity, isNested: !nested, render: actions, primaryActions: primaryActionsContent });
            }
            if (typeof actionsAsync === "function") {
                return (0, jsx_runtime_1.jsx)(actionsMenu_1.ActionsMenu, { entity: rowEntity, isNested: !nested, renderAsync: actionsAsync, primaryActions: primaryActionsContent });
            }
            return (0, jsx_runtime_1.jsx)(actionsButton_1.ActionsButton, { action: actions, entity: rowEntity });
        };
        const getRenderFeed = (column) => {
            var _a;
            const renderHeader = ((_a = column.columnComponent.renderHeader) === null || _a === void 0 ? void 0 : _a.bind(column.columnComponent)) || (() => column.title);
            return (title, feedEntity, isNested) => {
                if (column.columnComponent.renderFeed) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
                    const result = column.columnComponent.renderFeed(title, feedEntity, isNested);
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-unnecessary-type-assertion
                    if (isNested && ("renderNested" in column.columnComponent) && column.columnComponent.renderNested) {
                        return [result[0], column.columnComponent.renderNested.call(column.columnComponent, feedEntity)];
                    }
                    return result;
                }
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                const renderResult = column.columnComponent
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-unnecessary-type-assertion
                    ? isNested && ("renderNested" in column.columnComponent) && column.columnComponent.renderNested
                        ? column.columnComponent.renderNested.call(column.columnComponent, feedEntity)
                        : column.columnComponent.render.call(column.columnComponent, feedEntity, !nested)
                    : (feedEntity[column.id] || undefined);
                return [renderHeader(title), renderResult];
            };
        };
        const getRenderWrappers = (column) => (value, ent) => column.wrappers.reduce((result, wrapper) => wrapper.render(result, ent, false), value);
        const getFeedPlaceholder = (column) => {
            if (column.meta.renderFeedPlaceholder) {
                return column.meta.renderFeedPlaceholder;
            }
            return (title, ent) => [title, column.meta.renderPlaceholder ? column.meta.renderPlaceholder(ent) : "..."];
        };
        const getRenderFeedWrappers = (wrappers, ent, isNested) => 
        // eslint-disable-next-line react/display-name
        (primaryData, secondaryData) => {
            const feedResult = wrappers.reduce((result, wrapper) => wrapper(result[0], result[1], ent, isNested), [primaryData, secondaryData]);
            return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [feedResult[0], feedResult[1]] });
        };
        const mainColumnsData = mainColumnsMemoized.map(column => {
            const renderFeed = getRenderFeed(column);
            const renderWrappers = getRenderWrappers(column);
            const feedPlaceholder = getFeedPlaceholder(column);
            return (0, jsx_runtime_1.jsx)(dataFeedCell_1.DataFeedCell, { limited: false, visibleOnHover: false, isVisible: isVisible, title: column.title, render: renderFeed, renderWrappers: renderWrappers, renderPlaceholder: feedPlaceholder, defaultValue: column.meta.defaultValue, entity: rowEntity, isNested: !nested }, `${entity.id}-${column.id}`);
        });
        const secondaryColumnsData = secondaryColumnsMemoized.map(column => {
            const renderFeed = getRenderFeed(column);
            const renderWrappers = getRenderWrappers(column);
            const feedPlaceholder = getFeedPlaceholder(column);
            return (0, jsx_runtime_1.jsx)(dataFeedCell_1.DataFeedCell, { limited: false, visibleOnHover: false, isVisible: isVisible, title: column.title, render: renderFeed, renderWrappers: renderWrappers, renderPlaceholder: feedPlaceholder, defaultValue: column.meta.defaultValue, entity: rowEntity, isNested: !nested }, `${entity.id}-${column.id}`);
        });
        const onItemClick = nested && onExpandedChange
            ? () => onExpandedChange(!isRowExpanded)
            : undefined;
        const icon = getIconFromColumnComponent(mainColumnsMemoized[0], rowEntity, !nested);
        const actionsNode = getActions();
        const renderFeedWrappers = getRenderFeedWrappers(feedWrappers, rowEntity, !nested);
        const key = !nested ? `nested_${rowEntity.id}` : rowEntity.id;
        return (0, jsx_runtime_1.jsx)(feedItem_1.DataFeedItem, { id: entity.id, index: index, onClick: onItemClick, className: className, icon: icon, identifier: mainColumnsData[0], primaryData: mainColumnsData.slice(1), secondaryData: secondaryColumnsData, actions: actionsNode, nestedData: nested && nested.length ? nested : undefined, renderFeedWrappers: renderFeedWrappers }, key);
    }, [className, feedWrappers, index, isRowExpanded, isVisible, mainColumnsMemoized, onExpandedChange, secondaryColumnsMemoized, actions, actionsAsync, primaryActions, entity]);
    const nestedCells = (0, react_1.useMemo)(() => (entity.children && isRowExpanded ? entity.children : []).map(nestedEntity => renderCells(nestedEntity)), [entity.children, isRowExpanded, renderCells]);
    const cells = (0, react_1.useMemo)(() => renderCells(entity, nestedCells), [entity, nestedCells, renderCells]);
    return cells;
};
exports.FeedItem = (0, react_1.memo)(FeedItemInner);
